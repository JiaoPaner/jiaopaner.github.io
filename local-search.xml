<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>elasticsearch 教程</title>
    <link href="/2019/12/30/elasticsearch%20%E6%95%99%E7%A8%8B/"/>
    <url>/2019/12/30/elasticsearch%20%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="elasticsearch-教程"><a href="#elasticsearch-教程" class="headerlink" title="elasticsearch 教程"></a>elasticsearch 教程</h1><p><img src="/images/elasticsearch/1.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="安装、启动、测试"><a href="#安装、启动、测试" class="headerlink" title="安装、启动、测试"></a>安装、启动、测试</h2><p>elasticsearch下载地址:<a href="https://www.elastic.co/cn/downloads/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/elasticsearch</a><br>kibana下载地址:<a href="https://www.elastic.co/cn/downloads/kibana" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/kibana</a><br><strong>启动</strong><br>1.elasticsearch<br>./elasticsearch-7.5.1/bin/elasticsearch 默认端口：9200<br>浏览器访问：localhost:9200</p><pre><code class="lang-bash">{  &quot;name&quot; : &quot;jiaopandeMacBook-Pro.local&quot;,  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,  &quot;cluster_uuid&quot; : &quot;5vku_94_SjevMGVYIo3RYg&quot;,  &quot;version&quot; : {    &quot;number&quot; : &quot;7.5.1&quot;,    &quot;build_flavor&quot; : &quot;default&quot;,    &quot;build_type&quot; : &quot;tar&quot;,    &quot;build_hash&quot; : &quot;3ae9ac9a93c95bd0cdc054951cf95d88e1e18d96&quot;,    &quot;build_date&quot; : &quot;2019-12-16T22:57:37.835892Z&quot;,    &quot;build_snapshot&quot; : false,    &quot;lucene_version&quot; : &quot;8.3.0&quot;,    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;  },  &quot;tagline&quot; : &quot;You Know, for Search&quot;}</code></pre><p>2.kibana<br>配置kibana-7.5.1-darwin-x86_64/config/kibana.yml</p><pre><code class="lang-bash">server.host: &quot;localhost&quot;elasticsearch.hosts: [&quot;http://localhost:9200&quot;]</code></pre><p>./kibana-7.5.1-darwin-x86_64/bin/kibana<br>浏览器访问：localhost:5601<br><img src="/images/elasticsearch/2.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>测试</strong><br>kibana Dev Tools<br><img src="/images/elasticsearch/3.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><p>创建索引:</p><pre><code>PUT http://127.0.0.1:9200/test_index</code></pre><p>删除索引</p><pre><code>DELETE http://127.0.0.1:9200/test_index</code></pre><h3 id="document"><a href="#document" class="headerlink" title="document"></a>document</h3><p>创建文档：</p><pre><code>PUT http://127.0.0.1:9200/test_index/item/1{&quot;name&quot;:&quot;jiaopan&quot;,&quot;age&quot;:25}</code></pre><p>查询文档：</p><pre><code>GET http://127.0.0.1:9200/test_index/item/1</code></pre><p>更新文档</p><pre><code>POST http://127.0.0.1:9200/test_index/item/1/_update{    &quot;doc&quot;:{        &quot;name&quot;:&quot;jp&quot;    }}</code></pre><p>删除文档</p><pre><code>DELETE http://127.0.0.1:9200/test_index/item/1</code></pre><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>1.query string search</p><pre><code>GET http://127.0.0.1:9200/test_index/item/_searchGET http://127.0.0.1:9200/test_index/item/_search?q=name:jp&amp;sort=age:desc</code></pre><p>2.query DSL</p><pre><code>#查询所有GET http://127.0.0.1:9200/test_index/item/_search{    &quot;query&quot;:{        &quot;match_all&quot;:{}     }}#条件查询GET http://127.0.0.1:9200/test_index/item/_search{    &quot;query&quot;:{        &quot;match&quot;:{&quot;name&quot;:&quot;jp&quot;}     },    &quot;sort&quot;:[        {&quot;age&quot;:&quot;desc&quot;}    ]}#分页查询GET http://127.0.0.1:9200/test_index/item/_search{    &quot;query&quot;:{        &quot;match_all&quot;:{}     },    &quot;from&quot;:1,    &quot;size&quot;:2}#指定结果的字段GET http://127.0.0.1:9200/test_index/item/_search{    &quot;query&quot;:{        &quot;match_all&quot;:{}     },    &quot;_source“：[&quot;name&quot;]}</code></pre><p>3.query filter</p><pre><code>GET http://127.0.0.1:9200/test_index/item/_search{    &quot;query&quot;:{        &quot;bool&quot;:{            &quot;must&quot;:{                &quot;name&quot;:&quot;jp&quot; #name必须包含jp            },            &quot;filter&quot;:{                &quot;range&quot;:{                    &quot;age&quot;:{&quot;gt&quot;:18} #年龄大于18                }            }        }     }}</code></pre><p>4.full-text search(全文检索)</p><pre><code>GET http://127.0.0.1:9200/test_index/item/_search{    &quot;query&quot;:{        &quot;match&quot;:{            &quot;name&quot;:&quot;jp jiaopan&quot; #匹配jp/jiapan/jp或jiaopan        }     }}</code></pre><p>5.phrase search(短语搜索)</p><pre><code>GET http://127.0.0.1:9200/test_index/item/_search{    &quot;query&quot;:{        &quot;match_phrase&quot;:{            &quot;name&quot;:&quot;jp jiaopan&quot; #只匹配jp jiaopan        }     }}</code></pre><p>6.highlight search(高亮搜索结果)</p><pre><code>GET http://127.0.0.1:9200/test_index/item/_search{    &quot;query&quot;:{        &quot;match&quot;:{            &quot;name&quot;:&quot;jp&quot;         }     }，    “highlight“：{        &quot;fields&quot;:{            &quot;name&quot;:{} #高亮的字段        }    }}</code></pre><h3 id="mget-批量查询"><a href="#mget-批量查询" class="headerlink" title="mget-批量查询"></a>mget-批量查询</h3><h3 id="bulk"><a href="#bulk" class="headerlink" title="bulk"></a>bulk</h3><h3 id="multi-index，-all，scroll"><a href="#multi-index，-all，scroll" class="headerlink" title="multi-index，_all，scroll"></a>multi-index，_all，scroll</h3><h3 id="聚合分析"><a href="#聚合分析" class="headerlink" title="聚合分析"></a>聚合分析</h3><pre><code>#以&quot;tags&quot;字段分组GET http://127.0.0.1:9200/test_index/item/_search{    &quot;aggs&quot;:{        &quot;group_by_tags&quot;:{ //聚合名称(自定义)            &quot;terms&quot;:{                “field”：“tags” //分组字段            }         }     }}#先查询再分组GET http://127.0.0.1:9200/test_index/item/_search{    &quot;query&quot;:{        &quot;match&quot;:{            &quot;name&quot;:&quot;name&quot;         }     },    &quot;aggs&quot;:{        &quot;group_by_tags&quot;:{ //聚合名称(自定义)            &quot;terms&quot;:{                “field”：“tags” //分组字段            }         }     }}#分组数据再分析GET http://127.0.0.1:9200/test_index/item/_search{    &quot;aggs&quot;:{        &quot;group_by_tags&quot;:{ //聚合名称(自定义)            &quot;terms&quot;:{                “field”：“tags” //分组字段            },            &quot;aggs&quot;:{                &quot;avg_price&quot;:{&quot;field&quot;:&quot;price&quot;}            }         }     }}GET http://127.0.0.1:9200/test_index/item/_search{    &quot;aggs&quot;:{        &quot;group_by_tags&quot;:{ //聚合名称(自定义)            &quot;terms&quot;:{                “field”：“tags”, //分组字段                &quot;order&quot;:{&quot;avg_price&quot;:&quot;desc&quot;} //排序            },            &quot;aggs&quot;:{                &quot;avg_price&quot;:{&quot;field&quot;:&quot;price&quot;}            }         }     }}</code></pre><h3 id="mapping"><a href="#mapping" class="headerlink" title="mapping"></a>mapping</h3><h3 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h3><pre><code>GET /_analyze{    &quot;analyzer&quot;:&quot;standard&quot;,    &quot;text&quot;:&quot;text to analyze&quot;}</code></pre><p>备份资料：<br>1.索引-settings</p><pre><code>PUT /test_index/{  &quot;settings&quot;: {    &quot;index&quot;:{      &quot;number_of_shards&quot;:1,      &quot;number_of_replicas&quot;:1    }  }}{  &quot;acknowledged&quot; : true,  &quot;shards_acknowledged&quot; : true,  &quot;index&quot; : &quot;test_index&quot;}GET /test_index/_settings</code></pre><p>2.mget</p><h1 id="note"><a href="#note" class="headerlink" title="note"></a>note</h1><pre><code class="lang-bash">安装中文分词./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.5.1/elasticsearch-analysis-ik-7.5.1.zipGET /test_index/_mappingDELETE /test_indexPUT /test_index{  &quot;settings&quot;: {    &quot;analysis&quot;: {      &quot;analyzer&quot;: {        &quot;default&quot;: {          &quot;type&quot;: &quot;ik_max_word&quot;        }      }    }  },  &quot;mappings&quot;: {    &quot;properties&quot;: {      &quot;title&quot;:{        &quot;type&quot;: &quot;text&quot;      },      &quot;content&quot;:{        &quot;type&quot;: &quot;text&quot;      },      &quot;type&quot;:{        &quot;type&quot;: &quot;keyword&quot;      },      &quot;tags&quot;:{        &quot;type&quot;: &quot;text&quot;       },      &quot;location&quot;:{        &quot;type&quot;: &quot;geo_point&quot;      },      &quot;userid&quot;:{        &quot;type&quot;: &quot;keyword&quot;      }    }  }}GET /_analyze{  &quot;analyzer&quot;: &quot;ik_max_word&quot;,  &quot;text&quot;: &quot;宾馆&quot;}GET /test_index/_search{  &quot;query&quot;: {&quot;match_all&quot;: {}},  &quot;from&quot;: 0,   &quot;size&quot;: 20}POST /test_index/_bulk{&quot;index&quot;:{&quot;_id&quot;:1}}{&quot;title&quot;:&quot;五馅包&quot;,&quot;content&quot;:&quot;武隆县城包子店&quot;,&quot;type&quot;:&quot;delicious&quot;,&quot;location&quot;:&quot;29.3283854700,107.7670669000&quot;,&quot;tags&quot;:&quot;美食 吃&quot;}{&quot;index&quot;:{&quot;_id&quot;:2}}{&quot;title&quot;:&quot;奇香手撕鸭&quot;,&quot;content&quot;:&quot;武隆县城手撕鸭、美味可口，可邮寄&quot;,&quot;type&quot;:&quot;delicious&quot;,&quot;location&quot;:&quot;29.3280674400,107.7671581000&quot;,&quot;tags&quot;:&quot;美食 吃&quot;}{&quot;index&quot;:{&quot;_id&quot;:3}}{&quot;title&quot;:&quot;友家宾馆&quot;,&quot;content&quot;:&quot;打折,大床房，南北通透，有空调，有Wi-Fi&quot;,&quot;type&quot;:&quot;hotel&quot;,&quot;location&quot;:&quot;29.3277540900,107.7667235800&quot;,&quot;tags&quot;:&quot;住宿&quot;}{&quot;index&quot;:{&quot;_id&quot;:4}}{&quot;title&quot;:&quot;仙童公寓&quot;,&quot;content&quot;:&quot;特价公寓房、胶囊房间&quot;,&quot;type&quot;:&quot;hotel&quot;,&quot;location&quot;:&quot;29.3279318100,107.7663695300&quot;,&quot;tags&quot;:&quot;住宿&quot;}{&quot;index&quot;:{&quot;_id&quot;:5}}{&quot;title&quot;:&quot;凯迪酒店&quot;,&quot;content&quot;:&quot;高档酒店&quot;,&quot;type&quot;:&quot;hotel&quot;,&quot;location&quot;:&quot;29.3283307500,107.7663570600&quot;,&quot;tags&quot;:&quot;住宿&quot;}{&quot;index&quot;:{&quot;_id&quot;:6}}{&quot;title&quot;:&quot;疯狂烤翅&quot;,&quot;content&quot;:&quot;吃出疯狂，吃出味道&quot;,&quot;type&quot;:&quot;delicious&quot;,&quot;location&quot;:&quot;29.3258286100,107.7662980600&quot;,&quot;tags&quot;:&quot;美食 吃&quot;}{&quot;index&quot;:{&quot;_id&quot;:7}}{&quot;title&quot;:&quot;江辉宾馆&quot;,&quot;content&quot;:&quot;评价宾馆、评价住宿&quot;,&quot;type&quot;:&quot;hotel&quot;,&quot;location&quot;:&quot;29.3262214700,107.7646243600&quot;,&quot;tags&quot;:&quot;住宿 宾馆&quot;}{&quot;index&quot;:{&quot;_id&quot;:8}}{&quot;title&quot;:&quot;农村饭&quot;,&quot;content&quot;:&quot;土家味道、家常菜&quot;,&quot;type&quot;:&quot;delicious&quot;,&quot;location&quot;:&quot;29.3316091700,107.7650535100&quot;,&quot;tags&quot;:&quot;美食 吃&quot;}{&quot;index&quot;:{&quot;_id&quot;:9}}{&quot;title&quot;:&quot;汉平美食城&quot;,&quot;content&quot;:&quot;汉平美食城,较偏远&quot;,&quot;type&quot;:&quot;delicious&quot;,&quot;location&quot;:&quot;29.3213433000,107.7405488500&quot;,&quot;tags&quot;:&quot;美食 吃&quot;}GET /test_index/_search{  &quot;query&quot;: {    &quot;term&quot;: {      &quot;title&quot;: {        &quot;value&quot;: &quot;住宿&quot;      }    }  }}GET /test_index/_search{  &quot;query&quot;: {    &quot;bool&quot;: {      &quot;should&quot;: [        {          &quot;term&quot;: {            &quot;title&quot;: {              &quot;value&quot;: &quot;美食&quot;            }          }        },        {          &quot;term&quot;: {            &quot;content&quot;: {              &quot;value&quot;: &quot;住宿&quot;            }          }        }      ]    }  }}GET /test_index/_search{  &quot;query&quot;: {    &quot;match&quot;: {      &quot;title&quot;:&quot;武隆&quot;    }  },   &quot;from&quot;: 0,   &quot;size&quot;: 20}GET /test_index/_search{  &quot;from&quot;:0,&quot;size&quot;:20,  &quot;query&quot;:{    &quot;bool&quot;:{      &quot;must&quot;:[{        &quot;dis_max&quot;:{&quot;tie_breaker&quot;:0.0,&quot;queries&quot;:[{          &quot;match&quot;:{&quot;title&quot;:{&quot;query&quot;:&quot;美食&quot;,&quot;operator&quot;:&quot;OR&quot;,&quot;prefix_length&quot;:0,&quot;max_expansions&quot;:50,&quot;fuzzy_transpositions&quot;:true,&quot;lenient&quot;:false,&quot;zero_terms_query&quot;:&quot;NONE&quot;,&quot;auto_generate_synonyms_phrase_query&quot;:true,&quot;boost&quot;:1.0}}},          {&quot;match&quot;:{&quot;content&quot;:{&quot;query&quot;:&quot;美食&quot;,&quot;operator&quot;:&quot;OR&quot;,&quot;prefix_length&quot;:0,&quot;max_expansions&quot;:50,&quot;fuzzy_transpositions&quot;:true,&quot;lenient&quot;:false,&quot;zero_terms_query&quot;:&quot;NONE&quot;,&quot;auto_generate_synonyms_phrase_query&quot;:true,&quot;boost&quot;:1.0}}},          {&quot;match&quot;:{&quot;tags&quot;:{&quot;query&quot;:&quot;美食&quot;,&quot;operator&quot;:&quot;OR&quot;,&quot;prefix_length&quot;:0,&quot;max_expansions&quot;:50,&quot;fuzzy_transpositions&quot;:true,&quot;lenient&quot;:false,&quot;zero_terms_query&quot;:&quot;NONE&quot;,&quot;auto_generate_synonyms_phrase_query&quot;:true,&quot;boost&quot;:1.0}}}],&quot;boost&quot;:1.0}},          {&quot;geo_distance&quot;:{&quot;location&quot;:[107.76677549,29.32815771],&quot;distance&quot;:300.0,&quot;distance_type&quot;:&quot;plane&quot;,&quot;validation_method&quot;:&quot;STRICT&quot;,&quot;ignore_unmapped&quot;:false,&quot;boost&quot;:1.0}}],    &quot;should&quot;:[{&quot;term&quot;:{&quot;type&quot;:{&quot;value&quot;:&quot;route&quot;,&quot;boost&quot;:1.0}}},{&quot;term&quot;:{&quot;type&quot;:{&quot;value&quot;:&quot;playing&quot;,&quot;boost&quot;:1.0}}},{&quot;term&quot;:{&quot;type&quot;:{&quot;value&quot;:&quot;travel&quot;,&quot;boost&quot;:1.0}}},{&quot;term&quot;:{&quot;type&quot;:{&quot;value&quot;:&quot;activity&quot;,&quot;boost&quot;:1.0}}},{&quot;term&quot;:{&quot;type&quot;:{&quot;value&quot;:&quot;scenery&quot;,&quot;boost&quot;:1.0}}},{&quot;term&quot;:{&quot;type&quot;:{&quot;value&quot;:&quot;hotel&quot;,&quot;boost&quot;:1.0}}},{&quot;term&quot;:{&quot;type&quot;:{&quot;value&quot;:&quot;delicious&quot;,&quot;boost&quot;:1.0}}},{&quot;term&quot;:{&quot;type&quot;:{&quot;value&quot;:&quot;live&quot;,&quot;boost&quot;:1.0}}},{&quot;term&quot;:{&quot;type&quot;:{&quot;value&quot;:&quot;ticket&quot;,&quot;boost&quot;:1.0}}},{&quot;term&quot;:{&quot;type&quot;:{&quot;value&quot;:&quot;expert&quot;,&quot;boost&quot;:1.0}}}],&quot;adjust_pure_negative&quot;:true,&quot;boost&quot;:1.0}},    &quot;sort&quot;:[{&quot;_geo_distance&quot;:{&quot;location&quot;:[{&quot;lat&quot;:29.32815771,&quot;lon&quot;:107.76677549},{&quot;lat&quot;:29.32815771,&quot;lon&quot;:107.76677549}],&quot;unit&quot;:&quot;m&quot;,&quot;distance_type&quot;:&quot;arc&quot;,&quot;order&quot;:&quot;asc&quot;,&quot;validation_method&quot;:&quot;STRICT&quot;,&quot;ignore_unmapped&quot;:false}}]}{&quot;from&quot;:0,&quot;size&quot;:20,&quot;query&quot;:{&quot;bool&quot;:{&quot;must&quot;:[{&quot;geo_distance&quot;:{&quot;location&quot;:[107.76677549,29.32815771],&quot;distance&quot;:300.0,&quot;distance_type&quot;:&quot;plane&quot;,&quot;validation_method&quot;:&quot;STRICT&quot;,&quot;ignore_unmapped&quot;:false,&quot;boost&quot;:1.0}}],  &quot;should&quot;:[    {&quot;term&quot;:{&quot;type&quot;:{&quot;value&quot;:&quot;route&quot;,&quot;boost&quot;:1.0}}},    {&quot;term&quot;:{&quot;type&quot;:{&quot;value&quot;:&quot;playing&quot;,&quot;boost&quot;:1.0}}},    {&quot;term&quot;:{&quot;type&quot;:{&quot;value&quot;:&quot;travel&quot;,&quot;boost&quot;:1.0}}},    {&quot;term&quot;:{&quot;type&quot;:{&quot;value&quot;:&quot;activity&quot;,&quot;boost&quot;:1.0}}},    {&quot;term&quot;:{&quot;type&quot;:{&quot;value&quot;:&quot;scenery&quot;,&quot;boost&quot;:1.0}}},    {&quot;term&quot;:{&quot;type&quot;:{&quot;value&quot;:&quot;hotel&quot;,&quot;boost&quot;:1.0}}},    {&quot;term&quot;:{&quot;type&quot;:{&quot;value&quot;:&quot;delicious&quot;,&quot;boost&quot;:1.0}}},    {&quot;term&quot;:{&quot;type&quot;:{&quot;value&quot;:&quot;live&quot;,&quot;boost&quot;:1.0}}},    {&quot;term&quot;:{&quot;type&quot;:{&quot;value&quot;:&quot;ticket&quot;,&quot;boost&quot;:1.0}}},    {&quot;term&quot;:{&quot;type&quot;:{&quot;value&quot;:&quot;expert&quot;,&quot;boost&quot;:1.0}}},    {&quot;dis_max&quot;:{&quot;tie_breaker&quot;:0.0,&quot;queries&quot;:[{&quot;match&quot;:{&quot;title&quot;:{&quot;query&quot;:&quot;美食&quot;,&quot;operator&quot;:&quot;OR&quot;,&quot;prefix_length&quot;:0,&quot;max_expansions&quot;:50,&quot;fuzzy_transpositions&quot;:true,&quot;lenient&quot;:false,&quot;zero_terms_query&quot;:&quot;NONE&quot;,&quot;auto_generate_synonyms_phrase_query&quot;:true,&quot;boost&quot;:1.0}}},{&quot;match&quot;:{&quot;content&quot;:{&quot;query&quot;:&quot;美食&quot;,&quot;operator&quot;:&quot;OR&quot;,&quot;prefix_length&quot;:0,&quot;max_expansions&quot;:50,&quot;fuzzy_transpositions&quot;:true,&quot;lenient&quot;:false,&quot;zero_terms_query&quot;:&quot;NONE&quot;,&quot;auto_generate_synonyms_phrase_query&quot;:true,&quot;boost&quot;:1.0}}},{&quot;match&quot;:{&quot;tags&quot;:{&quot;query&quot;:&quot;美食&quot;,&quot;operator&quot;:&quot;OR&quot;,&quot;prefix_length&quot;:0,&quot;max_expansions&quot;:50,&quot;fuzzy_transpositions&quot;:true,&quot;lenient&quot;:false,&quot;zero_terms_query&quot;:&quot;NONE&quot;,&quot;auto_generate_synonyms_phrase_query&quot;:true,&quot;boost&quot;:1.0}}}],&quot;boost&quot;:1.0}}],&quot;adjust_pure_negative&quot;:true,&quot;boost&quot;:1.0}},&quot;sort&quot;:[{&quot;_geo_distance&quot;:{&quot;location&quot;:[{&quot;lat&quot;:29.32815771,&quot;lon&quot;:107.76677549},{&quot;lat&quot;:29.32815771,&quot;lon&quot;:107.76677549}],&quot;unit&quot;:&quot;m&quot;,&quot;distance_type&quot;:&quot;arc&quot;,&quot;order&quot;:&quot;asc&quot;,&quot;validation_method&quot;:&quot;STRICT&quot;,&quot;ignore_unmapped&quot;:false}}]}</code></pre>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>android使用opencv native方式环境搭建</title>
    <link href="/2019/11/01/android%E4%BD%BF%E7%94%A8opencv%20native%E6%96%B9%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2019/11/01/android%E4%BD%BF%E7%94%A8opencv%20native%E6%96%B9%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>1.opencv下载：<a href="https://opencv.org/releases/" target="_blank" rel="noopener">https://opencv.org/releases/</a> 解压后为OpenCV-android-sdk</p><p><img src="/images/opencv3/41.png" srcset="/img/loading.gif" alt=""></p><p>2.创建初始Android项目</p><p><img src="/images/opencv3/42.png" srcset="/img/loading.gif" alt=""></p><p>3.在app/src/main目录下新建jniLibs目录，在app/src/main/cpp目录下新建include目录和src目录</p><p>将OpenCV-android-sdk/sdk/native/libs下所有目录复制到jniLibs目录中</p><p>将OpenCV-android-sdk/sdk/native/jni/include下的所有目录复制到app/src/main/cpp/include目录中</p><p>移动app/src/main/cpp/CMakeLists.txt至app目录下 </p><p>移动app/src/main/cpp/native-lib.cpp至app/src/main/cpp/src/native-lib.cpp</p><p><img src="/images/opencv3/43.png" srcset="/img/loading.gif" alt=""></p><p>4.配置文件修改</p><p><strong>CMakeLists.txt</strong></p><pre><code># For more information about using CMake with Android Studio, read the# documentation: https://d.android.com/studio/projects/add-native-code.html# Sets the minimum version of CMake required to build the native library.cmake_minimum_required(VERSION 3.4.1)include_directories(${CMAKE_SOURCE_DIR}/src/main/cpp/include)#opencv 4.0.1add_library(libopencv_java4 SHARED IMPORTED)set_target_properties(libopencv_java4 PROPERTIES IMPORTED_LOCATION        ${CMAKE_SOURCE_DIR}/src/main/jniLibs/${ANDROID_ABI}/libopencv_java4.so)#localadd_library(native-lib SHARED src/main/cpp/src/native-lib.cpp)find_library(log-lib log )target_link_libraries(native-lib libopencv_java4 ${log-lib} )</code></pre><p><strong>app/build.gradle</strong></p><pre><code class="lang-bash">apply plugin: &#39;com.android.application&#39;android {    compileSdkVersion 29    buildToolsVersion &quot;29.0.2&quot;    defaultConfig {        applicationId &quot;com.wisesoft.wiseface&quot;        minSdkVersion 21        targetSdkVersion 29        versionCode 1        versionName &quot;1.0&quot;        testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot;        externalNativeBuild {            cmake {                cppFlags &quot;-std=c++11 -frtti -fexceptions&quot;                abiFilters &#39;armeabi-v7a&#39;                arguments &quot;-DANDROID_STL=c++_shared&quot;            }        }        ndk{            abiFilters &#39;armeabi-v7a&#39;        }    }    sourceSets{        main{            jniLibs.srcDirs = [&#39;src/main/jniLibs&#39;]            jni.srcDirs = []        }    }    buildTypes {        release {            minifyEnabled false            proguardFiles getDefaultProguardFile(&#39;proguard-android-optimize.txt&#39;), &#39;proguard-rules.pro&#39;            ndk{                abiFilters &#39;armeabi-v7a&#39;            }        }    }    externalNativeBuild {        cmake {            path &quot;CMakeLists.txt&quot;        }    }}dependencies {    implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])    implementation &#39;androidx.appcompat:appcompat:1.1.0&#39;    implementation &#39;androidx.constraintlayout:constraintlayout:1.1.3&#39;    testImplementation &#39;junit:junit:4.12&#39;    androidTestImplementation &#39;androidx.test:runner:1.2.0&#39;    androidTestImplementation &#39;androidx.test.espresso:espresso-core:3.2.0&#39;}</code></pre><p>5.刷新配置点击Sync Now并refresh c++</p><p><img src="/images/opencv3/44.png" srcset="/img/loading.gif" alt=""></p><p>6.使用原生opencv c++ 代码进行开发</p><pre><code class="lang-c++">#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;opencv2/opencv.hpp&gt;extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_wisesoft_wiseface_MainActivity_stringFromJNI(        JNIEnv* env,        jobject /* this */) {    std::string hello = &quot;Hello from C++&quot;;    cv::Mat mat;    return env-&gt;NewStringUTF(hello.c_str());}</code></pre>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>opencv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习模型转换</title>
    <link href="/2019/10/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>/2019/10/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="mxnet模型转tensorflow模型"><a href="#mxnet模型转tensorflow模型" class="headerlink" title="mxnet模型转tensorflow模型"></a>mxnet模型转tensorflow模型</h3><p>requirements：pip install mxnet tensorflow</p><h5 id="1-安装mmdnn"><a href="#1-安装mmdnn" class="headerlink" title="1.安装mmdnn"></a>1.安装mmdnn</h5><p>pip install -U git+<a href="https://github.com/Microsoft/MMdnn.git@master" target="_blank" rel="noopener">https://github.com/Microsoft/MMdnn.git@master</a></p><h5 id="2-模型下载"><a href="#2-模型下载" class="headerlink" title="2.模型下载"></a>2.模型下载</h5><p><a href="https://pan.baidu.com/s/1If28BkHde4fiuweJrbicVA" target="_blank" rel="noopener">https://pan.baidu.com/s/1If28BkHde4fiuweJrbicVA</a></p><h5 id="3-mxnet模型转IR"><a href="#3-mxnet模型转IR" class="headerlink" title="3.mxnet模型转IR"></a>3.mxnet模型转IR</h5><pre><code class="lang-bash">python -m mmdnn.conversion._script.convertToIR -f mxnet -n model-symbol.json -w model-0000.params -d tf_model --inputShape 3,112,112 #info:IR network structure is saved as [tf_model.json].#可视化文件IR network structure is saved as [tf_model.pb].#网络结构IR weights are saved as [tf_model.npy].#权重参数</code></pre><p>若报错：AttributeError: ‘NoneType’ object has no attribute ‘asnumpy’ line 410</p><p>解决：找到python3.6/site-packages/mmdnn/conversion/mxnet/mxnet_parser.py 410 行 修改如下：</p><pre><code>weight = self.weight_data.get(&quot;fc1_weight&quot;).asnumpy().transpose((1, 0))</code></pre><p>参考：<a href="https://github.com/microsoft/MMdnn/issues/231" target="_blank" rel="noopener">https://github.com/microsoft/MMdnn/issues/231</a></p><h5 id="4-生成tf-model-py-用于还原神经网络结构"><a href="#4-生成tf-model-py-用于还原神经网络结构" class="headerlink" title="4.生成tf_model.py 用于还原神经网络结构"></a>4.生成tf_model.py 用于还原神经网络结构</h5><p>调用tf_model.py中的KitModel函数加载npy权重参数可重新生成原网络框架</p><pre><code class="lang-bash">python -m mmdnn.conversion._script.IRToCode -f tensorflow --IRModelPath tf_model.pb --IRWeightPath tf_model.npy --dstModelPath tf_model.py#info:Parse file [tf_model.pb] with binary format successfully.Target network code snippet is saved as [tf_model.py].</code></pre><h5 id="5-验证模型输出结果是否一致"><a href="#5-验证模型输出结果是否一致" class="headerlink" title="5.验证模型输出结果是否一致"></a>5.验证模型输出结果是否一致</h5><p>5.1 test_mxnet.py</p><pre><code class="lang-python">import mxnet as mxfrom tensorflow.contrib.keras.api.keras.preprocessing import imageimport numpy as npfrom collections import namedtupleBatch = namedtuple(&#39;Batch&#39;, [&#39;data&#39;])ctx = mx.cpu(0)#加载模型sym, arg_params, aux_params = mx.model.load_checkpoint(&#39;mobile/model&#39;, 0) #mobile文件夹下为 model-symbol.json -w model-0000.paramsmod = mx.mod.Module(symbol = sym, context= ctx, label_names= None)mod.bind(for_training=False, data_shapes=[(&#39;data&#39;, (1, 3, 112, 112))], label_shapes= mod._label_shapes)mod.set_params(arg_params, aux_params, allow_missing= True)path = &#39;face.jpeg&#39;img = image.load_img(path, target_size = (112, 112))img = image.img_to_array(img)img = img[..., ::-1]img = np.expand_dims(img, 0).transpose((0,3,1,2))mod.forward(Batch([mx.nd.array(img)]))prob = mod.get_outputs()[0].asnumpy()prob = np.squeeze(prob)print(prob)</code></pre><p><strong><em>执行命令</em></strong></p><pre><code class="lang-python">python test_mxnet.py #info:[17:39:57] src/nnvm/legacy_json_util.cc:209: Loading symbol saved by previous version v1.0.0. Attempting to upgrade...[17:39:57] src/nnvm/legacy_json_util.cc:217: Symbol successfully upgraded![ 0.344491    0.10190611 -0.24501216  0.6819046   0.88096315  0.347766 -0.94702303 -0.67586213 -0.43900824  0.81431276 -0.4899036  -0.43025514 -0.50644076 -0.27366892  0.63601595 -0.5352368   0.13765731  0.40842316  0.76525426 -0.8959755   0.42129532 -0.38290668  0.02023177 -0.14840017  0.9108279  -0.27738237 -0.6017331  -0.214954    0.37644073  0.48894417 -0.8824417   0.31846505  0.19936565  0.27296835  1.5621403   0.4327985 -0.6486908  -0.23494942 -0.8708738  -0.77051663  0.09255238 -1.1803752 -0.17184262  0.2543226  -0.19088541 -0.26873437  0.9160875  -0.18985008 -0.4793183  -0.32987356 -1.3085973   1.2959319  -0.00581244  0.12396478  1.2034996   0.0991946  -1.9225345   0.92873436 -0.285992    0.11249313 -1.4562801   1.8767762  -1.2222489  -0.03905598  0.5152731   0.04876914  0.04671988 -0.32384786 -0.88341314  0.58193505 -0.7378911  -0.3082042  0.22141728  0.7255646   0.24394599  0.6563271  -0.46760473 -0.38698462 -0.11467619 -0.9940818  -1.1298056   1.015201    0.03592067  0.6738027 -0.5814839   0.1565634  -0.06737513 -1.040216   -0.9286871  -0.11091176 -0.66596293  0.03736701 -0.35337982 -0.4175317  -0.47258058 -0.62383175 -0.86612004 -0.5230916  -1.7838901   0.08661752 -0.02590845  0.23406455  0.77719927  1.4410776   0.41925532  0.4560187  -0.02141571  0.7005563 -0.58727044 -0.39757103  1.2808248  -1.1874324  -0.27268586 -0.82443166  0.39704558 -1.2778002  -0.52762616 -0.26455742  1.2137026   0.04997367  0.05591454  1.0264031   1.5093948  -0.5634581  -1.1715719  -0.646347  0.6021179   0.6725963 ]</code></pre><p>5.1 test_tensorflow.py</p><pre><code class="lang-python">from __future__ import absolute_importimport argparseimport numpy as npfrom six import text_type as _text_typefrom tensorflow.contrib.keras.api.keras.preprocessing import imageimport tensorflow as tfparser = argparse.ArgumentParser()parser.add_argument(&#39;-n&#39;, type=_text_type, default=&#39;kitModel&#39;,                    help=&#39;Network structure file name.&#39;)parser.add_argument(&#39;-w&#39;, type=_text_type, required=True,                    help=&#39;Network weights file name&#39;)parser.add_argument(&#39;--image&#39;, &#39;-i&#39;,                    type=_text_type, help=&#39;Test image path.&#39;,                    default=&quot;face.jpeg&quot;)args = parser.parse_args()if args.n.endswith(&#39;.py&#39;):    args.n = args.n[:-3]model_converted = __import__(args.n).KitModel(args.w)input_tf, model_tf = model_convertedimg = image.load_img(args.image, target_size = (112, 112))img = image.img_to_array(img)img = img[..., ::-1]input_data = np.expand_dims(img, 0)with tf.Session() as sess:    init = tf.global_variables_initializer()    sess.run(init)    predict = sess.run(model_tf, feed_dict = {input_tf : input_data})print(predict)</code></pre><p><strong>执行命令</strong></p><pre><code class="lang-bash">python test_tensorflow.py -n tf_model.py -w tf_model.npy -i face.jpeg#info:2019-10-25 17:51:37.745502: I tensorflow/core/common_runtime/process_util.cc:71] Creating new thread pool with default inter op setting: 12. Tune using inter_op_parallelism_threads for best performance.[[ 0.3444912   0.10190725 -0.24501228  0.6819044   0.88096356  0.3477651  -0.9470245  -0.67586106 -0.43900767  0.8143126  -0.48990446 -0.43025535  -0.50643945 -0.27366814  0.63601726 -0.5352377   0.13765681  0.40842274   0.7652553  -0.8959763   0.42129317 -0.38290572  0.02023016 -0.14840023   0.91082776 -0.27738187 -0.60173315 -0.2149537   0.37644142  0.48894492  -0.8824413   0.3184655   0.19936629  0.2729676   1.5621389   0.4327973  -0.6486915  -0.23494866 -0.87087345 -0.77051604  0.09255352 -1.180374  -0.17184272  0.25432315 -0.19088425 -0.26873374  0.91608876 -0.18985137  -0.4793172  -0.3298719  -1.308598    1.2959337  -0.00581198  0.12396422   1.2034999   0.09919477 -1.9225347   0.92873377 -0.28599226  0.11249284  -1.4562793   1.876776   -1.2222495  -0.03905648  0.5152732   0.04876836   0.04672025 -0.32384863 -0.8834132   0.581934   -0.7378913  -0.30820462   0.22141635  0.72556514  0.2439455   0.6563256  -0.46760577 -0.38698506  -0.1146768  -0.9940842  -1.1298054   1.015199    0.03592021  0.67380327  -0.58148336  0.15656358 -0.06737413 -1.0402167  -0.9286856  -0.11091161  -0.66596127  0.03736706 -0.35337985 -0.41753066 -0.47258082 -0.62383235  -0.8661205  -0.52309173 -1.7838898   0.08661895 -0.02590791  0.23406385   0.7771991   1.4410769   0.41925538  0.45601875 -0.02141583  0.70055544  -0.587271   -0.3975702   1.2808259  -1.1874334  -0.27268624 -0.8244319   0.39704552 -1.2778007  -0.5276267  -0.2645575   1.2137012   0.04997464   0.05591418  1.0264043   1.5093954  -0.5634565  -1.1715722  -0.6463482   0.60211945  0.67259526]]</code></pre><h5 id="6-基于tf-model-npy和tf-model-py文件，固化参数，生成PB文件"><a href="#6-基于tf-model-npy和tf-model-py文件，固化参数，生成PB文件" class="headerlink" title="6.基于tf_model.npy和tf_model.py文件，固化参数，生成PB文件"></a>6.基于tf_model.npy和tf_model.py文件，固化参数，生成PB文件</h5><p>freeze_graph.py </p><pre><code class="lang-python">import tensorflow as tfimport tf_model as tf_fundef netWork():    model=tf_fun.KitModel(&quot;./tf_model.npy&quot;) #调用tf_model.py中的KitModel函数加载npy权重参数    return modeldef freeze_graph(output_graph):    output_node_names = &quot;output&quot;    data,fc1=netWork()    fc1=tf.identity(fc1,name=&quot;output&quot;)    graph = tf.get_default_graph()  # 获得默认的图    input_graph_def = graph.as_graph_def()  # 返回一个序列化的图代表当前的图    init = tf.global_variables_initializer()    with tf.Session() as sess:        sess.run(init)        output_graph_def = tf.graph_util.convert_variables_to_constants(  # 模型持久化，将变量值固定            sess=sess,            input_graph_def=input_graph_def,  # 等于:sess.graph_def            output_node_names=output_node_names.split(&quot;,&quot;))  # 如果有多个输出节点，以逗号隔开        with tf.gfile.GFile(output_graph, &quot;wb&quot;) as f:  # 保存模型            f.write(output_graph_def.SerializeToString())  # 序列化输出if __name__ == &#39;__main__&#39;:    freeze_graph(&quot;frozen_model.pb&quot;)    print(&quot;finish!&quot;)</code></pre><p>python freeze_graph.py </p><pre><code class="lang-bash">#info:Instructions for updating:Use tf.compat.v1.graph_util.extract_sub_graphfinish!</code></pre><p><strong>测试pb模型</strong></p><p>test_pb.py</p><pre><code class="lang-python">from tensorflow.contrib.keras.api.keras.preprocessing import imageimport tensorflow as tfimport numpy as npwith tf.gfile.FastGFile(&#39;frozen_model.pb&#39;,&#39;rb&#39;) as f:    graph_def = tf.GraphDef()    graph_def.ParseFromString(f.read())    tf.import_graph_def(graph_def, name=&#39;&#39;)with tf.Session() as sess:    img = image.load_img(&#39;face.jpeg&#39;, target_size = (112, 112))    img = image.img_to_array(img)    img = img[..., ::-1]    input_data = np.expand_dims(img, 0)    init = tf.global_variables_initializer()    sess.run(init)    #print(tf.get_default_graph().get_operations()) 根据输出值，可知输入tensor名为data 全连接层输出的tensor名为ouput    #op = sess.graph.get_tensor_by_name(&#39;fc1/add_1:0&#39;)    #predict = sess.run(op, feed_dict = {&#39;data:0&#39; : input_data})    op = sess.graph.get_tensor_by_name(&#39;output:0&#39;)    predict = sess.run(op, feed_dict = {&#39;data:0&#39; : input_data})print(predict)</code></pre><p>python test_pb.py</p><pre><code class="lang-bash">#info:[[ 0.3444914   0.10190733 -0.2450121   0.68190414  0.8809633   0.3477656  -0.94702375 -0.6758606  -0.43900838  0.8143138  -0.48990518 -0.43025577  -0.5064386  -0.2736677   0.6360168  -0.5352382   0.13765849  0.40842175   0.7652537  -0.8959745   0.42129484 -0.3829043   0.02023116 -0.14839967   0.9108265  -0.27738202 -0.6017342  -0.21495399  0.37644026  0.48894358  -0.88244045  0.31846407  0.19936593  0.2729677   1.5621401   0.4327974  -0.6486902  -0.23494998 -0.8708729  -0.7705149   0.09255301 -1.1803752  -0.17184293  0.25432175 -0.19088468 -0.2687335   0.91608775 -0.18984997  -0.4793176  -0.32987317 -1.3085989   1.295933   -0.00581315  0.12396483   1.2034997   0.09919491 -1.9225343   0.9287349  -0.28599253  0.11249258  -1.4562799   1.876776   -1.222248   -0.03905599  0.5152738   0.04876841   0.04672143 -0.32384768 -0.88341135  0.58193433 -0.73789096 -0.30820417   0.22141536  0.7255656   0.24394391  0.65632653 -0.4676048  -0.38698527  -0.11467646 -0.9940818  -1.1298064   1.0152006   0.03592108  0.6738041  -0.5814836   0.1565624  -0.06737386 -1.0402162  -0.92868716 -0.1109117  -0.66596234  0.03736827 -0.35337996 -0.41753033 -0.4725821  -0.623832  -0.86612093 -0.5230911  -1.7838906   0.0866183  -0.02590806  0.23406453   0.77719873  1.4410781   0.41925526  0.45601833 -0.02141543  0.7005538  -0.5872698  -0.39757127  1.2808269  -1.1874311  -0.2726869  -0.8244321   0.39704597 -1.2778006  -0.5276277  -0.26455772  1.2137022   0.04997511   0.05591565  1.0264047   1.5093955  -0.56345737 -1.1715721  -0.64634734   0.60211873  0.67259526]]</code></pre><h5 id="7-pb模型转换为-tflite模型供tensorflow-lite调用-移动端部署"><a href="#7-pb模型转换为-tflite模型供tensorflow-lite调用-移动端部署" class="headerlink" title="7. .pb模型转换为.tflite模型供tensorflow lite调用(移动端部署)"></a>7. .pb模型转换为.tflite模型供tensorflow lite调用(移动端部署)</h5><p>pb2tflite.py</p><pre><code class="lang-python">import tensorflow as tfconvert=tf.lite.TFLiteConverter.from_frozen_graph(&quot;frozen_model.pb&quot;,input_arrays=[&quot;data&quot;],                                                  output_arrays=[&quot;output&quot;],                                                  input_shapes={&quot;data&quot;:[1,112,112,3]})convert.post_training_quantize=True #是否量化tflite_model=convert.convert()open(&quot;mobilenet.tflite&quot;,&quot;wb&quot;).write(tflite_model)print(&quot;finish!&quot;)</code></pre><p>python pb2tflite.py</p><p>info: 文件夹中生成mobilenet.tflite</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模型转换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mxnet Windows编译安装CPU版 c++ api</title>
    <link href="/2019/09/19/mxnet%20Windows%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85CPU%E7%89%88/"/>
    <url>/2019/09/19/mxnet%20Windows%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85CPU%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h1 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h1><p>win10 x64 、Visual Studio 2015、cmake 3.0+、python2.7 (环境变量需配置)</p><h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><p>1.OpenBLAS-v0.2.14-Win64-int64 下载地址：<a href="https://sourceforge.net/projects/openblas/files/v0.2.14/" target="_blank" rel="noopener">https://sourceforge.net/projects/openblas/files/v0.2.14/</a></p><p>解压安装后，添加环境变量<strong>OpenBLAS_HOME</strong> 值为openblas的目录，即：your_dir/openblas</p><p>2.OpenCV 3.0+ 下载地址：<a href="https://sourceforge.net/projects/opencvlibrary/files/opencv-win/3.3.1/opencv-3.3.1-vc14.exe/download" target="_blank" rel="noopener">https://sourceforge.net/projects/opencvlibrary/files/opencv-win/3.3.1/opencv-3.3.1-vc14.exe/download</a></p><p>安装后，添加环境变量<strong>OpenCV_DIR</strong> 值为<strong>your_dir\opencv3.3.1\build</strong>,并在<strong>path</strong>环境变量中添加<strong>your_dir\opencv3.3.1\build\x64\vc14\bin</strong></p><h1 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h1><p>1.git clone项目到本地 <strong>（版本1.5.1）</strong></p><pre><code class="lang-bash">git clone --recursive https://github.com/apache/incubator-mxnet mxnet</code></pre><p>2.在mxnet目录下创建build目录</p><p>3.启动cmake-gui.exe进行mxnet.sln工程的生成</p><p>设置mxnet源码路径和mxnet编译路径,点击configure,选择visual studio 2015 win64</p><p>生成的配置中，仅仅勾选<strong>use_opencv,use_openmp,use_cpp_package</strong>即可，如图所示</p><p><img src="/images/note/11.jpg" srcset="/img/loading.gif" alt="11"></p><p>若提示找不到opencv路径，则手动设置opencv路径即可，如图所示</p><p><img src="/images/note/12.jpg" srcset="/img/loading.gif" alt="11"></p><p>重新点击configure,配置选项未显示红框且最终信息显示Configuring done，则配置成功</p><p>若显示红框，则将显示红框的勾去掉，再重新configure（只保留<strong>use_opencv,use_openmp,use_cpp_package</strong>的勾选）</p><p>点击generate,生成mxnet.sln，生成成功会在build目录下出现mxnet.sln工程，如图所示</p><p><img src="/images/note/13.jpg" srcset="/img/loading.gif" alt="11"></p><p>拷贝如下dll文件至mxnet\cpp-package\scripts目录下<br>libopenblas.dll<br>opencv_world331.dll opencv_ffmpeg331_64.dll<br>(来自opencv3.3.1安装目录)<br>libgcc_s_seh-1.dll libgfortran-3.dll libquadmath-0.dll<br>(来自mingw64_dll 下载地址：<a href="https://sourceforge.net/projects/openblas/files/v0.2.14/" target="_blank" rel="noopener">https://sourceforge.net/projects/openblas/files/v0.2.14/</a>)</p><p><img src="/images/note/17.jpg" srcset="/img/loading.gif" alt="11"></p><p>4.利用visual studio 2015 打开mxnet.sln 并执行编译</p><p><img src="/images/note/14.jpg" srcset="/img/loading.gif" alt="11"></p><p>右键ALL_BUILD,点击生成执行编译，编译成功后会在build/release生成mxnet.lib和mxnet.dll,同时会在mxnet\cpp-package\include\mxnet-cpp生成op.h头文件</p><p>如图所示</p><p><img src="/images/note/15.jpg" srcset="/img/loading.gif" alt="11"></p><p><img src="/images/note/16.jpg" srcset="/img/loading.gif" alt="11"></p><p><img src="/images/note/18.jpg" srcset="/img/loading.gif" alt="11"></p><p>5.若自动生成op.h头文件失败，则手动生成c++ op.h头文件</p><p>重新configure（只保留<strong>use_opencv,use_openmp</strong>的勾选）再点击generate,生成mxnet.sln 重新利用Visual Studio 2015编译</p><p>拷贝如下dll文件至mxnet\cpp-package\scripts目录下</p><p>mxnet.dll<br>libopenblas.dll<br>opencv_world331.dll opencv_ffmpeg331_64.dll<br>(来自opencv3.3.1安装目录)<br>libgcc_s_seh-1.dll libgfortran-3.dll libquadmath-0.dll<br>(来自mingw64_dll 下载地址：<a href="https://sourceforge.net/projects/openblas/files/v0.2.14/" target="_blank" rel="noopener">https://sourceforge.net/projects/openblas/files/v0.2.14/</a>)</p><p><img src="/images/note/17.jpg" srcset="/img/loading.gif" alt="11"></p><p>执行如下命令，生成op.h</p><pre><code class="lang-bash">python OpWrapperGenerator.py mxnet.dll</code></pre><p><strong>错误处理</strong><br>1.<a href="https://github.com/apache/incubator-mxnet/issues/14116" target="_blank" rel="noopener">https://github.com/apache/incubator-mxnet/issues/14116</a><br>···bash<br>Build config:<br>1&gt;——— Build started: Project: cpp_package_op_h, Configuration: Release x64 ———<br>1&gt;”Running: OpWrapperGenerator.py”<br>1&gt;D:/Projects/MXNet-versions/MxNet1-3-1/build/Release/libmxnet.dll<br>1&gt;argument “lrs” of operator “multi_sgd_update” has unknown type “, required”<br>1&gt;argument “wds” of operator “multi_sgd_update” has unknown type “, required”<br>1&gt;argument “lrs” of operator “multi_sgd_mom_update” has unknown type “, required”<br>1&gt;argument “wds” of operator “multi_sgd_mom_update” has unknown type “, required”<br>1&gt;argument “lrs” of operator “multi_mp_sgd_update” has unknown type “, required”<br>1&gt;argument “wds” of operator “multi_mp_sgd_update” has unknown type “, required”<br>1&gt;argument “lrs” of operator “multi_mp_sgd_mom_update” has unknown type “, required”<br>1&gt;argument “wds” of operator “multi_mp_sgd_mom_update” has unknown type “, required”<br>========== Build: 1 succeeded, 0 failed, 3 up-to-date, 0 skipped ==========</p><pre><code>解决方案：https://github.com/apache/incubator-mxnet/pull/15144/files</code></pre>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mxnet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cmake教程</title>
    <link href="/2019/08/07/cmake%E6%95%99%E7%A8%8B/"/>
    <url>/2019/08/07/cmake%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>1.hello world</strong> </p><p>main.cpp</p><pre><code class="lang-c++">int main(){  std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;  return 0;}</code></pre><p>CMakeLists.txt</p><pre><code class="lang-bash">cmake_minimum_required(VERSION 3.14) #最低cmake版本project(test) #定义项目名称set(CMAKE_CXX_STANDARD 11) #设置c++编译标准版本add_executable(test main.cpp)</code></pre><p>构建</p><pre><code class="lang-bash">cmake . #.代表本目录make</code></pre><p>Note:</p><p>1.project(name)会同时隐式定义NAME_BINARY_DIR 以及NAME_SOURCE_DIR变量</p><p>2.SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]]) 定义变量:set( SRC_LIST main.cpp test.cpp)</p><p>3.ADD_EXECUTABLE(test ${SRC_LIST}) 生成名为test的可执行文件 源文件为SRC_LIST</p><p>4.变量使用${}取值，在IF控制语句中直接使用变量名</p><p>指令(参数1 参数2 …) 指令不区分大小写 参数区分大小写</p><p>》〉》以上hello world 的编译为内部编译，无法删除中间文件</p><p>5.外部构建(通常的方式)</p><pre><code class="lang-bash">sudo mkdir build #在工程目录任意位置 cd buildcmake .. #..代表父目录(包含CMakeLists.txt构建文件)make</code></pre><p>6.ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) 当前工程添加源文件存放的子目录并指定目标二进制文件存放目录：</p><p>ADD_SUBDIRECTORY(src bin)</p><p>7.cmake -DCMAKE_INSTALL_PREFIX=/usr/local . #-DCMAKE_INSTALL_PREFIX指定安装目录</p><p>8.INSTALL指令 DCMAKE_INSTALL_PREFIX默认为/usr/local目录</p><p><strong>目标文件的安装</strong></p><p>INSTALL(<strong>TARGETS</strong> targets… </p><p>​                [</p><p>​                [ARCHIVE|LIBRARY|RUNTIME] </p><p>​                [DESTINATION (dir)]</p><p>​                [PERMISSIONS permissions…] </p><p>​                [CONFIGURATIONS [Debug|Release|…]</p><p>​                ]</p><p>​                [COMPONENT \<component\>] [OPTIONAL] ] […])</p><p>INSTALL(TARGETS myrun mylib mystaticlib </p><p>​               RUNTIME DESTINATION bin </p><p>​               LIBRARY DESTINATION lib </p><p>​               ARCHIVE DESTINATION libstatic ) </p><p>可执行文件 myrun 安装到${CMAKE_INSTALL_PREFIX}/bin 目录 </p><p>动态库 libmylib 安装到${CMAKE_INSTALL_PREFIX}/lib 目录 </p><p>静态库 libmystaticlib 安装到${CMAKE_INSTALL_PREFIX}/libstatic 目录</p><p><strong>普通文件的安装</strong></p><p>INSTALL(<strong>FILES</strong> files… </p><p>​              DESTINATION (dir)</p><p>​              [PERMISSIONS permissions…] [CONFIGURATIONS [Debug|Release|…]] [COMPONENT (component)] [RENAME (name)] [OPTIONAL])</p><p><strong>2.静态库与动态库构建</strong></p><p>ADD_LIBRARY(libname [SHARED|STATIC|MODULE] [EXCLUDE_FROM_ALL] source1 source2 … sourceN)</p><p>工程目录 CMakeLists.txt</p><pre><code>PROJECT(HELLOLIB) ADD_SUBDIRECTORY(lib)</code></pre><p>līb目录下 CMakeLists.txt</p><pre><code class="lang-bash">SET(LIBHELLO_SRC hello.c) ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC}) #动态库ADD_LIBRARY(hello_static STATIC ${LIBHELLO_SRC}) #静态库SET_TARGET_PROPERTIES(hello_static PROPERTIES OUTPUT_NAME &quot;hello&quot;) #使得动态库和静态库同名SET_TARGET_PROPERTIES(hello PROPERTIES CLEAN_DIRECT_OUTPUT 1) #防止同名时被清理SET_TARGET_PROPERTIES(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT 1) #防止同名时被清理INSTALL(TARGETS hello hello_static                 LIBRARY DESTINATION lib                 ARCHIVE DESTINATION lib)</code></pre><p>构建并安装</p><pre><code class="lang-bash">sudo mkdir build cd buildcmake -DCMAKE_INSTALL_PREFIX=/usr .. makemake install</code></pre><p>lib目录生成libhello.so libhello.a文件,并安装到/usr/bin目录</p><p><strong>3.外部共享库和头文件的使用</strong></p><pre><code class="lang-bash">INCLUDE_DIRECTORIES([AFTER|BEFORE] [SYSTEM] dir1 dir2 ...) #添加包含目录指令INCLUDE_DIRECTORIES(/usr/include/hello)LINK_DIRECTORIES(directory1 directory2 ...) 添加共享库目录TARGET_LINK_LIBRARIES(target library1 library2 ...) #为目标文件添加需要的共享库TARGET_LINK_LIBRARIES(main libhello.so) #动态库TARGET_LINK_LIBRARIES(main libhello.a) #静态库</code></pre><p><strong>4.cmake 常用指令</strong></p><p>ADD_DEFINITIONS(-D…)：向 C/C++编译器添加-D 定义</p><p>AUX_SOURCE_DIRECTORY(dir VARIABLE)：发现一个目录下所有的源代码文件并将列表存储在一个变量中</p><p>AUX_SOURCE_DIRECTORY(. SRC_LIST)</p><p>ADD_EXECUTABLE(main ${SRC_LIST})</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>make</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构(7) 排序</title>
    <link href="/2019/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(7)%20%E6%8E%92%E5%BA%8F/"/>
    <url>/2019/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(7)%20%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p><strong>直接插入排序</strong></p><p>把$n$个待排序的元素假设为一个有序表和一个无序表，开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次即可完成排序过程</p><pre><code class="lang-c++">void insertSort(int array[],int n) {    int i, j, key;    for (i = 1; i &lt; n; i++) {        if (array[i] &lt; array[i - 1]) {            key = array[i];//设置为哨兵            //找到合适的插入位置并将比key大的元素后移            for (j = i - 1; key &lt; array[j] &amp;&amp; j &gt;= 0; --j)                array[j + 1] = array[j];            array[j + 1] = key;//插入        }    }}</code></pre><p><strong>折半插入排序</strong></p><pre><code class="lang-c++">void insertSortbyHalf(int array[],int n){    int i,j,key,mid,low,high;    for (i = 1; i &lt; n; i++) {        if(array[i] &lt; array[i-1]){            key = array[i];            low = 0,high = i-1;              //找到插入的位置            while(low &lt;= high){                mid = (low + high) / 2;                if(key &lt; array[mid])                    high = mid - 1;                else                    low = mid + 1;            }              //统一移动元素            for(j = i-1;j &gt;= high+1;j--){                array[j+1] = array[j];            }            array[j+1] = key;//插入        }    }}</code></pre><p><strong>希尔排序</strong></p><p>增量序列 $d<em>1，d_2，\cdots，d_k$，其中 $d_1=n/2,d</em>{i+1}=[d_i/2],d_k = 1$；</p><p>按增量序列个数 $k$，对序列进行 $k$ 趟排序；</p><p>每趟排序，先根据对应的增量 $d_i$，将待排序序列分割为$d_i$个组，距离为$d_i$的元素为同一组，再对每个组进行直接插入排序，直到$d_i =1$,即所有元素已在同一组中，再进行一次直接插入排序</p><p><img src="\images\dataStructure\81.png" srcset="/img/loading.gif" alt=""></p><pre><code class="lang-c++">void shellSort(int array[],int n) {    int di, i,j, key;    for (di = n/2; di &gt;= 1; di = di/2) {//设置增量        //分组并进行插入排序        for (i = di; i &lt; n; i++) {            if (array[i] &lt; array[i - di]) {                key = array[i];                for (j = i - di; j &gt;= 0 &amp;&amp; key &lt; array[j]; j = j - di) {                    array[j + di] = array[j];                }                array[j + di] = key;            }        }    }}</code></pre><h1 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h1><p><strong>冒泡排序</strong></p><p>每次比较两个相邻的元素，如果其顺序错误就交换</p><pre><code class="lang-c++">void bubbleSort(int array[],int n) {    int key;    for (int i = 0; i &lt; n-1;i++) {        //LEN-i:每一次都已归位一个数,不再需要与已归位的数比较        for (int j = 0; j &lt; n - i - 1; j++) {            if (array[j] &gt; array[j + 1]) {                key = array[j];                array[j] = array[j + 1];                array[j + 1] = key;            }        }    }}</code></pre><p><strong>快速排序</strong></p><p>1.设置两个变量$i,j$，初始化：$i=0，j=n-1$；<br>2.基准数$key=array[0]$；<br>3.从$j$开始向前搜索，即由后开始向前搜索$(j—)$，找到第一个小于$key$的值$array[j]$，将$array[j]$和$array[i]$的值交换；<br>4.从$i$开始向后搜索，即由前开始向后搜索$(i++)$，找到第一个大于key的$array[i]$，将$array[i]$和$array[j]$的值交换；<br>5.重复第3、4步，直到$i=j$；</p><p>经过一趟上述步骤后，基准数左边全小于基准数，基准数右边全大于基准数，通过分治法继续处理左、右</p><pre><code class="lang-c++">void quickSort(int array[], int left, int right){    if (left &gt;= right){        return;    }    int i = left;    int j = right;    int key = array[left];//基准数    while (i &lt; j){        //向前寻找小于key的数        while (i &lt; j &amp;&amp; key &lt;= array[j]){            j--;        }        array[i] = array[j];        //向后寻找大于key的数        while (i &lt; j &amp;&amp; key &gt;= array[i]){            i++;        }        array[j] = array[i];    }    array[i] = key;//基准数归位    quickSort(array, left, i - 1);//分治处理左边    quickSort(array, i + 1, right);//分治处理右边}</code></pre><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p><strong>简单选择排序</strong></p><p>(1)在未排序序列中找到最小/大元素，存放到排序序列的起始位置;(2)再从剩余未排序元素中继续寻找最小/大元素，放到已排序序列的末尾;重复第二步，直到所有元素均排序完毕</p><p><img src="\images\dataStructure\selectionSort.gif" srcset="/img/loading.gif" alt=""></p><pre><code class="lang-c++">void selectSort(int array[], int n) {    for (int i = 0; i &lt; n - 1; i++) {        int min = i;        for (int j = i + 1; j &lt; n; j++) {            if (array[j] &lt; array[min])                min = j;        }        if (i != min) {            int temp = array[i];            array[i] = array[min];            array[min] = temp;        }    }}</code></pre><p><strong>堆排序</strong></p><p>堆是具有以下性质的完全二叉树：</p><p>1.每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；</p><p>2.每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆；</p><p><img src="\images\dataStructure\45.jpg" srcset="/img/loading.gif" alt=""></p><p>堆排序算法步骤：</p><p>1.构造初始堆，将无序序列构造为大顶堆，从倒数第一个非叶子结点开始调整,从左至右，从下至上进行调整；</p><p>倒数第$i$个非叶子结点索引$index=array.length/2^i-1(i=1,2,3\dots|2^i\leqslant  array.length)$</p><p><img src="\images\dataStructure\46.jpg" srcset="/img/loading.gif" alt=""></p><p>2.将堆顶元素与末尾元素进行交换，使末尾元素最大，然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素，如此反复进行交换、重建、交换…</p><p><img src="\images\dataStructure\47.jpg" srcset="/img/loading.gif" alt=""></p><pre><code class="lang-c++">void swap(int* a, int* b){    int temp = *b;    *b = *a;    *a = temp;}void max_heapify(int array[], int start, int end){    //建立父节点指标和子结点指标    int dad = start;    int son = dad * 2 + 1;    while (son &lt;= end){//若子结点索引在范围内才做比较        //先比较两个子结点大小，选择最大的        if (son + 1 &lt;= end &amp;&amp; array[son] &lt; array[son + 1])            son++;        if (array[dad] &gt; array[son]) //如果父节点大於子结点代表调整完毕，直接跳出函数            return;        else{            swap(&amp;array[dad], &amp;array[son]);            dad = son;            son = dad * 2 + 1;        }    }}void heap_sort(int array[], int len){    int i;    //初始化，生成最大堆    for (i = len / 2 - 1; i &gt;= 0; i--)        max_heapify(array, i, len - 1);    //堆顶元素与末尾元素进行交换，再重新调整，直到排序完毕    for (i = len - 1; i &gt; 0; i--){        swap(&amp;array[0], &amp;array[i]);        max_heapify(array, 0, i - 1);    }}</code></pre><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>假定含有$n$个元素的待排序表，则可视为$n$个有序的子表，每个子表长度为1，然后两两归并，得到[$n/2$]个长度为2或1的有序表；再两两归并$\cdots$,直到合并长度为$n$的有序表为止</p><p><img src="\images\dataStructure\82.png" srcset="/img/loading.gif" alt=""></p><pre><code class="lang-c++">void merge(int array[], int low, int mid, int high, int temp[]){    int i = low, j = mid + 1;    int m = mid, n = high;    int k = 0;    while (i &lt;= m &amp;&amp; j &lt;= n){        if (array[i] &lt;= array[j])            temp[k++] = array[i++];        else            temp[k++] = array[j++];    }    while (i &lt;= m)        temp[k++] = array[i++];    while (j &lt;= n)        temp[k++] = array[j++];    for (i = 0; i &lt; k; i++)        array[low + i] = temp[i];}void mergesort(int array[], int low, int high, int temp[]){    if (low &lt; high){        int mid = (low + high) / 2;        mergesort(array, low, mid, temp);            mergesort(array, mid + 1, high, temp);         merge(array, low, mid, high, temp);    }}</code></pre><hr><p><img src="\images\dataStructure\83.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构(6) 查找</title>
    <link href="/2019/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(6)%20%E6%9F%A5%E6%89%BE/"/>
    <url>/2019/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(6)%20%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h1><p>1.一般线性表</p><pre><code class="lang-c++">typedef struct{    ElemType *elem;//0号单元留空    int length;}STable;int search(STable table,ElemType key){    table.elem[0] = key;//哨兵    for(int i = table.length;table.elem[i] != key; --i);    return i;}</code></pre><h1 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h1><pre><code class="lang-c++">int binary_search(SeqList list,ElemType key){    int low = 0;high = list.length-1;mid;    while(low &lt;= high){        mid = (low+high)/2;        if(list.elem[mid] == key)            return mid;        else if(list.elem[mid] &lt; key)            low = mid+1;        else            high = mid-1;    }    return -1;//查找失败}</code></pre><h1 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h1><p>$B$树中所有结点的子结点数的最大值称为$B$树的阶，一个 $m$ 阶的$B$树是一个有以下属性的树：</p><p><strong>1</strong>.每一个结点最多有 $m $个子结点，即每个结点至多含有$m-1$个关键字<br>2.每一个非叶子结点（除根结点）最少有 $⌈m/2⌉$ 个子结点,即至少含有$[m/2]-1$个关键字<br>3.如果根结点不是叶子结点，那么它至少有两个子结点<br>4.有 $k$ 个子结点的非叶子结点拥有 $k − 1$ 个键<br>5.所有的叶子结点都在同一层</p><p>非根内部结点的关键字个数$n$范围：$[m/2]-1 \leq n \leq m-1$,根结点关键字个数$n$范围：$1 \leq n\leq m-1$</p><p>每一个内部结点的键将结点的子树分开。</p><p>例如，如果一个内部结点有3个子结点（子树），那么它就必须有两个键： $a_1 $和 $a_2$ </p><p>左边子树的所有值都必须小于 $a_1$ ，中间子树的所有值都必须在 $a_1$ 和$a_2$ 之间，右边子树的所有值都必须大于$ a_2$ </p><p><img src="\images\dataStructure\44.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>B树的查找</strong></p><p>1.在$B$中找结点 (读入内存) 2.在结点内找关键字(通过顺序查找或折半查找查找等于key的关键字)</p><p><strong>B树的插入</strong></p><p>所有的插入都从根结点开始，要插入一个新的元素，首先搜索这棵树，找到新元素应该被添加到的叶子结点</p><p>将新元素插入到这一结点中的步骤如下：</p><p>如果结点拥有的元素数量小于最大值，那么有空间容纳新的元素，将新元素插入到这一结点，且保持结点中元素有序，否则这一结点已经满了，将它平均地分裂成两个结点：从叶子结点的元素和新的元素中选择出中位数；小于这一中位数的元素放入左边结点，大于这一中位数的元素放入右边结点，中位数作为分隔值.<br><strong>分隔值被插入到父结点中</strong>，这可能会造成父结点分裂，分裂父结点时可能又会使它的父结点分裂，以此类推.如果没有父结点（这一结点是根结点），就创建一个新的根结点（增加了树的高度）,即如果分裂一直上升到根节点，那么一个新的根节点会被创建，它有一个分隔值和两个子节点</p><blockquote><p>以5阶B树为例</p></blockquote><p>[]: <a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">https://www.cnblogs.com/nullzx/p/8729425.html</a></p><p>1.空树中插入39</p><p><img src="\images\dataStructure\45.png" srcset="/img/loading.gif" alt=""></p><p>2.继续插入22，97和41</p><p><img src="\images\dataStructure\46.png" srcset="/img/loading.gif" alt=""></p><p>3.继续插入53</p><p><img src="\images\dataStructure\47.png" srcset="/img/loading.gif" alt=""></p><p>插入后超过了最大允许的关键字个数4，需以中位数(41)为中心进行分裂</p><p><img src="\images\dataStructure\48.png" srcset="/img/loading.gif" alt=""></p><p>4.依次插入13，21，40，同样会造成分裂，结果如下图</p><p><img src="\images\dataStructure\49.png" srcset="/img/loading.gif" alt=""></p><p>5.依次插入30，27, 33 ；36，35，34 ；24，29</p><p><img src="\images\dataStructure\50.png" srcset="/img/loading.gif" alt=""></p><p>6.插入key值为26的记录</p><p><img src="\images\dataStructure\51.png" srcset="/img/loading.gif" alt=""></p><p>当前结点需要以27为中心分裂,并向父结点插入27</p><p><img src="\images\dataStructure\52.png" srcset="/img/loading.gif" alt=""></p><p>插入后导致当前结点（即根结点）也需要分裂</p><p><img src="\images\dataStructure\53.png" srcset="/img/loading.gif" alt=""></p><p><strong>B树的删除</strong></p><p>删除时，需要判断结点中关键字的个数$\geqslant [m/2]-1$</p><blockquote><p>5阶B树为例，结点最多有4个key,最少有2个key</p></blockquote><p>[]: <a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">https://www.cnblogs.com/nullzx/p/8729425.html</a></p><p><img src="\images\dataStructure\54.png" srcset="/img/loading.gif" alt=""></p><p>1.B树中删除21，删除后结点中的关键字个数仍然大于等2，删除结束</p><p><img src="\images\dataStructure\55.png" srcset="/img/loading.gif" alt=""></p><p>2.删除27，27位于非叶子结点中，利用27的后继28替代</p><p><img src="\images\dataStructure\56.png" srcset="/img/loading.gif" alt=""></p><p>删除后，当前叶子结点的关键字的个数小于2，而它的兄弟结点中有3个关键字，从兄弟结点中借取一个关键字</p><p><img src="\images\dataStructure\57.png" srcset="/img/loading.gif" alt=""></p><p>3.删除32</p><p><img src="\images\dataStructure\58.png" srcset="/img/loading.gif" alt=""></p><p>删除后，当前结点中只有一个关键字，而兄弟结点中也仅有2个关键字，只能让父结点中的30下移并和兄弟结点中的关键字合并，成为一个新的结点，当前结点的指针指向父结点</p><p><img src="\images\dataStructure\59.png" srcset="/img/loading.gif" alt=""></p><p>4.删除40</p><p><img src="\images\dataStructure\60.png" srcset="/img/loading.gif" alt=""></p><p>同理，当前结点的关键字数小于2，兄弟结点中没有多余关键字，所以父结点中的关键字下移，和兄弟结点(左右兄弟结点都可)的关键字合</p><p><img src="\images\dataStructure\61.png" srcset="/img/loading.gif" alt=""></p><p>当前结点关键字个数小于2，继续合并</p><p><img src="\images\dataStructure\62.png" srcset="/img/loading.gif" alt=""></p><p><strong>B+树</strong></p><p>1.每个分支结点最多有$m$个子结点</p><p>2.结点的子结点个数与关键字个数相等(或结点的子结点个数 = 关键字个数+1)</p><p>3.所有叶结点包含全部关键字及指向记录的指针，且叶结点中关键字按大小顺序排列，所有相邻结点按大小顺序互相链接</p><p>4.非根内部结点的关键字个数$n$范围：$[m/2] \leq n \leq m$,根结点关键字个数$n$范围：$1 \leq n\leq m$</p><p><img src="\images\dataStructure\63.png" srcset="/img/loading.gif" alt=""></p><p><strong>B+树的插入</strong></p><blockquote><p>以5阶B树为例</p></blockquote><p>1.空树中插入5</p><p><img src="\images\dataStructure\64.png" srcset="/img/loading.gif" alt=""></p><p>2.依次插入8，10，15</p><p><img src="\images\dataStructure\65.png" srcset="/img/loading.gif" alt=""></p><p>3.插入16</p><p>插入16后超过了关键字的个数限制，需进行分裂</p><p><img src="\images\dataStructure\66.png" srcset="/img/loading.gif" alt=""></p><p>4.插入17</p><p><img src="\images\dataStructure\67.png" srcset="/img/loading.gif" alt=""></p><p>5.插入18</p><p><img src="\images\dataStructure\68.png" srcset="/img/loading.gif" alt=""></p><p>当前结点的关键字个数大于限制的个数，需进行分裂</p><p><img src="\images\dataStructure\69.png" srcset="/img/loading.gif" alt=""></p><p>6.插入若干数据</p><p><img src="\images\dataStructure\70.png" srcset="/img/loading.gif" alt=""></p><p>7.插入7</p><p><img src="\images\dataStructure\71.png" srcset="/img/loading.gif" alt=""></p><p>当前结点的关键字个数大于限制的个数，需进行分裂</p><p><img src="\images\dataStructure\72.png" srcset="/img/loading.gif" alt=""></p><p>当前结点的关键字个数大于限制的个数，需进行分裂</p><p><img src="\images\dataStructure\73.png" srcset="/img/loading.gif" alt=""></p><p><strong>B+树的删除</strong></p><blockquote><p>以5阶B树为例</p></blockquote><p><img src="\images\dataStructure\74.png" srcset="/img/loading.gif" alt=""></p><p>1.删除22</p><p><img src="\images\dataStructure\75.png" srcset="/img/loading.gif" alt=""></p><p>2.删除15</p><p><img src="\images\dataStructure\76.png" srcset="/img/loading.gif" alt=""></p><p>删除后当前结点只有一个关键字，不满足条件，而兄弟结点有三个关键字，从兄弟结点中借关键字为9,同时更新将父结点中的关键字由10变为9，删除结束</p><p><img src="\images\dataStructure\77.png" srcset="/img/loading.gif" alt=""></p><p>3.删除7</p><p><img src="\images\dataStructure\78.png" srcset="/img/loading.gif" alt=""></p><p><img src="\images\dataStructure\79.png" srcset="/img/loading.gif" alt=""></p><p><img src="\images\dataStructure\80.png" srcset="/img/loading.gif" alt=""></p><h1 id="散列-hash-表"><a href="#散列-hash-表" class="headerlink" title="散列(hash)表"></a>散列(hash)表</h1><p><strong>散列函数</strong></p><p>一个把查找表中的关键字映射为该关键字对应的地址函数，记$Hash(key)=Address$</p><p>1.直接定址法 $Hash(key)=a\times key+b$，($a,b$未常数)</p><p>2.除留余数法 $Hash(key)=key\%p$，($p$为质数)</p><p>3.数字分析法 设关键字是$r$进制数，选取数码分布较为均匀的若干位作为散列地址</p><p>4.平方取中法 取关键字的平方值的中间几位作为散列地址</p><p>5.折叠法 将关键字分割成位数相同的块，取块的叠加和作为散列地址</p><p><strong>冲突处理</strong></p><p>散列函数可能会把两个或两个以上的的不同关键字映射到同一地址，这种情况称为”冲突”</p><p>设散列函数为$Hash(key),H_i$表示发生冲突后第$i$次探测的散列地址</p><p>1.开放定址法</p><script type="math/tex; mode=display">H_i=(Hash(key)+d_i)\%m</script><p>$m$表示散列表长度，$d_i$为增量序列</p><p>$d_i$的选取方法：</p><p>1) 线性探测法 $d_i=0,1,2,3,\cdots,m-1$</p><p>2) 平方探测法 $d_i=0^2,1^2,-1^2,2^2,-2^2,\cdots ,k^2,-k^2(k\leqslant m/2)$</p><p>3) 再散列法或双散列法 $d_i=Hash_2(key)$，即$H_i=(Hash(key)+i*Hash_2(key))\%m$($i$为冲突次数)</p><p>4) 伪随机序列法 $d_i=$伪随机数序列</p><p>2.拉链法</p><p>同义词存储在一个线性链表$L_i$中,散列地址为$i$的同义词链表$L_i$的头指针存放在散列表第$i$个单元中</p><p><strong>散列查找过程</strong></p><p>1.初始化：$address = Hash(key)$</p><p>2.若$L[address]=NULL$,则查找失败；若$L[address]\neq NULL$且$L[address]\neq key$，则$H_1=(address+1)\%m$,若$L[H_1]\neq NULL$且$L[H_1]\neq key$,则$H_2=(H_1+2)\%m$,若$L[H_2]\neq NULL$且$L[H_1]\neq key$,则$H_3=\cdots$</p><p>重复执行$H<em>{i+1}=(H_i+(i+1))\%m$ ($i=1,2,3,\cdots,m-1$),直到$L[H</em>{i+1}]=key或L[H_{i+1}]=NULL$</p><h1 id="字符串模式匹配"><a href="#字符串模式匹配" class="headerlink" title="字符串模式匹配"></a>字符串模式匹配</h1><p>1.简单的模式匹配算法</p><p>从主串S的指定字符开始，和模式串的第一个字符比较，若相等则继续逐个比较后续字符，直到模式串中的每个字符依次和主串的一个连续字符序列相等，则匹配成功；若比较过程中有某对字符不相等，则从主串的下一个字符重新与模式串的第一个字符相比较。</p><pre><code class="lang-c++">int matching(String target, String pattern, int begin) {        // i为目标串target的索引        int i = begin;        // j为模式串pattern的索引        int j = 0;        if (target == null || pattern == null || begin &gt; target.length()) {            return -1;        }        while (i &lt; target.length() &amp;&amp; j &lt; pattern.length()){            if (target[i] == pattern[j]) {                i++;                j++;            } else {                i = i - j + 1;                j = 0;            }        }        // 模式串是否存在于目标串        if (j == pattern.length()) {            return i - pattern.length() ;        }        return -1;    }</code></pre><p>2.KMP模式匹配算法</p><p>wait</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>opencv3(2) 图像载入-显示-输出</title>
    <link href="/2019/07/10/opencv3(2)%20%E5%9B%BE%E5%83%8F%E8%BD%BD%E5%85%A5-%E6%98%BE%E7%A4%BA-%E8%BE%93%E5%87%BA/"/>
    <url>/2019/07/10/opencv3(2)%20%E5%9B%BE%E5%83%8F%E8%BD%BD%E5%85%A5-%E6%98%BE%E7%A4%BA-%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<ul><li>载入函数</li></ul><pre><code class="lang-cpp">Mat imread( const String&amp; filename, int flags = IMREAD_COLOR );IMREAD_UNCHANGED   = -1, //!&lt; If set, return the loaded image as is (with alpha channel, otherwise it gets cropped).IMREAD_GRAYSCALE   = 0,  //!&lt; If set, always convert image to the single channel grayscale image.IMREAD_COLOR       = 1,  //!&lt; If set, always convert image to the 3 channel BGR color image.IMREAD_ANYDEPTH    = 2,  //!&lt; If set, return 16-bit/32-bit image when the input has the corresponding depth, otherwise convert it to 8-bit.IMREAD_ANYCOLOR    = 4,  //!&lt; If set, the image is read in any possible color format.Mat img = imread(&quot;D:/learn/dota.jpg&quot;);</code></pre><ul><li>显示函数</li></ul><pre><code class="lang-cpp">imshow(&quot;dota&quot;, img);</code></pre><ul><li>输出函数</li></ul><pre><code class="lang-cpp">bool imwrite( const String&amp; filename, InputArray img,              const std::vector&lt;int&gt;&amp; params = std::vector&lt;int&gt;());imwrite(&quot;D:/new_dota.jpg&quot;, img);</code></pre><ul><li><p>实例</p><pre><code class="lang-cpp">#include &lt;iostream&gt;  #include &lt;opencv2/core/core.hpp&gt;  #include &lt;opencv2/highgui/highgui.hpp&gt;  using namespace cv;int main() {  //图像显示  Mat logo = imread(&quot;D:/learn/logo.jpg&quot;);  imshow(&quot;logo&quot;, logo);  //图像混合  Mat img = imread(&quot;D:/learn/dota.jpg&quot;);  imshow(&quot;img&quot;, img);  Mat imgROI;  imgROI = img(Rect(800, 350, logo.cols, logo.rows));  //logo加载到背景图  addWeighted(imgROI,0.5,logo,0.3,0,imgROI);  imshow(&quot;dota_logo&quot;, img);  //保存混合的图像  imwrite(&quot;D:/learn/dota_logo.jpg&quot;,img);  waitKey(0);}</code></pre><p><img src="/images/opencv3/18.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/opencv3/19.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/opencv3/20.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/opencv3/21.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>读取视频文件 调用摄像头 写入视频文件</p><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;opencv2/opencv.hpp&gt;using namespace std;using namespace cv;int main() {  namedWindow(&quot;cap&quot;, cv::WINDOW_AUTOSIZE);  VideoCapture cap;  Mat frame;  cap.open(0);  //视频流写出  Size size = Size(cap.get(CV_CAP_PROP_FRAME_WIDTH), cap.get(CV_CAP_PROP_FRAME_HEIGHT));  VideoWriter writer;  writer.open(&quot;test.avi&quot;, -1, 10, size);  //  for (;;){      cap &gt;&gt; frame;      imshow(&quot;out&quot;, frame);      writer &lt;&lt; frame;      if (waitKey(33) &gt;= 0) break;  }  cap.release();  //waitKey(0);  return 0;}</code></pre></li></ul><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>opencv3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>opencv3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>opencv3(1-1) vs2015配置opencv3开发环境</title>
    <link href="/2019/07/10/opencv3(1-1)%20vs2015%E9%85%8D%E7%BD%AEopencv3%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <url>/2019/07/10/opencv3(1-1)%20vs2015%E9%85%8D%E7%BD%AEopencv3%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h2 id="vs2015配置opencv3开发环境"><a href="#vs2015配置opencv3开发环境" class="headerlink" title="vs2015配置opencv3开发环境"></a>vs2015配置opencv3开发环境</h2><p>官网地址:<a href="https://opencv.org/" target="_blank" rel="noopener">https://opencv.org/</a></p><ul><li><p>下载<br><img src="/images/opencv3/1.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"><br><img src="/images/opencv3/2.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"></p></li><li><p>下载完成后双击安装,并配置环境变量<br><img src="/images/opencv3/3.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"></p></li><li>打开VS2015,新建项目<br><img src="/images/opencv3/4.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"><br><img src="/images/opencv3/5.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"><br><strong>配置opencv</strong><br><img src="/images/opencv3/6.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"></li><li>添加包含目录<br><img src="/images/opencv3/7.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"><br><img src="/images/opencv3/8.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"></li><li>添加库目录<br><img src="/images/opencv3/9.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"><br><img src="/images/opencv3/10.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"></li><li>添加附加依赖项 将vc14下的lib都添加进来,以d结尾的lib文件为调试使用<br><img src="/images/opencv3/11.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"><br><img src="/images/opencv3/12.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"></li><li>测试<br><img src="/images/opencv3/13.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"><br><img src="/images/opencv3/14.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;using namespace cv;int main() {  Mat img = imread(&quot;D:/learn/dota.jpg&quot;);  imshow(&quot;dota&quot;, img);   waitKey(6000);}</code></pre></li><li>运行<br><img src="/images/opencv3/15.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"></li><li>结果<br><img src="/images/opencv3/16.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"></li></ul><hr><p><strong>opencv模块简介</strong><br><img src="/images/opencv3/17.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"></p><ul><li>calib3d<br>相机校准和3维重建相关的内容,包括多视角几何算法、单个立体摄像头标定、物体姿态估计、立体相似性算法等</li><li>core<br>核心功能模块,包含opencv基本数据结构、动态数据结构、绘图函数、数组操作、辅助函数/系统函数/宏、OpenGL互操作</li><li>imgproc<br>图像处理模块,包含线性和非线性的图像滤波、图像几何变换、直方图、结构分和形状描述、运动分析、运动分析和对象跟踪、特征检测、目标检测</li><li>features2d<br>2D功能模块,包含特征检测和描述、特征检测器通用接口、描述符提取器、描述符匹配器、通用描述符匹配器接口、关键点绘制函数和匹配功能绘制函数</li><li>flann<br>高维近似近邻快速搜索算法库,包含快速近似最近邻搜索、聚类</li><li>gpu<br>运用GPU加速计算机视觉模块</li><li>highgui<br>高层GUI图形用户界面,包含媒体输入输出、视频捕捉、图像和视频编码解码、图形交互界面接口</li><li>legacy<br>废弃的代码库,用于向下兼容</li><li>ml<br>机器学习模块，包含统计模型、贝叶斯分类器、支持向量机、决策树、提升、随机树、神经网络</li><li>objdetect<br>目标检测模块,包含级联分类和LatentSVM</li><li>photo<br>图像修复和去噪</li><li>stitching<br>图像拼接模块,包含拼接流水线、特点寻找和匹配图像、估计旋转、自动校准、图片歪斜、接缝估测、曝光补偿、图片混合</li><li>superres<br>超分辨率技术模块</li><li>video<br>视频分析组件,包含运动估计、背景分离、对象跟踪</li><li>videostab<br>视频稳定组件</li></ul><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>opencv3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>opencv3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++教程(4) C++标准库</title>
    <link href="/2019/07/09/C++%E6%95%99%E7%A8%8B(4)%20C++%E6%A0%87%E5%87%86%E5%BA%93/"/>
    <url>/2019/07/09/C++%E6%95%99%E7%A8%8B(4)%20C++%E6%A0%87%E5%87%86%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h3 id="Pair"><a href="#Pair" class="headerlink" title="Pair"></a>Pair</h3><p>Class Pair将两个value视为一个单元</p><pre><code class="lang-cpp">namespace std{    template&lt;typename T,typename U&gt;    struct pair{        T first;        U second;        ...    };}</code></pre><p><img src="/images/pair.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h3><p>tuple可拥有任意类型任意数量的元素</p><pre><code class="lang-cpp">std::tuple&lt;int, double, char,std::string&gt; tuple(1, 2.3, &#39;y&#39;, &quot;hello wolrd&quot;);</code></pre><p><img src="/images/tuple.jpg" srcset="/img/loading.gif" alt=""><br>tuple不允许迭代,运行时传入索引值将报错</p><pre><code class="lang-cpp">std::get&lt;i&gt;(tuple);//错误</code></pre><h3 id="Smart-Pointer-智能指针"><a href="#Smart-Pointer-智能指针" class="headerlink" title="Smart Pointer(智能指针)"></a>Smart Pointer(智能指针)</h3><p>Smart Pointer能够得知本身是否为指向某个对象的最后一个指针,当其为指向某个对象的最后一个指针且被删除时即会销毁所指对象</p><h4 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h4><p>共享式拥有 多个smart pointer指向同一对象,对象和资源在最后一个smart pointer销毁时被释放</p><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;memory&gt;using namespace std;int main() {    shared_ptr&lt;string&gt; x(new string(&quot;kyleson&quot;));    shared_ptr&lt;string&gt; y(new string(&quot;monica&quot;));    (*x)[0] = &#39;K&#39;;    y-&gt;replace(0, 1, &quot;J&quot;);    vector&lt;shared_ptr&lt;string&gt;&gt; person;    person.push_back(x);    person.push_back(y);    person.push_back(x);    person.push_back(y);    for (auto ptr : person)        cout &lt;&lt; *ptr &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;    *x = &quot;Nonica&quot;;    for (auto ptr : person)        cout &lt;&lt; *ptr &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;    cout &lt;&lt; &quot;use_count:&quot; &lt;&lt; person[0].use_count() &lt;&lt; endl;//所指对象当前拥有者(指针)数量    getchar();    return 0;}Kyleson Jonica Kyleson JonicaNonica Jonica Nonica Jonicause_count:3</code></pre><p>当string的最后一个拥有者shared_ptr被销毁,所指对象随即调用delete<br>对象的delete不一定发生在 程序终点 , 将nullptr赋值给x或者调整vector大小使其只含有y,则都会调用delete</p><h4 id="自定义delete"><a href="#自定义delete" class="headerlink" title="自定义delete"></a>自定义delete</h4><pre><code class="lang-cpp">    shared_ptr&lt;string&gt; x(new string(&quot;kyleson&quot;),                         [](string *p){                            cout &lt;&lt; &quot;delete&quot; &lt;&lt; *p;                            delete p;                        });</code></pre><p>当最后一个拥有者被销毁时,将调用该lambda函数</p><p>shared point的默认调用delete，而非delete [],当智能指针指向数组时需自定义delete</p><pre><code class="lang-cpp">shared_ptr&lt;int&gt; p(new int[10], [](int *p) {delete[] p; });shared_ptr&lt;int&gt; p(new int[10],std::default_delete&lt;int[]&gt;());//利用unique_ptr提供的辅助函数</code></pre><h4 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h4><p>weak_ptr共享但不拥有某对象,一旦最末拥有该对象的shared_ptr失去拥有权,任何weak_ptr都会自动成空</p><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;memory&gt;using namespace std;class Person {public:    string name;    shared_ptr&lt;Person&gt; mother;    shared_ptr&lt;Person&gt; father;    vector&lt;shared_ptr&lt;Person&gt;&gt; kids;    Person(const string &amp;name,            shared_ptr&lt;Person&gt; m = nullptr,            shared_ptr&lt;Person&gt; f = nullptr) :           name(name), mother(m), father(f) {};    ~Person(){        std::cout &lt;&lt; &quot;delete &quot; &lt;&lt; name &lt;&lt; endl;    }};shared_ptr&lt;Person&gt; initFamily(const string &amp;name) {    shared_ptr&lt;Person&gt; mom(new Person(name + &quot;&#39;s mom&quot;));    shared_ptr&lt;Person&gt; dad(new Person(name + &quot;&#39;s dad&quot;));    shared_ptr&lt;Person&gt; kid(new Person(name, mom, dad));    mom-&gt;kids.push_back(kid);    dad-&gt;kids.push_back(kid);    return kid;}int main() {    shared_ptr&lt;Person&gt; p = initFamily(&quot;kyleson&quot;);    cout &lt;&lt; &quot;kyleson&#39;s family exits&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;- kyleson is shared &quot; &lt;&lt; p.use_count() &lt;&lt; &quot; times&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;- name of 1st kid of kyleson&#39;s mom:&quot;        &lt;&lt; p-&gt;mother-&gt;kids[0]-&gt;name &lt;&lt; endl;    p = initFamily(&quot;Ninoca&quot;);    cout &lt;&lt; &quot;- Ninoca is shared &quot; &lt;&lt; p.use_count() &lt;&lt; &quot; times&quot; &lt;&lt; endl;    getchar();    return 0;}kyleson&#39;s family exits- kyleson is shared 3 times- name of 1st kid of kyleson&#39;s mom:kyleson- Ninoca is shared 3 times</code></pre><p>程序结束时,并未打印”delete kyleon”或“delete Ninoca”，即未执行析构函数,Person内部存在循环指向,其对象在程序结束时仍至少被一个shared_ptr指向.</p><pre><code class="lang-cpp">vector&lt;weak_ptr&lt;Person&gt;&gt; kids;cout &lt;&lt; &quot;- name of 1st kid of kyleson&#39;s mom:&quot;        &lt;&lt; p-&gt;mother-&gt;kids[0].lock()-&gt;name &lt;&lt; endl;kyleson&#39;s family exits- kyleson is shared 1 times- name of 1st kid of kyleson&#39;s mom:kylesondelete kylesondelete kyleson&#39;s daddelete kyleson&#39;s mom- Ninoca is shared 1 times...</code></pre><p>使用weak_ptr将会解决循环指向问题,当改变p的指向后调用了析构函数,且当程序结束时”Ninoca”的析构函数也将被调用</p><pre><code class="lang-cpp">int *x = new int;shared_ptr&lt;int&gt; sp1(x);shared_ptr&lt;int&gt; sp2(x);//错误shared_ptr&lt;int&gt; sp3 = sp1;//正确</code></pre><p>问题出在sp1和sp2意味着”两个指向团队”,都会在丢失x的拥有权时释放资源，因此相应的资源会被释放两次而导致错误</p><pre><code class="lang-cpp">class Person {public:    ...    void setParentAndTheirKids(shared_ptr&lt;Person&gt; m = nullptr, shared_ptr&lt;Person&gt; f = nullptr) {        mother = m;        father = f;        if (m != nullptr)            m-&gt;kids.push_back(shared_ptr&lt;Person&gt;(this));//错误 引入了新的指向团队        if (f != nullptr)            f-&gt;kids.push_back(shared_ptr&lt;Person&gt;(this));//错误 引入了新的指向团队    }};</code></pre><p>根据this建立的shared_ptr同样建立了新的”指向团队”</p><pre><code class="lang-cpp">class Person :std::enable_shared_from_this&lt;Person&gt;{public:    ...    void setParentAndTheirKids(shared_ptr&lt;Person&gt; m = nullptr, shared_ptr&lt;Person&gt; f = nullptr) {        mother = m;        father = f;        if (m != nullptr)            m-&gt;kids.push_back(shared_from_this());        if (f != nullptr)            f-&gt;kids.push_back(shared_from_this());    }};</code></pre><h4 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h4><p>独占式拥有 同一时间只有一个smart pointer指向该对象</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++教程(3) 模板和泛型编程</title>
    <link href="/2019/07/06/C++%E6%95%99%E7%A8%8B(3)%20%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    <url>/2019/07/06/C++%E6%95%99%E7%A8%8B(3)%20%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>通过 template <typename T>定义函数模板,T的类型由编译时根据模板函数的使用情况而定 即根据传入的实参推断T的类型.由此模板函数即可处理任何数据类型,而不用为每种数据类型编写重复的函数代码</p><pre><code class="lang-cpp">#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;int compare(const T &amp;a, const T &amp;b) {    if(a &lt; b) return -1;    if(a &gt; b) return 1;    return 0;}int main() {    int a = 1, b = 5;    double c = 2, d = -1;    string e = &quot;A&quot;, f = &quot;A&quot;;    std::cout &lt;&lt; compare(a, b) &lt;&lt; std::endl;    std::cout &lt;&lt; compare(c, d) &lt;&lt; std::endl;    std::cout &lt;&lt; compare(e, f) &lt;&lt; std::endl;    getchar();    return 0;}结果: -1 1 0</code></pre><p>模板函数返回值</p><pre><code class="lang-cpp">template &lt;typename T&gt;T compare(const T &amp;a, const T &amp;b) {    T temp = b;    ....    return temp;}</code></pre><p>多个模板函数参数</p><pre><code class="lang-cpp">template &lt;typename T,typename U&gt;int compare(const T &amp;a, const U &amp;b) {    ....}</code></pre><p>内联模板函数</p><pre><code class="lang-cpp">template &lt;typename T&gt;inline int min(const T &amp;a, const T &amp;b);</code></pre><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;string&gt;#include &lt;stdexcept&gt;using namespace std;template &lt;class T&gt;class Stack {    private:        vector&lt;T&gt; elems;    public:        void push(T const&amp;); //入栈        void pop();          //出栈        T top() const;       //栈顶元素        bool empty() const {            return elems.empty();        }};template &lt;class T&gt;void Stack&lt;T&gt;::push(T const&amp; elem){    elems.push_back(elem);}template &lt;class T&gt;void Stack&lt;T&gt;::pop(){    if (elems.empty()) {        throw out_of_range(&quot;Stack&lt;&gt;::pop(): empty stack&quot;);    }    elems.pop_back();}template &lt;class T&gt;T Stack&lt;T&gt;::top() const{    if (elems.empty()) {        throw out_of_range(&quot;Stack&lt;&gt;::top(): empty stack&quot;);    }    return elems.back();}int main(){    try {        Stack&lt;int&gt;    intStack;  // int 类型的栈         Stack&lt;string&gt; stringStack;    // string 类型的栈         // 操作 int 类型的栈         intStack.push(7);        cout &lt;&lt; intStack.top() &lt;&lt; endl;        // 操作 string 类型的栈         stringStack.push(&quot;hello&quot;);        cout &lt;&lt; stringStack.top() &lt;&lt; std::endl;        stringStack.pop();        //stringStack.pop();    }    catch (exception const&amp; ex) {        cerr &lt;&lt; &quot;Exception: &quot; &lt;&lt; ex.what() &lt;&lt; endl;        getchar();        return -1;    }    getchar();    return 0;}</code></pre><p>Note:T top() <strong>cons</strong>t; 表示函数Top()为只读操作,不能对类成员进行修改<br>默认模板参数</p><pre><code class="lang-cpp">template &lt;class T=int&gt; class Stack {...}</code></pre><h3 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h3><p>普通类里定义模板函数或模板内部类</p><pre><code class="lang-cpp">class Car {    template &lt;typename T&gt; void run(T &amp;);};//定义template&lt;typename T&gt; void Car::run(T &amp; a,){...}</code></pre><p>类模板里定义独立的成员模板</p><pre><code class="lang-cpp">template &lt;typename T&gt; class Car {    template &lt;typename U&gt; void run (U a, U b);};//定义template&lt;typename T&gt;template&lt;typename U&gt;void Car&lt;T&gt;::run(U a, U b){...}</code></pre><h3 id="函数模板显式实参"><a href="#函数模板显式实参" class="headerlink" title="函数模板显式实参"></a>函数模板显式实参</h3><p>显示模板实参在调用时由用户指出</p><pre><code class="lang-cpp">template &lt;typename T1,typename T2,typename T3&gt;T3 sum(T1,T2)；//T3为显示模板实参double a = 2.0,b = 3.0;auto val = sum&lt;int&gt;(a,b);//指定显示模板实参T3为int，T2,T3由a，b推断得出</code></pre><h3 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h3><pre><code class="lang-cpp">template &lt;typename T,typename ... Args&gt;void foo(T &amp;t, const Args&amp; ... rest);foo(1,&#39;A&#39;);foo(1,2,&#39;C&#39;);</code></pre><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++教程(2) 面向对象编程</title>
    <link href="/2019/07/05/C++%E6%95%99%E7%A8%8B(2)%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <url>/2019/07/05/C++%E6%95%99%E7%A8%8B(2)%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="定义和声明"><a href="#定义和声明" class="headerlink" title="定义和声明"></a>定义和声明</h3><pre><code class="lang-cpp">#include&lt;iostream&gt;int add(int, int); //声明函数int main(){    int a = 6, b = 9;    int c = add(a, b);    std::cout &lt;&lt; c &lt;&lt; std::endl;    getchar();    return 0;}//定义函数int add(int a , int b){    int c = a + b;    return c;}</code></pre><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><pre><code class="lang-cpp">int func(int val) //副本传递//副本传递时,修改val不影响原来的val值int func(int &amp;val) //引用传递int func(int *val) //指针传递//指针和引用传递时,修改val会影响原来的val值int func(int a, int b, int args ...);//可变参数</code></pre><pre><code class="lang-cpp">#实例 数字交换#include&lt;iostream&gt;void func1(int, int);void func2(int &amp;, int &amp;);void func3(int *, int *);int main(){    int a = 6, b = 9;    func1(a, b);    std::cout &lt;&lt; &quot;func1 ----&gt; a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot;&lt;&lt; b &lt;&lt; std::endl; //a,b未交换    func2(a, b);    std::cout &lt;&lt; &quot;func2 ----&gt; a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; std::endl; //a,b被交换    func3(&amp;a, &amp;b);    std::cout &lt;&lt; &quot;func3 ----&gt; a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; std::endl;//a,b被交换    getchar();    return 0;}void func1(int a , int b){    int temp = 0;    temp = a;    a = b;    b = temp;}void func2(int &amp;a, int &amp;b) {    int temp = 0;    temp = a;    a = b;    b = temp;}void func3(int *a, int *b) {    int *temp = 0;    temp = a;    a = b;    b = temp;}结果:func1 ----&gt; a:6 b:9func2 ----&gt; a:9 b:6func3 ----&gt; a:9 b:6</code></pre><h3 id="函数地址作为函数参数"><a href="#函数地址作为函数参数" class="headerlink" title="函数地址作为函数参数"></a>函数地址作为函数参数</h3><pre><code class="lang-cpp">#include&lt;iostream&gt;void swap(int &amp;, int &amp;);void func1(int &amp;, int &amp;, void(*pf)(int &amp;, int &amp;));int main(){    int a = 6, b = 9;    void(*pf)(int &amp;, int &amp;);    pf = swap;    (*pf)(a,b);    std::cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; std::endl; //a,b被交换    int c = 17, d = 29;    func1(c,d,pf);    std::cout &lt;&lt; &quot;c:&quot; &lt;&lt; c &lt;&lt; &quot; d:&quot; &lt;&lt; d &lt;&lt; std::endl; // c,d被交换    getchar();    return 0;}void func1(int &amp;c,int &amp;d,void (*pf)(int &amp;,int &amp;)) {    (*pf)(c,d);}void swap(int &amp;a, int &amp;b) {    int temp = 0;    temp = a;    a = b;    b = temp;}结果:a:9 b:6c:29 d:17</code></pre><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>常规函数的调用过程<br>程序执行到”函数指令”代码处时,立即存储”函数指令”代码的内存地址,并将函数参数复制到堆栈,然后跳到函数起点的内存单元((函数的内存地址,非”函数指令”代码地址)执行函数代码,函数执行结束后跳回保存的”函数指令”内存地址处,即跳回到程序执行函数指令的那一行,然后继续执行余下的指令.<br>内联函数调用过程<br>程序执行到”函数指令”代码处时,编译器将调用的函数代码替换掉该函数指令,无需再跳转到函数的位置去执行.速度比常规函数调用快,但内存开销大,假设程序有10个地方条用了同一个内联函数,则程序中将包含该内联函数代码的10个副本.<br><img src="/images/func.png" srcset="/img/loading.gif" alt=""></p><pre><code class="lang-cpp">#include &lt;iostream&gt;using namespace std;inline int Max(int x, int y){     return (x &gt; y) ? x : y;}int main(){     std::cout &lt;&lt; &quot;Max (20,10):&quot; &lt;&lt; Max(20, 10) &lt;&lt; std::endl;     std::cout &lt;&lt; &quot;Max (0,200): &quot; &lt;&lt; Max(0, 200) &lt;&lt; std::endl;     std::cout &lt;&lt; &quot;Max(100,1010): &quot; &lt;&lt; Max(100, 1010) &lt;&lt; std::endl;     return 0;}结果:Max (20,10): 20Max (0,200): 200Max (100,1010): 1010</code></pre><h3 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h3><p>带默认参数的函数 必须从右至左添加默认值</p><pre><code class="lang-cpp">void func(int a,int b,double c = 3.14); //合法void func(int a,int b = 2,double c); //非法#调用时具有默认参数的参数可选func(1,2);func(1,2,3);</code></pre><hr><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h3><p>person.h 声明类person的头文件<br>若在类中声明函数暨定义,则函数当作内联函数处理</p><pre><code class="lang-cpp">#include&lt;string&gt;class person {public:    person();    person(std::string name);    std::string print_info(std::string name,int year);    void print_name();    void print();    int add(int a,int b){return a + b}//当作内联函数处理private:    std::string name;};</code></pre><p>person.cpp 定义类person中的函数和变量</p><pre><code class="lang-cpp">#include &quot;person.h&quot;#include&lt;iostream&gt;#include&lt;string&gt;person::person(){};person::person(std::string name){    person::name = name;}std::string person::print_info(std::string name, int year){    std::cout &lt;&lt; &quot;your name is &quot; &lt;&lt; name &lt;&lt; &quot; and your age is &quot; &lt;&lt; year &lt;&lt; std::endl;    return &quot;hi &quot; + name;}void person::print_name(){    std::cout &lt;&lt; person::name &lt;&lt; std::endl;}void person::print(){    std::cout &lt;&lt; &quot;hello person &quot; &lt;&lt; std::endl;}</code></pre><p>main.cpp 使用person类</p><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;string&gt;#include &quot;person.h&quot;int main(){    person p1;    p1.print();    person p2(&quot;kyleson&quot;);    p2.print_name();    std::string info = p2.print_info(&quot;kyleson&quot;,19);    std::cout &lt;&lt; info &lt;&lt; std::endl;    getchar();    return 0;}结果:hello personkylesonyour name is kyleson and your age is 19hi kyleson</code></pre><h3 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h3><p>Date类中的成员函数(+const)表示函数为只读函数,不能对类Date的成员和状态进行修改</p><pre><code class="lang-cpp">class Date {    int d, m, y;public:    int day() const { return d; }    int month() const;};int Date::month() const {    return Date::m;}</code></pre><h3 id="mutable成员"><a href="#mutable成员" class="headerlink" title="mutable成员"></a>mutable成员</h3><p>mutable修饰的成员仍可被常量成员函数修改</p><pre><code class="lang-cpp">class Date {    int d, m, y;public:    int day() const { return d; }    int month() const;private:    int century;    mutable int cache;};int Date::month() const {    Date::century = 0;//错误,month()函数不可修改century的值    Date::cache = 0;    return Date::m;}</code></pre><h3 id="自引用"><a href="#自引用" class="headerlink" title="自引用"></a>自引用</h3><pre><code class="lang-cpp">class Date {    int d = 12, m = 6, y =2018;public:    Date&amp; add_day(){ d++; };    Date&amp; add_month(){ m++; };    Date&amp; add_year() { y++; };private:    int cache;    mutable int modied;};int main(){    Date date;    date.add_year().add_month().add_day();    getchar();    return 0;}</code></pre><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>类的析构函数是类的一种特殊的成员函数,在每次删除所创建的对象时执行<br>析构函数的名称与类的名称完全相同,由波浪号(~)作为其前缀,析构函数不会返回任何值,也不能带有任何参数.析构函数有助于在跳出程序(比如关闭文件、释放内存等）前释放资源.</p><pre><code class="lang-cpp">#include &lt;iostream&gt;using namespace std;class Line{  public:     Line(); // 构造函数声明     ~Line(); // 析构函数声明};Line::Line(void){     cout &lt;&lt; &quot;Object is being created&quot; &lt;&lt; endl;}Line::~Line(void){     cout &lt;&lt; &quot;Object is being deleted&quot; &lt;&lt; endl;     }// 程序的主函数int main(){     Line line;     return 0;}结果:Object is being createdObject is being deleted</code></pre><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>访问类的 private 和 protected 成员</p><pre><code class="lang-cpp">#include &lt;iostream&gt;using namespace std;class Box{     double width;     public:        friend void printWidth(Box box);         void setWidth(double wid);};void Box::setWidth(double wid){     width = wid;}//注意：printWidth() 不是任何类的成员函数void printWidth(Box box){     cout &lt;&lt; &quot;Width of box : &quot; &lt;&lt; box.width &lt;&lt; endl;}int main(){    Box box;    box.setWidth(10.0);    printWidth(box);    return 0;}</code></pre><h3 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h3><pre><code class="lang-cpp">#include &lt;iostream&gt;using namespace std;class Box{public:       Box(double length = 2.0){       length = length; } int compare(Box box){       return this-&gt; length &gt; box. length; }private:      double length; };int main(void){     Box Box1(3.3);      Box Box2(8.5);      if(Box1.compare(Box2)){          cout &lt;&lt; &quot;Box2 is smaller than Box1&quot; &lt;&lt; endl;     }else{         cout &lt;&lt; &quot;Box2 is equal to or larger than Box1&quot; &lt;&lt; endl;}    return 0;}</code></pre><h3 id="指向类的指针"><a href="#指向类的指针" class="headerlink" title="指向类的指针"></a>指向类的指针</h3><pre><code class="lang-cpp">#include &lt;iostream&gt;using namespace std;class Box{public:     Box(double h = 2.0){         height = h; } double Volume(){        return length * breadth *height; }private:       double height; };int main(void){      Box Box1(3.3);       Box *ptrBox;       ptrBox = &amp;Box1;      cout &lt;&lt; &quot;Volume of Box1: &quot; &lt;&lt; ptrBox-&gt;Volume() &lt;&lt; endl;      return 0;}</code></pre><h3 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h3><p>静态成员在类的所有对象中是共享的, 无论创建多少个类的对象，静态成员都只有一个副本</p><pre><code class="lang-cpp">class Box{    public:         static int objectCount;         Box(double h = 2.0){         height = h;         objectCount++;     }     double Volume(){         return length * breadth *height;     }    private:          double height; };int Box::objectCount = 0;int main(void){     Box Box1(3.3);      Box Box2(8.5);      cout &lt;&lt; &quot;Total objects: &quot; &lt;&lt; Box::objectCount &lt;&lt; endl; //objectCount = 2     return 0;}</code></pre><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><pre><code class="lang-cpp">#include &lt;iostream&gt;using namespace std;// 基类class Shape {  public:    void setWidth(int w) {        width = w;    }    void setHeight(int h) {        height = h;    }  protected:    int width;    int height;};// 派生类class Rectangle : public Shape {  public:    int getArea() {        return (width * height);     }};int main(void) {    Rectangle Rect;    Rect.setWidth(5);    Rect.setHeight(7);    cout &lt;&lt; &quot;Total area:&quot; &lt;&lt; Rect.getArea() &lt;&lt; endl;    getchar();    return 0;}</code></pre><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><pre><code class="lang-cpp">// 基类class Shape {...};class PaintCost {...};// 多继承class Rectangle : public Shape, public PaintCost {...};</code></pre><h3 id="虚函数和纯虚函数-virtual-修饰符"><a href="#虚函数和纯虚函数-virtual-修饰符" class="headerlink" title="虚函数和纯虚函数 virtual 修饰符"></a>虚函数和纯虚函数 virtual 修饰符</h3><p>类中被声明为虚函数的函数在基类中实现也可被派生类重写.<br>类中被声明为纯虚函数的函数在基类中只能声明,定义纯虚函数是为定义一个接口,必须由派生类实现,且这个类是抽象类</p><pre><code class="lang-cpp">class Shape {     //虚函数     virtual int area(){       cout &lt;&lt; &quot;Parent class area :&quot; &lt;&lt; endl;       return 0;     }};class Rectangle : public Shape {     //重写的虚函数     int area(){        cout &lt;&lt; &quot;Rectangle class area :&quot; &lt;&lt; endl;        return (width * height);     }};class Shape {     //纯虚函数 由派生类实现     virtual int area() = 0;};</code></pre><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多个派生类根据需要对基类的虚函数进行了不同的实现,在函数调用时会根据派生类的不同进行相应的调用</p><pre><code class="lang-cpp">#include &lt;iostream&gt; using namespace std;class Shape {  public:    virtual void area() {        cout &lt;&lt; &quot;Parent class area :&quot; &lt;&lt; endl;    }};class Rectangle : public Shape {  public:    void area() {        cout &lt;&lt; &quot;Rectangle class area &quot; &lt;&lt; endl;    }};class Triangle : public Shape {  public:    void area() {        cout &lt;&lt; &quot;Triangle class area &quot; &lt;&lt; endl;    }};int main() {    Shape *shape;    Rectangle rec;    Triangle tri;    shape = &amp;rec;    shape-&gt;area();    shape = &amp;tri;    shape-&gt;area();    getchar();    return 0;}结果:Rectangle class area Triangle class area</code></pre><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><pre><code class="lang-cpp">class Date {  public:    int d = 12, m = 6, y = 2018;    Date operator+(const Date &amp;a);    void operator++();};Date Date::operator+(const Date &amp; a){    Date c;    c.d = this-&gt;d + a.d;    c.m = this-&gt;m + a.m;    c.y = this-&gt;y + a.y;    return c;}void Date::operator++(){    this-&gt;y++;    this-&gt;m++;    this-&gt;d++;}int main(){    Date a,b;    Date c = a + b;    std::cout &lt;&lt; c.y &lt;&lt; std::endl;    Date d;    ++d;//++d == d.operator++();    std::cout &lt;&lt; d.y;    getchar();    return 0;}</code></pre><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><pre><code class="lang-cpp">//捕获并处理异常void task_master(){    try{        auto result = do_task();    }catch(some_error){        //todo     }}//抛出异常int do_task(){    if(...)        return result;    else        throw some_error{};}#include &lt;iostream&gt;using namespace std;double division(int a, int b){   if( b == 0 ){      throw &quot;Division by zero condition!&quot;;   }   return (a/b);}int main (){   int x = 50;   int y = 0;   double z = 0;   try {     z = division(x, y);     cout &lt;&lt; z &lt;&lt; endl;   }catch (const char* msg) {     cerr &lt;&lt; msg &lt;&lt; endl;   }   return 0;}</code></pre><p>C++标准异常</p><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;exception&gt;using namespace std;struct MyException : public exception{  const char * what() const throw (){    return &quot;C++ Exception&quot;;  }};int main(){  try{    throw MyException();  }catch(MyException&amp; e){    std::cout &lt;&lt; &quot;MyException caught&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; e.what() &lt;&lt; std::endl;  }catch(std::exception&amp; e){    //其他的错误  }}</code></pre><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++教程(1) 基础</title>
    <link href="/2019/07/05/C++%E6%95%99%E7%A8%8B(1)%20%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/07/05/C++%E6%95%99%E7%A8%8B(1)%20%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="C-尝鲜"><a href="#C-尝鲜" class="headerlink" title="C++尝鲜"></a>C++尝鲜</h2><pre><code class="lang-cpp">#include&lt;iostream&gt;using namespace std;int main(){    int num = 0;    cout &lt;&lt; &quot;how old are you ?&quot; &lt;&lt; endl;    cin &gt;&gt; num;    cout &lt;&lt; &quot;you are&quot; &lt;&lt; num &lt;&lt; &quot; years old&quot; &lt;&lt; endl;    return 0;}</code></pre><pre><code class="lang-cpp">#include&lt;iostream&gt; 引入输入输出流----------------------------------------std::cout 标准输出 std::cout &lt;&lt; 变量; std::cout &lt;&lt; 变量 &lt;&lt; string &lt;&lt; endl; 拼接std::cout &lt;&lt; 变量 &lt;&lt; std::endl; 添加换行----------------------------------------std::cin 标准输入std::cin &gt;&gt; 变量</code></pre><hr><h2 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h2><p><strong>声明和定义变量</strong><br>多个文件使用同一个变量,声明和定义必须分离,且变量的定义只能出现在一个文件中,其他使用到该变量的文件则必须对其声明,不能重复定义<br>(头文件 climits定义了基本数据类型的最大最小值符号常量)</p><pre><code class="lang-cpp">声明变量: extern int i;定义变量 :        int j;         int j = 3.14;        extern int i = 0;  初始化后的extern标记的变量不再是声明变量而是定义变量</code></pre><p><strong>声明常量</strong></p><pre><code class="lang-cpp">const int month = 12;</code></pre><p><strong>auto关键字</strong><br>auto根据初始化值的类型推断变量的类型</p><pre><code class="lang-cpp">auto n =100;auto x =1.5 ;auto str = &quot;kyeleson&quot;</code></pre><p><strong>引用 左值引用&amp; 右值引用&amp;&amp;</strong></p><pre><code class="lang-cpp">int val = 1024; int &amp;ref_val = ival;int i = ref_val; i 被初始化为val的值</code></pre><p>ref_val指向val<br>引用即别名,并非引用对象,仅仅为所存在的对象声明一个新名字<br>引用的初始值必须是一个对象,只能被初始化一次,不可修改<br>一个变量可以定义多个引用<br>对引用的操作与对变量的直接操作完全一样，即修改引用ref_val等同于修改val</p><pre><code class="lang-cpp">#include&lt;iostream&gt;int main(){    int val = 10;    int &amp;ref_val = val;    ref_val = 32;    std::cout &lt;&lt; val &lt;&lt; std::endl;    getchar();    return 0;}结果:32</code></pre><p>右值引用—&gt;临时对象,绑定到右值,可修改且不会再被利用<br>利用廉价的移动操作代替昂贵的拷贝操作以此优化性能</p><pre><code class="lang-cpp">string &amp;&amp;str(&quot;hello&quot;);//右值引用//旧式swap函数template &lt;class T&gt;string swap(T &amp;a ,T &amp;b){    T temp = a;//拷贝a值    a = b;//拷贝b值    b = temp;//拷贝temp值}//右值引用版//temp为右值引用 临时对象template &lt;class T&gt;string swap(T &amp;a ,T &amp;b){    //move(x) == static_cast&lt;T&amp;&amp;&gt;(x)    T temp = move(a);//直接读取a右值    a = move(b);//直接读取b右值    b = move(temp);//直接读取temp右值}</code></pre><p><strong>数组</strong></p><pre><code class="lang-cpp">一维数组int array[5];int array[] = { 1,2,3,4 }；double array[4]{ 1.2,3.4,3.2,4.5 }; //C++11char array[] = { &#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;\0&#39; }；char array[2] = { &#39;a&#39;,&#39;b&#39;,&#39;\0&#39; }；//C风格char array[2] ={&#39;A&#39;,&#39;b&#39;}; // C++自动添加&#39;\0&#39;char str[] = &quot;hello&quot;;多维数组int zippo[4][2];int array[][];非法int array[][4];合法声明n维数组时除了最左边的方括号可以留空外,其他都需要填写数值zippo == &amp;zippo[0];zippo[0] == &amp;zippo[0][0] == zippo; [ zippo和zippo[0]起始于同一地址 具有相同的数值 ]*&amp;zippo[0][0] == **zippo == zippo[0][0]zippo[2][1] == *(*(zippo+2)+1)</code></pre><p><strong>字符串</strong><br>(字符串处理:直到遇到’\0’才结束)</p><pre><code class="lang-cpp">char array[] = { &#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;\0&#39; }；//C风格char array[2] = { &#39;a&#39;,&#39;b&#39;,&#39;\0&#39; }；//C风格char array[2] ={&#39;A&#39;,&#39;b&#39;}; // C++自动添加&#39;\0&#39;char str[] = &quot;hello&quot;;// C++自动添加&#39;\0&#39;(char[int] 定义的字符串是字符串常量 不可使用直接修改)## string类#include&lt;string&gt;string str = &quot;hello&quot;;str = &quot;world&quot;; //可修改string str = {&quot;hello world&quot;};string str{&quot;hello world&quot;};string c(5, &#39;A&#39;); //c = &quot;AAAAA&quot;</code></pre><p><strong>结构体</strong></p><pre><code class="lang-cpp">struct person{    char name[20];    int year;    char sex;};person p = {&quot;kyleson&quot;,19,&#39;男&#39;};std::cout &lt;&lt; p1.name &lt;&lt; std::endl;person *pp = &amp;p;//pp-&gt;name == (*pp).nameC++结构体中可以定义函数 C语言则不可struct sample{    int a;    int b;    int add() {return a + b;}};sample s = { 1,2 };std::cout &lt;&lt; s.add() &lt;&lt; std::endl;</code></pre><p>每个struct只能有唯一的定义<br>对于两个struct,即使成员相同其本身仍是不同的类型</p><pre><code class="lang-cpp">struct addr{    int num;};addr x;addr y = x;//错误,类型不匹配int i = x;//错误,类型不匹配</code></pre><p><strong>联合体 union</strong><br>union是特殊的struct,其所有成员都分配在同一地址空间,即在相同的内存位置存储不同的数据类型,union实际占用的空间大小与其最大的成员相同,并且在同一时刻union只保存一个成员的值</p><pre><code class="lang-cpp">union value{   char sex;   int sex_num;}value val;val.sex = &#39;男&#39;;//根据类型需求设置成员及值</code></pre><p><strong>枚举</strong><br>enum Name{…}枚举值隐式转换为整数类型,枚举值名字与枚举本身位于同一作用域</p><pre><code class="lang-cpp">enum color{ red,blue,black,white };color brand = red;std::cout &lt;&lt; brand &lt;&lt; std::endl;brand = 10;// 错误 非枚举类型brand = color(blue);brand = color(4);int c = red;//隐式转换为intenum bit{one = 10,two = 22,three};bit b = three; //three = 23</code></pre><p>enum class Name{…}限定作用域的强类型枚举,枚举值不会隐式转换为其他类型,枚举值名字位于枚举局部作用域</p><pre><code class="lang-cpp">enum class Color{red,green,yellow};Color c = Color::red;//局部作用域Color color = red;//错误int c = Color::red;//错误</code></pre><p>指定枚举初始类型</p><pre><code class="lang-cpp">enum class color:char{red,green,yellow};</code></pre><p><strong>指针</strong><br>指向对象的对象[存储指向对象的地址],在生命周期内可指向不同的对象</p><pre><code class="lang-cpp">int *p; //p指向int类型对象的指针int val = 19;int *ip = &amp;val;ip是指向变量val的指针,存储变量val的地址 此处&amp;:取地址符 非引用std::cout &lt;&lt; ip ---&gt; val的地址值std::cout &lt;&lt; *ip ---&gt; val的值 42</code></pre><p>指针的值(状态):指向一个对象、指向紧邻对象所占空间的下一个位置、空指针、无效指针<br>利用指针访问对象:操作符 *</p><pre><code class="lang-cpp">int num = 12; int * p = &amp;num; std::cout &lt;&lt; *p &lt;&lt;std::endl;打印结果:12</code></pre><p>空指针:不指向任何对象 </p><pre><code class="lang-cpp">int *p = nullptr;int *p =0;</code></pre><p>通过new分配内存</p><pre><code class="lang-cpp">int *p = new int;*p = 10;std::cout &lt;&lt; *p &lt;&lt; std::endl;delete p;</code></pre><p>void* 指针:存放任意对象的地址</p><pre><code class="lang-cpp">double pi = 3.14,*pd = &amp;pi ;void pv = &amp;pi;pv == pd ? --&gt; truenote：不能直接操作void*指针所指向的对象,对象类型未知</code></pre><p>指针的指针:指向指针的指针,存储指针的本身的地址</p><pre><code class="lang-cpp">int val = 1024;int *p = &amp;val; //指向一个int类型的变量int **pp = &amp;p;//指向一个int类型的指针变量</code></pre><p><img src="/images/pointer.jpg" srcset="/img/loading.gif" alt=""><br>指向常量的指针,不允许被修改</p><pre><code class="lang-cpp">const double pi = 3.14;const double *p1 = &amp;pi;double *p2 = &amp;pi;// 错误 p2被定义为普通指针*p1 = 42; //错误 不允许赋值</code></pre><p>const指针:常量指针,指针本身也是常量,必须被初始化</p><pre><code class="lang-cpp">int errNum = 0;int *const curErr = &amp;errNum; //curErr一直指向errNum对象const double pi = 3.14;const double *const pip = &amp;pi ;// pip指向常量对象的常量指针int num = 1;curErr = &amp;num; //错误 指向的对象不允许被改变*curErr = 1; //正确 指向的对象非常量,其值可被修改*pip = 1; //错误 指向的对象为常量,其值不能被修改</code></pre><p>函数指针 指向函数的指针,保存着函数代码起始处的地址</p><pre><code class="lang-cpp">函数：void toUpper(char*);指向函数的指针：void (*pf) (char*);pf = toUpper; 函数指针赋值char mis[6]=&quot;hello&quot;;#把toUpper作用于mis(*pf)(mis);pf(mis)bool (*pf)(const string &amp;,const string &amp;)</code></pre><p><strong> 指针和数组</strong></p><pre><code class="lang-cpp">int array[5] = {1,2,3,4 };array本身是指向array第一个元素的指针std::cout&lt;&lt; *array; ---&gt; 1char array[] = { &#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39; };char str1 = array[0];char str2 = *array;char str4 = array[1];char str3 = *(array +1);std::cout &lt;&lt; str1 &lt;&lt; str2 &lt;&lt; str3 &lt;&lt; str4 &lt;&lt; std::endl;输出:a a b bchar *start = begin(array); //指向array首元素的指针char *end = end(array); //指向array尾元素下一位置的指针 默认的空字符int *pts[10]; //pts:含有10个整型指针的数组int(*ptr)[10]; //ptr:指向(含有10个整型的数组)的指针char *name = &quot;kyleson&quot;;char str[5] = &quot;ABC&quot;;char *p = str;int array[] = { 1,2,3 };int *pa = array;std::cout &lt;&lt; name &lt;&lt; *name &lt;&lt; *(name + 1) &lt;&lt; std::endl;//值: kyleson k ystd::cout &lt;&lt; p &lt;&lt; *p &lt;&lt; std::endl;//值: ABC Astd::cout &lt;&lt; pa &lt;&lt; *pa &lt;&lt; std::endl; //值: 000000F0E032F900 1std::cout &lt;&lt; string ----&gt; (字符串处理:直到遇到&#39;\0&#39;才结束)</code></pre><p><strong>类型别名 typedef</strong></p><pre><code class="lang-cpp">typedef double wages; //wages是double的同义词typedef wages base,*p; //base是wages的同义词,p是double* 的同义词wage hourly,weekly; //等价于double hourly,weekly;typedef char* pstr; //复合类型,指向char的指针const pstr str = 0; //指向char的常量指针,并不是指向常量char的指针const pstr* ps; //指向[指向char类型的常量指针]的指针const char* str ;//指向常量char的指针</code></pre><p><strong>类型指示符 decltype</strong></p><pre><code class="lang-cpp">decltype(fun()) sum = x ; //sum的类型是函数fun()的返回类型</code></pre><p><strong>vector 对象的集合</strong></p><pre><code class="lang-cpp">#include&lt;vector&gt;vector&lt;string&gt; strs;//定义空集合vector&lt;string&gt; vetor = {&quot;a&quot;,&quot;person&quot;,&quot;hi&quot;};// 列表初始化vector&lt;int&gt; v_num(10,9); //创建指定数量的元素 每个元素被赋值为9vector&lt;int&gt; ten_num(10); // 10个元素 每个元素被初始化为0strs.push_back(&quot;hello&quot;);//添加元素</code></pre>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(1)Faster R-CNN implemented by Keras</title>
    <link href="/2019/07/04/(1)Faster%20R-CNN%20%20implemented%20by%20Keras/"/>
    <url>/2019/07/04/(1)Faster%20R-CNN%20%20implemented%20by%20Keras/</url>
    
    <content type="html"><![CDATA[<p><strong>训练数据</strong><br>训练数据集下载地址:<br>1.下载class-descriptions-boxable.csv 即 V4下的Metadata ClassNames (训练数据集的所有类别)<br><a href="https://storage.googleapis.com/openimages/web/download.html" target="_blank" rel="noopener">https://storage.googleapis.com/openimages/web/download.html</a><br>2.下载train-images-boxable.csv和train-annotations-bbox.csv (已标记的图片集)<br><a href="https://www.figure-eight.com/dataset/open-images-annotated-with-bounding-boxes/" target="_blank" rel="noopener">https://www.figure-eight.com/dataset/open-images-annotated-with-bounding-boxes/</a><br>note:原始训练集有600个类别,数据量庞大,只抽取其中两个类别的图片集作为训练数据集,如Car,Person</p><p><img src="\images\object-detection\open-image-files.jpg" srcset="/img/loading.gif" alt=""></p><hr><p><strong>数据集预览</strong></p><pre><code class="lang-python">import numpy as npimport timeimport sysimport osimport randomfrom skimage import ioimport pandas as pdfrom matplotlib import pyplot as pltfrom shutil import copyfileimport cv2import tensorflow as tfbase_path = &#39;D:/data/open-image-v4&#39;#数据集下载的主目录images_boxable_fname = &#39;train-images-boxable.csv&#39;annotations_bbox_fname = &#39;train-annotations-bbox.csv&#39;class_descriptions_fname = &#39;class-descriptions-boxable.csv&#39;</code></pre><p>原始图片预览</p><pre><code class="lang-python">images_boxable = pd.read_csv(os.path.join(base_path, images_boxable_fname))images_boxable.head()</code></pre><p><img src="\images\object-detection\1.jpg" srcset="/img/loading.gif" alt=""></p><p>图片标记数据预览</p><pre><code class="lang-python">annotations_bbox = pd.read_csv(os.path.join(base_path, annotations_bbox_fname))annotations_bbox.head()</code></pre><p><img src="\images\object-detection\2.jpg" srcset="/img/loading.gif" alt=""></p><p>类别预览</p><pre><code class="lang-python">class_descriptions = pd.read_csv(os.path.join(base_path, class_descriptions_fname))class_descriptions.head()</code></pre><p><img src="\images\object-detection\3.jpg" srcset="/img/loading.gif" alt=""></p><p>通过annotations_bbox将目标/类别在原图上标记出来</p><pre><code class="lang-python">image_name = images_boxable[&#39;image_name&#39;][5]image_url = images_boxable[&#39;image_url&#39;][5]print(image_name,image_url)</code></pre><p>e17acd05b631d330.jpg <a href="https://requestor-proxy.figure-eight.com/figure_eight_datasets/open-images/train/e17acd05b631d330.jpg" target="_blank" rel="noopener">https://requestor-proxy.figure-eight.com/figure_eight_datasets/open-images/train/e17acd05b631d330.jpg</a></p><pre><code class="lang-python">img = io.imread(image_url) #读取网络图片height, width, _ = img.shapeprint(img.shape)plt.figure(figsize=(15,10))plt.subplot(1,2,1)plt.title(&#39;Original Image&#39;)plt.imshow(img)img_id = image_name[:16]bboxs = annotations_bbox[annotations_bbox[&#39;ImageID&#39;]==img_id]img_bbox = img.copy()for index, row in bboxs.iterrows():    xmin = row[&#39;XMin&#39;]    xmax = row[&#39;XMax&#39;]    ymin = row[&#39;YMin&#39;]    ymax = row[&#39;YMax&#39;]    xmin = int(xmin*width)    xmax = int(xmax*width)    ymin = int(ymin*height)    ymax = int(ymax*height)    label_name = row[&#39;LabelName&#39;]    class_series = class_descriptions[class_descriptions[&#39;name&#39;]==label_name]    class_name = class_series[&#39;class&#39;].values[0]    cv2.rectangle(img_bbox,(xmin,ymin),(xmax,ymax),(0,255,0),2)    font = cv2.FONT_HERSHEY_SIMPLEX    cv2.putText(img_bbox,class_name,(xmin,ymin-10), font, 1,(0,255,0),2)plt.subplot(1,2,2)plt.title(&#39;Image with Bounding Box&#39;)plt.imshow(img_bbox)plt.show()</code></pre><p><img src="\images\object-detection\4.jpg" srcset="/img/loading.gif" alt=""></p><hr><p><strong>训练集构造(检测car、person)</strong></p><p>抽取数据类别,Car,Person</p><pre><code class="lang-python">car = class_descriptions[class_descriptions[&#39;class&#39;]==&#39;Car&#39;]person = class_descriptions[class_descriptions[&#39;class&#39;]==&#39;Person&#39;]print(car)print(person)</code></pre><p>570  /m/0k4j   Car<br>68  /m/01g317  Person</p><p>抽取car、person原始图片下载地址和对应的标记框数据</p><pre><code class="lang-python">#car、person全部标记框数据car_bbox = annotations_bbox[annotations_bbox[&#39;LabelName&#39;]==car[&#39;name&#39;].values[0]]person_bbox = annotations_bbox[annotations_bbox[&#39;LabelName&#39;]==person[&#39;name&#39;].values[0]]car_ids = car_bbox[&#39;ImageID&#39;]person_ids = person_bbox[&#39;ImageID&#39;]#一张图片包含多个标记框,去掉重复的原始图片idcar_ids = np.unique(car_ids)person_ids = np.unique(person_ids)print(&#39;car_ids:&#39;+str(len(car_ids)),&#39;person_ids:&#39;+str(len(person_ids)))</code></pre><p>car_ids:89465 car_ids:248384</p><p>随机选取1000张car和1000张person图片作为训练集</p><pre><code class="lang-python">#打乱次序copy_car_ids = car_ids.copy()random.seed(1)random.shuffle(car_ids)copy_person_ids = person_ids.copy()random.seed(1)random.shuffle(person_ids)n = 1000sub_car_ids = copy_car_ids[:n]sub_person_ids = copy_person_ids[:n]print(sub_car_ids[0:10],sub_person_ids[0:10])</code></pre><p>[‘17729c78b866181e’ ‘7b77dbbc71105e1c’ ‘c9a719e92a035033’<br> ‘58539243ddf350d1’ ‘b4bd75496b4880d8’ ‘6b54b697b13d6573’<br> ‘1e8eab50c0f6ff3a’ ‘ec6ff911833016f3’ ‘a10c03baa942e135’<br> ‘81c73298cc8d5349’] [‘763f5e853b1895df’ ‘d469ba5b2e558fc7’ ‘5348a30462ad2308’<br> ‘751439461f7a5fd3’ ‘5734bee1abe8c58e’ ‘730c2135df540687’<br> ‘14920852dd7e8c93’ ‘6bce959fa9db8fbc’ ‘254dbd00353a1d22’<br> ‘f7b5eabe2c2713c8’]</p><p>获取原始图片下载地址</p><pre><code class="lang-python">sub_car_urls = [images_boxable[images_boxable[&#39;image_name&#39;]==name+&#39;.jpg&#39;] for name in sub_car_ids]sub_person_urls = [images_boxable[images_boxable[&#39;image_name&#39;]==name+&#39;.jpg&#39;] for name in sub_person_ids]print(sub_car_urls[0].values[0][0])  print(sub_car_urls[0].values[0][1])</code></pre><p>17729c78b866181e.jpg<br><a href="https://requestor-proxy.figure-eight.com/figure_eight_datasets/open-images/train/17729c78b866181e.jpg" target="_blank" rel="noopener">https://requestor-proxy.figure-eight.com/figure_eight_datasets/open-images/train/17729c78b866181e.jpg</a></p><p>保存urls到磁盘供复用 </p><pre><code class="lang-python">sub_car_urls_csv = pd.DataFrame()sub_person_urls_csv = pd.DataFrame()for i in range(1000):    sub_car_urls_csv = sub_car_urls_csv.append(sub_car_urls[i], ignore_index = True)    sub_person_urls_csv = sub_person_urls_csv.append(sub_person_urls[i], ignore_index = True)sub_car_urls_csv.to_csv(os.path.join(&#39;D:/data/open-image-v4&#39;,&#39;sub_car_urls.csv&#39;),index=False)sub_person_urls_csv.to_csv(os.path.join(&#39;D:/data/open-image-v4&#39;,&#39;sub_person_urls.csv&#39;),index=False)</code></pre><p>下载图片到磁盘(D:/data/open-image-v4/下新建train-data和test-data文件夹,再分别在train-data和test-data下新建文件夹car和person)</p><pre><code class="lang-python">sub_car_pd = pd.read_csv(os.path.join(base_path, &#39;sub_car_urls.csv&#39;))sub_person_pd = pd.read_csv(os.path.join(base_path, &#39;sub_person_urls.csv&#39;))print(sub_car_pd[&#39;image_name&#39;][0])print(sub_car_pd[&#39;image_url&#39;][0])#建议开启多线程下载#训练图片for i in range(800):    img_car = io.imread(sub_car_pd[&#39;image_url&#39;][i])    car_saved_path = os.path.join(&#39;D:/data/open-image-v4/train-data/car&#39;,sub_car_pd[&#39;image_name&#39;][i])    io.imsave(car_saved_path, img_car)for j in range(800):    img_person = io.imread(sub_person_pd[&#39;image_url&#39;][j])    person_saved_path = os.path.join(&#39;D:/data/open-image-v4/train-data/person&#39;,sub_person_pd[&#39;image_name&#39;][j])    io.imsave(person_saved_path, img_person)#测试图片for i in range(800,1000):    img_car = io.imread(sub_car_pd[&#39;image_url&#39;][i])    car_saved_path = os.path.join(&#39;D:/data/open-image-v4/test-data/car&#39;,sub_car_pd[&#39;image_name&#39;][i])    io.imsave(car_saved_path, img_car)for j in range(800,1000):    img_person = io.imread(sub_person_pd[&#39;image_url&#39;][j])    person_saved_path = os.path.join(&#39;D:/data/open-image-v4/test-data/person&#39;,sub_person_pd[&#39;image_name&#39;][j])    io.imsave(person_saved_path, img_person)</code></pre><p>0000048549557964.jpg<br><a href="https://requestor-proxy.figure-eight.com/figure_eight_datasets/open-images/train/0000048549557964.jpg" target="_blank" rel="noopener">https://requestor-proxy.figure-eight.com/figure_eight_datasets/open-images/train/0000048549557964.jpg</a></p><p>下载完成后,如图所示</p><p><img src="\images\object-detection\5.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="\images\object-detection\6.jpg" srcset="/img/loading.gif" alt=""></p><p>将train-data/car、train-data/person合并到同一文件夹train-data/all下,train-test同理<br>note:由于一张图片可能同时包含car和person,因此合并时会将重复的图片剔除而只保留一张</p><pre><code class="lang-python">file_names = [&#39;car&#39;,&#39;person&#39;]train_path = &#39;D:/data/open-image-v4/train-data&#39;for i in range(len(file_names)):    train_images = os.listdir(os.path.join(train_path,file_names[i]))    for j in range(len(train_images)):        original_path = os.path.join(os.path.join(train_path, label_names[i]), train_images[j])        new_path = os.path.join(os.path.join(train_path, &#39;all&#39;), train_images[j])        copyfile(original_path, new_path)print(&#39;all_train_images&#39;,len(os.listdir(os.path.join(train_path, &#39;all&#39;))))test_path = &#39;D:/data/open-image-v4/test-data&#39;for i in range(len(file_names)):    test_images = os.listdir(os.path.join(test_path,file_names[i]))    for j in range(len(test_images)):        original_path = os.path.join(os.path.join(test_path, label_names[i]), test_images[j])        new_path = os.path.join(os.path.join(test_path, &#39;all&#39;), test_images[j])        copyfile(original_path, new_path)      print(&#39;all_test_images&#39;,len(os.listdir(os.path.join(test_path, &#39;all&#39;))))</code></pre><p>all_train_images 1558<br>all_test_images 401</p><p>构造包含了标记框的训练集和测试集 train.csv和test.csv</p><pre><code class="lang-python">class_descriptions = pd.read_csv(&quot;D:/data/open-image-v4/class-descriptions-boxable.csv&quot;)car = class_descriptions[class_descriptions[&#39;class&#39;]==&#39;Car&#39;]person = class_descriptions[class_descriptions[&#39;class&#39;]==&#39;Person&#39;]print(car,&#39;\n&#39;+car[&#39;name&#39;].values[0])print(person,&#39;\n&#39;+person[&#39;name&#39;].values[0])</code></pre><p>570  /m/0k4j   Car<br>/m/0k4j<br>68  /m/01g317  Person<br>/m/01g317</p><p>抽取car、person的标记框数据</p><pre><code class="lang-python">annotations_bbox = pd.read_csv(&#39;D:/data/open-image-v4/train-annotations-bbox.csv&#39;)car_bbox = annotations_bbox[annotations_bbox[&#39;LabelName&#39;]==car[&#39;name&#39;].values[0]]person_bbox = annotations_bbox[annotations_bbox[&#39;LabelName&#39;]==person[&#39;name&#39;].values[0]]annotations_bbox = pd.concat([car_bbox,person_bbox])print(annotations_bbox.shape)</code></pre><p>(1282796, 13)</p><pre><code class="lang-python">train_df = pd.DataFrame(columns=[&#39;FileName&#39;, &#39;XMin&#39;, &#39;YMin&#39;, &#39;XMax&#39;, &#39;YMax&#39;, &#39;ClassName&#39;])train_path = &#39;D:/data/open-image-v4/train-data/all&#39;train_images = os.listdir(train_path)for i in range(len(train_images)):    sys.stdout.write(&#39;Parse train_imgs &#39; + str(i+1) + &#39;; Number of boxes: &#39; + str(len(train_df)) + &#39;\r&#39;)    sys.stdout.flush()    img_name = train_images[i]    img_id = img_name[0:16]    tmp_df = annotations_bbox[annotations_bbox[&#39;ImageID&#39;]==img_id]    for index, row in tmp_df.iterrows():        labelName = row[&#39;LabelName&#39;]        if labelName == car[&#39;name&#39;].values[0]:            className = &#39;car&#39;        elif labelName == person[&#39;name&#39;].values[0]:            className = &#39;person&#39;        train_df = train_df.append({&#39;FileName&#39;: img_name,                                             &#39;XMin&#39;: row[&#39;XMin&#39;],                                             &#39;YMin&#39;: row[&#39;YMin&#39;],                                             &#39;XMax&#39;: row[&#39;XMax&#39;],                                             &#39;YMax&#39;: row[&#39;YMax&#39;],                                             &#39;ClassName&#39;:className},ignore_index=True)train_df.to_csv(os.path.join(&#39;D:/data/open-image-v4/train-data&#39;, &#39;train.csv&#39;),index=False)</code></pre><p>Parse train_imgs 1557; Number of boxes: 5722</p><pre><code class="lang-python">test_df = pd.DataFrame(columns=[&#39;FileName&#39;, &#39;XMin&#39;, &#39;YMin&#39;, &#39;XMax&#39;, &#39;YMax&#39;, &#39;ClassName&#39;])test_path = &#39;D:/data/open-image-v4/test-data/all&#39;test_images = os.listdir(test_path)for i in range(len(test_images)):    sys.stdout.write(&#39;Parse train_imgs &#39; + str(i+1) + &#39;; Number of boxes: &#39; + str(len(test_df)) + &#39;\r&#39;)    sys.stdout.flush()    img_name = test_images[i]    img_id = img_name[0:16]    tmp_df = annotations_bbox[annotations_bbox[&#39;ImageID&#39;]==img_id]    for index, row in tmp_df.iterrows():        labelName = row[&#39;LabelName&#39;]        if labelName == car[&#39;name&#39;].values[0]:            className = &#39;car&#39;        elif labelName == person[&#39;name&#39;].values[0]:            className = &#39;person&#39;        test_df = test_df.append({&#39;FileName&#39;: img_name,                                             &#39;XMin&#39;: row[&#39;XMin&#39;],                                             &#39;YMin&#39;: row[&#39;YMin&#39;],                                             &#39;XMax&#39;: row[&#39;XMax&#39;],                                             &#39;YMax&#39;: row[&#39;YMax&#39;],                                             &#39;ClassName&#39;:className},ignore_index=True)test_df.to_csv(os.path.join(&#39;D:/data/open-image-v4/test-data&#39;, &#39;test.csv&#39;),index=False)</code></pre><p>Parse train_imgs 401; Number of boxes: 1413</p><pre><code class="lang-python">train_df.head()</code></pre><p><img src="\images\object-detection\7.jpg" srcset="/img/loading.gif" alt=""></p><pre><code>test_df.head()</code></pre><p><img src="\images\object-detection\8.jpg" srcset="/img/loading.gif" alt=""></p><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>目标检测</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VGG16Net</title>
    <link href="/2019/07/03/VGG16Net/"/>
    <url>/2019/07/03/VGG16Net/</url>
    
    <content type="html"><![CDATA[<p><img src="\images\dp-net\VGG16_Summary_Table.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="\images\dp-net\vgg16-neural-network.jpg" srcset="/img/loading.gif" alt=""></p><pre><code class="lang-python">import tensorflow as tffrom tensorflow import kerasfrom tensorflow.keras import layers#模型model = keras.Sequential()# 1st Layermodel.add(layers.Conv2D(input_shape=(224,224,3),filters=64,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))model.add(layers.Conv2D(filters=64,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))model.add(layers.MaxPool2D(pool_size=(3,3),strides=(2,2),padding=&#39;same&#39;))# 2nd Layermodel.add(layers.Conv2D(filters=128,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))model.add(layers.Conv2D(filters=128,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))model.add(layers.MaxPool2D(pool_size=(3,3),strides=(2,2),padding=&#39;same&#39;))# 3rd Layermodel.add(layers.Conv2D(filters=256,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))model.add(layers.Conv2D(filters=256,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))model.add(layers.Conv2D(filters=256,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))model.add(layers.MaxPool2D(pool_size=(3,3),strides=(2,2),padding=&#39;same&#39;))# 4th Layermodel.add(layers.Conv2D(filters=512,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))model.add(layers.Conv2D(filters=512,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))model.add(layers.Conv2D(filters=512,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))model.add(layers.MaxPool2D(pool_size=(3,3),strides=(2,2),padding=&#39;same&#39;))# 5th Layermodel.add(layers.Conv2D(filters=512,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))model.add(layers.Conv2D(filters=512,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))model.add(layers.Conv2D(filters=512,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))model.add(layers.MaxPool2D(pool_size=(3,3),strides=(2,2),padding=&#39;same&#39;))# Passing it to a Fully Connected layermodel.add(layers.Flatten())# 7th Fully Connected Layermodel.add(layers.Dense(4096,activation=&#39;relu&#39;))model.add(layers.Dropout(0.5))# 7th Fully Connected Layermodel.add(layers.Dense(4096,activation=&#39;relu&#39;))model.add(layers.Dropout(0.5))# Output Layermodel.add(layers.Dense(1000,activation=&#39;softmax&#39;))model.summary()</code></pre><pre><code>_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================conv2d_31 (Conv2D)           (None, 224, 224, 64)      1792      _________________________________________________________________conv2d_32 (Conv2D)           (None, 224, 224, 64)      36928     _________________________________________________________________max_pooling2d_13 (MaxPooling (None, 112, 112, 64)      0         _________________________________________________________________conv2d_33 (Conv2D)           (None, 112, 112, 128)     73856     _________________________________________________________________conv2d_34 (Conv2D)           (None, 112, 112, 128)     147584    _________________________________________________________________max_pooling2d_14 (MaxPooling (None, 56, 56, 128)       0         _________________________________________________________________conv2d_35 (Conv2D)           (None, 56, 56, 256)       295168    _________________________________________________________________conv2d_36 (Conv2D)           (None, 56, 56, 256)       590080    _________________________________________________________________conv2d_37 (Conv2D)           (None, 56, 56, 256)       590080    _________________________________________________________________max_pooling2d_15 (MaxPooling (None, 28, 28, 256)       0         _________________________________________________________________conv2d_38 (Conv2D)           (None, 28, 28, 512)       1180160   _________________________________________________________________conv2d_39 (Conv2D)           (None, 28, 28, 512)       2359808   _________________________________________________________________conv2d_40 (Conv2D)           (None, 28, 28, 512)       2359808   _________________________________________________________________max_pooling2d_16 (MaxPooling (None, 14, 14, 512)       0         _________________________________________________________________conv2d_41 (Conv2D)           (None, 14, 14, 512)       2359808   _________________________________________________________________conv2d_42 (Conv2D)           (None, 14, 14, 512)       2359808   _________________________________________________________________conv2d_43 (Conv2D)           (None, 14, 14, 512)       2359808   _________________________________________________________________max_pooling2d_17 (MaxPooling (None, 7, 7, 512)         0         _________________________________________________________________flatten_3 (Flatten)          (None, 25088)             0         _________________________________________________________________dense_11 (Dense)             (None, 4096)              102764544 _________________________________________________________________dropout_8 (Dropout)          (None, 4096)              0         _________________________________________________________________dense_12 (Dense)             (None, 4096)              16781312  _________________________________________________________________dropout_9 (Dropout)          (None, 4096)              0         _________________________________________________________________dense_13 (Dense)             (None, 1000)              4097000   =================================================================Total params: 138,357,544Trainable params: 138,357,544Non-trainable params: 0_________________________________________________________________</code></pre><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>神经网络模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统(3) 内存管理</title>
    <link href="/2019/06/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(3)%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2019/06/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(3)%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>操作系统对内存的划分和动态分配。</p><ul><li>内存空间的分配与回收</li><li>地址转换：逻辑地址和物理地址的转换</li><li>内存空间扩充：虚拟存储技术</li><li>存储保护：保证各道作业在各自的存储空间运行，互不干扰</li></ul><p><strong>内存连续分配管理</strong></p><ol><li><p>单一连续分配：内存分为系统区和用户区，只能用于单用户、单任务操作系统中</p></li><li><p>固定分区分配：将用户内存空间划分为若干个固定大小(分区相等或不等)的区域</p></li><li><p>动态分区分配：根据进程大小动态建立分区，并使分区大小正好适合进程的需要</p><p>分配策略，根据算法找到满足进程需要的空闲分区</p><ul><li><p>首次适应：空闲分区以地址递增的次序链接</p><p>(缺点：低地址出现较多小的空闲分区，查找都需经过这些分区，增加了查找开销)</p></li><li><p>最佳适应：空闲分区以容量递增的次序链接</p><p>(缺点：产生最多的外部碎片)</p></li><li><p>最坏适应：空闲分区以容量递减的次序链接</p><p>(缺点：可能会导致没有可用的大内存块)</p></li><li><p>邻近适应：分配内存时从上次查找结束的地址位置继续查找</p></li></ul></li></ol><p><img src="\images\system\4.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>内存非连续分配管理</strong></p><p>wait….</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Alexnet</title>
    <link href="/2019/06/28/Alexnet/"/>
    <url>/2019/06/28/Alexnet/</url>
    
    <content type="html"><![CDATA[<p><img src="\images\dp-net\AlexNet_Summary_Table.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="\images\dp-net\AlexNet-1.png" srcset="/img/loading.gif" alt=""></p><pre><code class="lang-py">import tensorflow as tffrom tensorflow import kerasfrom tensorflow.keras import layers#模型model = keras.Sequential()# 1st Convolutional Layermodel.add(layers.Conv2D(input_shape=(227,227,3),filters=96,kernel_size=[11,11],strides=(4,4),padding=&#39;valid&#39;,activation=&#39;relu&#39;))model.add(layers.MaxPool2D(pool_size=(3,3),strides=(2,2),padding=&#39;valid&#39;))# 2nd Convolutional Layermodel.add(layers.Conv2D(filters=256,kernel_size=[5,5],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))model.add(layers.MaxPool2D(pool_size=(3,3),strides=(2,2),padding=&#39;valid&#39;))# 3rd Convolutional Layermodel.add(layers.Conv2D(filters=384,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))# 4th Convolutional Layermodel.add(layers.Conv2D(filters=384,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))# 5th Convolutional Layermodel.add(layers.Conv2D(filters=256,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))model.add(layers.MaxPool2D(pool_size=(3,3),strides=(2,2),padding=&#39;valid&#39;))# Passing it to a Fully Connected layermodel.add(layers.Flatten())# 6th Fully Connected Layermodel.add(layers.Dense(4096,activation=&#39;relu&#39;))model.add(layers.Dropout(0.5))# 7th Fully Connected Layermodel.add(layers.Dense(4096,activation=&#39;relu&#39;))model.add(layers.Dropout(0.5))# Output Layermodel.add(layers.Dense(1000,activation=&#39;softmax&#39;))model.summary()</code></pre><pre><code class="lang-cpp">_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================conv2d_25 (Conv2D)           (None, 55, 55, 96)        34944     _________________________________________________________________max_pooling2d_13 (MaxPooling (None, 27, 27, 96)        0         _________________________________________________________________conv2d_26 (Conv2D)           (None, 27, 27, 256)       614656    _________________________________________________________________max_pooling2d_14 (MaxPooling (None, 13, 13, 256)       0         _________________________________________________________________conv2d_27 (Conv2D)           (None, 13, 13, 384)       885120    _________________________________________________________________conv2d_28 (Conv2D)           (None, 13, 13, 384)       1327488   _________________________________________________________________conv2d_29 (Conv2D)           (None, 13, 13, 256)       884992    _________________________________________________________________max_pooling2d_15 (MaxPooling (None, 6, 6, 256)         0         _________________________________________________________________flatten_3 (Flatten)          (None, 9216)              0         _________________________________________________________________dense_12 (Dense)             (None, 4096)              37752832  _________________________________________________________________dropout_9 (Dropout)          (None, 4096)              0         _________________________________________________________________dense_13 (Dense)             (None, 4096)              16781312  _________________________________________________________________dropout_10 (Dropout)         (None, 4096)              0         _________________________________________________________________dense_14 (Dense)             (None, 1000)              4097000   _________________________________________________________________dropout_11 (Dropout)         (None, 1000)              0         _________________________________________________________________dense_15 (Dense)             (None, 1000)              1001000   =================================================================Total params: 63,379,344Trainable params: 63,379,344Non-trainable params: 0_________________________________________________________________</code></pre><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>神经网络模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx-rtmp流媒体服务</title>
    <link href="/2019/06/26/nginx-rtmp%E6%B5%81%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1/"/>
    <url>/2019/06/26/nginx-rtmp%E6%B5%81%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<ol><li><p>安装ffmpeg</p><pre><code class="lang-bash">#安装h264视频编解码库sudo apt-get updatesudo apt-get install libx264-dev#安装ffmpeg#通过源安装&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;sudo add-apt-repository ppa:djcj/hybrid #添加源sudo apt-get updatesudo apt-get install ffmpegsudo ffmpeg -version #验证是否安装成功#源码安装&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;wget http://ffmpeg.org/releases/ffmpeg-3.0.9.tar.bz2sudo tar jxvf ffmpeg-3.0.9.tar.bz2cd ffmpeg-3.0.9/sudo ./configure --enable-shared --enable-pthreads --enable-gpl  --enable-avresample $ --enable-libx264 --enable-libtheora  --disable-yasmsudo make   sudo make install</code></pre></li><li><p>安装nginx</p><pre><code class="lang-bash">#源码安装&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;#安装依赖sudo apt-get install build-essentialsudo apt-get install libtoolsudo apt-get updatesudo apt-get install libpcre3 libpcre3-devsudo apt-get install zlib1g-devsudo apt-get install openssl#安装sudo mkdir nginxcd nginxgit clone https://github.com/arut/nginx-rtmp-module.gitsudo wget http://nginx.org/download/nginx-1.12.0.tar.gzsudo tar -zxvf nginx-1.12.0.tar.gzcd nginx-1.12.0/sudo ./configure --prefix=/usr/local/nginx --with-http_ssl_module --add-module=../nginx-rtmp-modulesudo makesudo make install#启动：sudo /usr/local/nginx/sbin/nginx#orsudo /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</code></pre></li><li><p>配置Nginx流媒体服务器</p><pre><code class="lang-bash">#停止sudo /usr/local/nginx/sbin/nginx -s stop sudo vim /usr/local/nginx/conf/nginx.conf#添加rtmp {    server {            listen 1935;            chunk_size 4096;            application live {                    live on;                    record on;                    }    }}#重新启动sudo /usr/local/nginx/sbin/nginx</code></pre></li><li><p>ffmpeg 推流</p><pre><code class="lang-bash">ffmpeg -re -i /home/test.mp4 -vcodec copy -acodec copy -b:v 800k -b:a 32k -f flv rtmp://localhost/live</code></pre></li><li><p>客户端拉流</p><p>使用vlc打开网络串流,输入流媒体服务器地址:rtmp://服务器IP:1935/live/ ,即可播放</p></li></ol><p><strong>nginx的删除</strong></p><pre><code class="lang-bash">$ sudo service nginx stop$ sudo apt-get --purge remove nginx$ sudo apt-get autoremove$ dpkg --get-selections|grep nginx#结果:nginx-common$ sudo apt-get --purge remove nginx-common</code></pre><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构(4) 树与二叉树</title>
    <link href="/2019/06/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(4)%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2019/06/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(4)%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>树的定义:树是$N(N\geqslant 0)$个结点的有限集合。特别的，当$N=0$时，称为空树。</p><p>任意非空树满足的条件：</p><ul><li>有且仅有一个特定的称为<strong>根</strong>的结点</li><li>当$N&gt;1$时，其余结点可分为$m$个互不相交的有限集合$T_1,T_2,\dots,T_m$,其中每个集合本身又是一棵树，并且称为根结点的子树</li></ul><p>树是一种递归的数据结构</p><ul><li>根结点无前驱结点，除根结点外的其余所有结点有且仅有一个前驱结点</li><li>树中所有结点可以有零个或多个后继结点</li></ul><p><strong>基本术语</strong></p><p><img src="\images\dataStructure\2.jpg" srcset="/img/loading.gif" alt=""></p><ol><li>结点$K$,结点$A,B,E$为到结点$K$的唯一路径上的结点，$A,B$为$K$的<strong>祖先结点</strong>，$K$为$A,B$的子孙结点；$E$为$K$的<strong>双亲结点</strong>，$K$为$E$的<strong>孩子结点</strong>，有相同双亲的结点为<strong>兄弟结点</strong>，如$K$和$L$互为兄弟节点；</li><li>树中一个子结点的个数称为该结点的度，树中结点的最大度数称为树的度；</li><li>度大于$0$的结点称为分支结点,如$B,C,D$,度为$0$的结点称为叶子结点，如$K,L,M$；</li><li>树的深度为树中结点的最大层数，如图的树形结构深度为4</li><li>两个结点之间的路径为两个结点之间所经过的结点序列，路径长度为路径上经过的边的个数，如$A$到$K$的路径长度为3；</li><li>森林是$m$课互不相交的树的集合；</li></ol><h1 id="二叉树概念"><a href="#二叉树概念" class="headerlink" title="二叉树概念"></a>二叉树概念</h1><p>定义:每个结点至多只有两颗子树的树形结构，即二叉树中不存在度大于2的结点，二叉树有左右之分，次序不可颠倒。</p><p><strong>二叉树的形态</strong>：</p><p><img src="\images\dataStructure\3.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>满二叉树：</strong>一颗高度为$h$，并且含有$2^h-1$个结点的二叉树</p><p>对于编号$i$结点，如果有双亲，其双亲为[$i/2$]，如果孩子结点，左孩子为$2i$,右孩子为$2i+1$</p><p><img src="\images\dataStructure\4.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>完全二叉树</strong>：设深度为$h$，有$n$个结点的二叉树，当且仅当其每一个结点都与深度为$h$的满二叉树中编号为$1\sim n$的结点<strong>一一对应</strong>，称为完全二叉树。</p><p>特点：</p><ol><li>若$i\leqslant[n/2] $,则结点$i$为分支节点，否则为叶子节点；</li><li>如果有度为1的结点，只可能有一个，且该结点只有左孩子无右孩子；</li></ol><p><strong>平衡二叉树</strong>：树上<strong>任一结点</strong>的左子树和右子树的深度差不超过1</p><p><strong>二叉树的性质：</strong></p><ol><li>非空二叉树上叶子结点数等于度为2的结点数加1，即$N_0=N_2+1$</li><li>非空二叉树上第$K$层至多有$2^{k-1}个结点(K\geqslant 1)$</li><li>深度为$h$的二叉树至多有$2^{h}-1$个结点</li><li>对于具有$1 \sim n$编号的完全二叉树，具有如下关系<ul><li>当$i&gt;1$时，结点$i$的双亲结点编号为$[i/2]$,当$i$为偶数时其为双亲结点的左孩子，当$i$为奇数时其为双亲结点的右孩子</li><li>当$2i\leqslant n $时，结点$i$的左孩子编号为$2i$，否则无左孩子</li><li>当$2i+1\leqslant n $时，结点$i$的左孩子编号为$2i +1$，否则无右孩子</li><li>结点$i$所在深度为$[\log _2{i}+1]$</li></ul></li><li>具有$n$个结点的完全二叉树的深度为$[\log _2{(n+1)}]$或$[\log _2{n}]+1$</li></ol><p><strong>二叉树的顺序存储</strong></p><p>将完全二叉树上编号为$i$的结点元素存储在某个数组下标为$i-1$的分量中。</p><p>对于一般的二叉树，使用0表示不存在的空结点，下标从1开始。</p><p><img src="\images\dataStructure\5.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>二叉树的链式存储</strong></p><pre><code class="lang-c++">typedef struct biTreeNode{    ElemType data;    struct biTreeNode *left,*right;//左右孩子指针}biTreeNode,*biTree;</code></pre><h1 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h1><ol><li><p>先序遍历</p><p>访问根结点$\rightarrow$先序遍历左子树$\rightarrow $先序遍历右子树</p><pre><code class="lang-c++">void preOrder(BiTree tree){    if(tree != null){        visit(tree);        preOrder(tree-&gt;left);        preOrder(tree-&gt;right);    }}</code></pre></li><li><p>中序遍历</p><p>中序遍历左子树$\rightarrow$访问根结点$\rightarrow $中序遍历右子树</p><pre><code class="lang-c++">void inOrder(BiTree tree){    if(tree != null){        inOrder(tree-&gt;left);        visit(tree);        inOrder(tree-&gt;right);    }}</code></pre></li><li><p>后序遍历</p><p>后序遍历左子树$\rightarrow$后序遍历右子树$\rightarrow $访问根结点</p><pre><code class="lang-c++">void postOrder(BiTree tree){    if(tree != null){        postOrder(tree-&gt;left);        postOrder(tree-&gt;right);        visit(tree);    }}</code></pre><p><img src="\images\dataStructure\6.jpg" srcset="/img/loading.gif" alt=""></p><ul><li>先序遍历：1 2 4 6 3 5 </li><li>中序遍历：2 6 4 1 3 5</li><li>后序遍历：6 4 2 5 3 1</li></ul></li><li><p>非递归遍历算法</p><pre><code class="lang-c++">//中序遍历非递归算法void inOrder*(BiTree tree){    initStack(stack);//初始化栈    BiTree p = tree;//遍历指针    while(p || !isEmpty(stack)){        if(p){            push(stack,p);            p = p-&gt;left;        }        else{            pop(stack,p);            visit(p);            p = p-&gt;right;        }    }}</code></pre></li><li><p>层次遍历</p><p>按图中箭头的顺序进行遍历，先访问第一层，再访问第二层,$\dots$</p><p><img src="\images\dataStructure\7.jpg" srcset="/img/loading.gif" alt=""></p><pre><code class="lang-c++">void levelOrder(BiTree tree){    initQueue(queue);    biTree p;    enQueue(queue,tree);//根节点入队    while(!isEmpty(queue)){        deQueue(queue,p);//队头元素出队        visit(p);        if(p-&gt;left != null)            enQueue(queue,p-&gt;left);        if(p-&gt;right != null)            enQueue(queue,p-&gt;right);    }}</code></pre></li><li><p>根据遍历序列构造二叉树</p><ul><li>二叉树的先序序列和中序序列可以唯一确定一颗二叉树。先序序列中，第一结点为根节点，在中序序列中，根结点将其分为两个子序列，根据该子序列在先序序列中找到对应的左子序列和右子序列，其先序序列中，左子序列第一个结点为左子树的根节点，右子序列的第一个结点为右子树的根结点，如此递归。</li><li>二叉树的后序序列和中序序列可以唯一确定一颗二叉树。后序序列的最后一个结点为根节点。</li><li>层次遍历序列和中序序列可以唯一确定一颗二叉树。</li></ul><p>求先序序列$ABCDEFGHI$和中序遍历$BCAEDGHFI$所确定的二叉树</p><p><img src="\images\dataStructure\8.jpg" srcset="/img/loading.gif" alt=""></p></li></ol><h1 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h1><p>二叉树线索化时通常规定，若无左子树，令leftChild指向其前驱结点，leftTag = 1；若无右子树，令right-child指向其后继结点,rightTag = 1。</p><p><strong>线索二叉树的存储结构</strong></p><pre><code class="lang-c++">typedef struct threadNode{    ElemType data;    struct threadNode *leftChild,rightChild;    int leftTag,rightTag;}</code></pre><p><strong>线索二叉树的构造</strong></p><pre><code class="lang-c++">//中序遍历-二叉树线索化//指针pre指向中序遍历时上一个刚刚访问过的结点void inThreadNode(threadNode &amp;p,threadNode &amp;pre){    if(p != null){        inThreadNode(p-&gt;leftChild,pre);//递归线索化左子树        if(p-&gt;leftChild == null){ //建立前驱线索            p-&gt;leftChild = pre;            p-&gt;leftTag = 1;        }        if(pre != null &amp;&amp; pre-&gt;rightCihld == null){//建立后继线索            pre-&gt;rightChild = p;            pre-&gt;rightTag = 1;        }        pre = p;        inthreadNode(p-&gt;rightChild,pre);//递归线索化右子树    }}void createInThreadNode(threadNode T){    threadNode pre = null;    if(T != null){        inThreadNode(T,pre);        pre-&gt;rightChild = null;//处理遍历的最后一个结点        pre-&gt;rightTag = 1;    }}</code></pre><p><img src="\images\dataStructure\9.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>线索二叉树的遍历</strong></p><ul><li><p>求中序线索二叉树中中序序列的第一个结点</p><pre><code class="lang-c++">threadNode * firstNode(threadNode *p){    while(p-&gt;leftTag == 0)        p = p-&gt;leftChild;    return p;}</code></pre></li><li><p>求中序线索二叉树中结点p在中序序列下的后继结点</p><pre><code class="lang-c++">threadNode * nextNode(threadNode *p){    if(p-&gt;rightTag == 0)        return firstNode(p-&gt;rightChild);    else return p-&gt;rightChild;}</code></pre></li><li><p>遍历算法</p><pre><code class="lang-c++">void * inThreadNode(threadNode *T){    for(threadNode *p = firstNode(T);p != NULL;p = nextNode(p))        visit(p);}</code></pre></li></ul><h1 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h1><ol><li><p>双亲表示法</p><pre><code class="lang-c++">#define MAX_TREE_SIZE 100typedef struct{    ElemType data;//数据    int parent;//双亲位置域}Node;typedef struct{    Node nodes[MAX_TREE_SIZE];    int n;//结点数}Tree;</code></pre><p><img src="\images\dataStructure\10.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>孩子表示法</p><p>将每个结点的孩子结点都用单链表链接起来形成一个线性结构</p><p><img src="\images\dataStructure\11.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>孩子兄弟表示法</p><p>以二叉链表作为树的存储结构，每个结点包括：结点值、指向结点第一个孩子的指针、指向结点下一个兄弟结点的指针</p><pre><code class="lang-c++">typedef struct Node{    ElemType data;//数据    struct Node *firstChild,*nextSibling;//第一个孩子和兄弟指针}Node,*Node;</code></pre><p><img src="\images\dataStructure\12.jpg" srcset="/img/loading.gif" alt=""></p></li></ol><p><strong>树、森林与二叉树的转换</strong></p><p>树转换为二叉树的规则：每个结点的左指针指向它的第一个孩子结点，右指针指向它在树中的相邻兄弟结点，由于根结点没有兄弟，因此由树转换而来的二叉树没有右子树。</p><p><img src="\images\dataStructure\13.jpg" srcset="/img/loading.gif" alt=""></p><h1 id="树与二叉树的应用"><a href="#树与二叉树的应用" class="headerlink" title="树与二叉树的应用"></a>树与二叉树的应用</h1><ol><li><p>并查集</p></li><li><p>二叉排序树</p><p><strong>定义</strong>：</p><ul><li>若左子树非空，则左子树上所有结点关键值均小于根节点的关键值</li><li>若右子树非空，则右子树上所有结点关键值均大于根节点的关键值</li><li>左右子树本身也为一颗二叉排序树</li></ul><p><img src="\images\dataStructure\14.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>二叉排序树的查找</strong></p><p>从根节点开始，若给定值与根结点关键值相等则查找成功；若根结点大于给定值则在左子树中查找；若根结点小于给定值则在右子树中查找</p><pre><code class="lang-c++">//查找函数返回指向关键值为key的结点指针pbiTreeNode * biTreeNodeSearch(biTree tree,ElemType key){    while(tree != NULL &amp;&amp; key != tree-&gt;data){        if(key &lt; tree-&gt;data)            tree = tree-&gt;leftChild;        else            tree = tree-&gt;rightChild;    }    return tree;}</code></pre><p><strong>二叉排序树的插入</strong></p><p>若原二叉树为空，则直接插入结点；若根结点大于给定值则插入到左子树中；若根结点小于给定值则插入到右子树中</p><pre><code class="lang-c++">![15](F:\jiaopaner\source\images\dataStructure\15.jpg)bool biTreeNodeInsert(biTree tree,ElemType key){    if(tree == null){        tree = (biTree)malloc(sizeof(biTreeNode));        tree-&gt;data = key;        tree-&gt;leftChild=  tree-rightChild = NULL;        return true;    }    else if(key == tree-&gt;data)        return false;    else if(key &lt; tree-&gt;data)        return biTreeNodeInsert(tree-&gt;lefgChild,key);    else if(key &gt; tree-&gt;data)        return biTreeNodeInsert(tree-&gt;rightChild,key);}</code></pre><p><strong>二叉排序树的删除</strong></p><ul><li><p>删除的结点为叶结点，则直接删除，不会破坏二叉树的排序性质</p></li><li><p>若删除结点$z$只有一颗左子树(或右子树)，则让$z$的左子树(或右子树)成为$z$结点的父结点的子树，即代替$z$的位置</p><p><img src="\images\dataStructure\15.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="\images\dataStructure\16.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>若删除结点$z$有左、右子树，则令$z$的右子树中中序第一个子女代替$z$，并转换相应的位置</p><p><img src="\images\dataStructure\17.jpg" srcset="/img/loading.gif" alt=""></p></li></ul></li><li><p>平衡二叉树</p><p>定义：任意结点的左右子树高度差不超过1的二叉排序树</p><p><strong>平衡二叉树的插入</strong></p><p>平衡二叉树插入新结点会破坏平衡性，因此插入新结点后需要做调整，以重新达到平衡性</p><p><img src="\images\dataStructure\18.jpg" srcset="/img/loading.gif" alt=""></p><p>平衡性调整策略</p><ul><li><p>LL平衡旋转(右单旋转)</p><p>在根结点$A$的左孩子(L)结点$B$的左子树(L)结点$BL$上插入了结点,破坏了平衡性的调整策略，$B$结点右上旋转代替$A$成为根结点，$A$结点成为$B$的右子树根结点，且$B$的右子树作为$A$结点的左子树</p><p><img src="\images\dataStructure\19.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>RR平衡旋转(左单旋转)</p><p>在根结点$A$的右孩子(R)结点$C$的右子树(R)结点$CR$上插入了结点,破坏了平衡性的调整策略，$C$结点左上旋转代替$A$成为根结点，$A$结点成为$C$的左子树根结点，且$C$的左子树作为$A$结点的右子树</p><p><img src="\images\dataStructure\20.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>LR平衡旋转(先左后右双旋转)</p><p>在根结点$A$的左孩子(L)结点$B$的右子树(R)结点$BR$上插入了结点,破坏了平衡性的调整策略</p><p><img src="\images\dataStructure\21.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>RL平衡旋转(先右后左双旋转)</p><p>在根结点$A$的右孩子(R)结点$C$的左子树(L)结点$CR$上插入了结点,破坏了平衡性的调整策略</p><p><img src="\images\dataStructure\22.jpg" srcset="/img/loading.gif" alt=""></p></li></ul></li><li><p><strong>哈夫曼树和哈夫曼编码</strong></p><p>树结点赋予权值，从根结点到任意结点的路径长度(经过的边数)与该结点权值的乘积称为该结点的带权路径长度，树中所有<strong>叶结点</strong>的带权路径长度之和称为该树的带权路径长度$WPL$。</p><script type="math/tex; mode=display">WPL=\sum_{i=1}^{n}w_i\times l_i</script><p>其中$w_i$为第$i$个叶结点的权值，$l_i$为根结点到第$i$个叶结点的路径长度</p><p>在含有$n$个带权叶子结点的二叉树中，其中$WPL$最小的二叉树称为哈夫曼树(最优二叉树)</p><p><img src="\images\dataStructure\23.jpg" srcset="/img/loading.gif" alt=""></p><p>$WPL(a)=7\times2+5\times2+2\times2+4\times2=36$</p><p>$WPL(b)=7\times3+5\times3+1\times2+4\times2=46$</p><p>$WPL(c)=7\times1+5\times2+2\times3+4\times3=35$</p><p>$c$树为哈夫曼树</p><p><strong>哈夫曼树的构造</strong></p><ul><li>将$n$个带权结点作为$n$课仅含一个结点的二叉树，构成森林$F$</li><li>构造一个新结点$P$，并从$F$中选取两棵权值最小的树作为新结点的左、右子树，将新结点的权值置为左、右子树权值之和</li><li>从$F$中删除上述选取的两棵树，同时将新结点$P$加入$F$中</li><li>重复2、3步骤，直至$F$中只剩下一棵树</li></ul><p><img src="\images\dataStructure\24.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>哈夫曼编码</strong></p><p>对频率高的字符赋予短编码，对频率低的字符赋予长编码，从而使字符平均编码长度减短</p><p>哈夫曼编码：对每个字符当作一个独立的结点，其权值为字符出现的次数，构造哈夫曼树</p><p><img src="\images\dataStructure\25.jpg" srcset="/img/loading.gif" alt=""></p></li></ol><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构(3) 栈和队列</title>
    <link href="/2019/06/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(3)%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <url>/2019/06/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(3)%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p><strong>栈</strong>：只允许在一端进行插入或删除操作的线性表。</p><p>栈顶：允许插入和删除的一端。栈底：固定的，不允许插入和删除的一端。</p><p>特性：先进后出。</p><h2 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h2><pre><code class="lang-c++">#define MaxSize 50typedef struct{    ElemType data[MaxSize];//存放栈中元素    int top;//栈顶指针 空栈 top=-1} Stack;#初始化void initStack(Stack &amp;s){    s.top = -1;}#判断栈空bool stackEmpty(Stack &amp;s){    if(s.top == -1)        return true;    else        return false;}#进栈bool push(Stack &amp;s,ElemType x){    if(s.top == MaxSize-1)        return false;    s.data[++s.top] = x;    return true;}#出栈bool pop(Stack &amp;s,ElemType &amp;x){    if(s.top == -1)        return false;    x = s.data[s.top--];    return true;}#读取栈顶元素bool getTop(Stack &amp;s,ElemType &amp;x){    if(s.top == -1)        return false;    x = s.data[s.top];    return true;}</code></pre><h2 id="栈的链式存储"><a href="#栈的链式存储" class="headerlink" title="栈的链式存储"></a>栈的链式存储</h2><pre><code class="lang-c++">typedef struct LinkNode{    ElemType data;    struct LinkNode *next;} *LinkStack;</code></pre><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p><strong>队列</strong>：只允许在表的一端进行插入，在表的另一端进行删除。</p><p>队头：允许删除的一端。队尾：允许插入的一端。</p><p>特性：先进先出</p><h2 id="队列的顺序存储结构"><a href="#队列的顺序存储结构" class="headerlink" title="队列的顺序存储结构"></a>队列的顺序存储结构</h2><pre><code class="lang-c++">#define MaxSize 50typedef struct{    ElemType data[MaxSize];//存放队列元素    int front,rear;//队头指针、队尾指针}Queue;</code></pre><p><strong>循环队列</strong></p><pre><code class="lang-c++">#初始化void InitQueue(Queue &amp;queue){    queue.rear = queue.front = 0;}#判断队列空bool isEmpty(Queue queue){    if(queue.rear == queue.front)        return true;    else        return false;}#入队bool enQueue(Queue &amp;queue,ElemType x){    if((queue.rear+1)%MaxSize == queue.front)        return false;//队列满    queue.data[queue.rear] = x;    queue.rear = (queue.rear+1) % MaxSize;    return true;}#出队bool deQueue(Queue &amp;queue,ElemType &amp;x){    if(queue.rear+1 == queue.front)        return false;//队列空    x = queue.data[queue.font];    queue.front = (queue.front+1) % MaxSize;    return true;}</code></pre><h2 id="队列的链式存储结构"><a href="#队列的链式存储结构" class="headerlink" title="队列的链式存储结构"></a>队列的链式存储结构</h2><pre><code class="lang-c++">typedef struct{    ElemType data;    struct LinkNode *next}LinkNode;typedef struct{    LinkNode *front,*rear;}LinkQueue;#初始化void InitQueue(LinkQueue &amp;queue){    queue.front = queue.rear=(LinkNode*)malloc(sizeof(LinkNode));    queue.front.next = null;}#判断队列空bool isEmpty(LinkQueue queue){    if(queue.front == queue.rear)        return true;    else        return false;}#入队void enQueue(LinkQueue &amp;queue,ElemType x){    s = (LinkNode *)malloc(sizeof(LinkNode));    s-&gt;data = x;    s-&gt;next = null;    queue.rear-&gt;next = s;    queue.rear = s;}#出队bool deQueue(LinkQueue &amp;queue,ElemType &amp;x){    if(queue.front == queue.rear)        return false;    p = queue.front-&gt;next;    x = p-&gt;data;    queue.front-&gt;next = p-&gt;next;    if(queue.rear == p)        queue.rear = queue.front;    free(p);    return true;}</code></pre><h1 id="栈和队列的应用"><a href="#栈和队列的应用" class="headerlink" title="栈和队列的应用"></a>栈和队列的应用</h1>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统(2) 进程管理</title>
    <link href="/2019/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(2)%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <url>/2019/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(2)%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h1><p>在多道程序环境下，允许多个程序并发执行，因此失去封闭性并具有间断性和不可再现性的特征，为此引入进程，更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性。</p><p><strong>进程控制块(PCB)</strong>：描述进程的基本情况和运行状态，进而控制和管理进程。</p><p>PCB是进程存在的唯一标志。创建进程实质是创建PCB，撤销进程实质是撤销PCB。</p><p><strong>进程映像</strong>：由程序段、相关数据段、PCB组成。</p><p><strong>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</strong></p><p><strong>特征</strong></p><ul><li>动态性：进程是程序的一次执行，具有生命周期。动态性是进程最基本的特征。</li><li>并发性、独立性、异步性、结构性</li></ul><p><strong>进程的状态与转换</strong></p><p><img src="\images\system\1.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>进程创建过程</strong></p><p>终端用户登录、作业调度、系统提供服务、用户程序的应用等请求都会引起进程的创建。</p><ol><li>为新进程分配唯一的进程标识号，申请空白的PCB；</li><li>为进程分配资源，分配进程的程序、数据和用户栈必要的内存空间；</li><li>初始化PCB，初始化标志信息、处理机状态信息、处理机控制信息、设置进程优先级；</li><li>将新进程插入到就绪队列等待调度；</li></ol><p><strong>进程终止过程</strong></p><p>正常结束、异常结束(存储区越界、保护错、非法指令、特权指令错、I/O故障)、外界干预等都会引起进程的终止。</p><ol><li>根据被终止进程标识符检索PCB，读取该进程的状态；</li><li>若被终止的进程处于执行状态则立即终止，将处理机资源分配给其他进程；</li><li>若有子进程，将其所有的子进程终止；</li><li>释放该进程的所有资源；</li><li>将PCB从所在队列中删除</li></ol><p>进程的创建、撤销以及要求系统设备完成的I/O操作都是利用系统调用而进入内核。</p><p><strong>进程的切换</strong></p><ol><li>保存处理机上下文，包括程序计数器和其他寄存器；</li><li>更新PCB信息；</li><li>进程的PCB移入相应的队列，如就绪、阻塞；</li><li>选择另一个进程，并更新其PCB；</li><li>更新内存管理的数据结构；</li><li>恢复处理机上下文；</li></ol><p><strong>进程的通信</strong></p><ul><li><p>共享存储</p><p>通过对共享空间进行读写操作实现进程间的信息交换</p></li><li><p>消息传递</p><p>进程间的数据交换以格式化的消息为单位</p></li><li><p>管道通信</p><p>消息传递的特殊方式，所谓管道是指连接一个读进程和一个写进程以实现进程之间通信的一个共享文件。</p><p>写进程以字符流的形式将大量的数据写入管道。</p></li></ul><p><strong>线程</strong></p><p>线程是基本的CPU执行单元，线程是进程中的一个实体，是被系统独立调度和分派的基本单位。线程不拥有系统资源，只拥有在运行中必不可少的资源，可与同属同一进程的其他线程共享进程所拥有的全部资源。同一进程中的多个线程可以并发执行。</p><p>在传统操作系统中，拥有资源和独立调度的基本单位都是进程，引入多线程的操作系统中，线程是独立调度的基本单位，进程是拥有资源的基本单位。</p><h1 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h1><p>处理及调度是对处理机进行分配，即从进程就绪队列中按照一定的算法选择进程并为其分配处理机，以实现进程并发执行。</p><p><strong>调度层次</strong></p><ul><li>作业调度：只调入/调出一次；</li><li>中级调度：内存调度，提高内存利用率和系统吞吐量，进程的挂起/就绪；</li><li>进程调度：按照某种算法调度进程执行； </li></ul><p>进程调度和切换程序是操作系统的内核程序。</p><p><strong>进程调度方式</strong></p><ul><li>非剥夺方式/非抢占方式：一旦将CPU分配给某个进程，只有当该进程执行完或转换到等待状态时才会进行进程的切换。实现简单、开销小，适用于大多数批处理系统，但不适用于实时和分时系统。</li><li>剥夺调度方式/抢占方式：若有某个更紧迫的进程需要调度，则立即暂定正在运行的进程，将处理机分配给更为紧迫的进程。剥夺原则：优先权、短进程优先、时间片原则。</li></ul><p><strong>调度的基本原则</strong></p><ol><li><p>CPU利用率</p></li><li><p>系统吞吐量：单位时间内CPU完成的作业数量；</p></li><li><p>周转时间：作业提交到作业完成的时间；</p><p>周转时间 = 作业完成时间 - 作业提交时间</p><p>带权周转时间 = $\frac{作业周转时间}{作业实际运行时间}$</p></li><li><p>等待时间</p></li><li><p>响应时间</p></li></ol><p><strong>调度算法</strong></p><ul><li><p>先来先服务(FCFS)调度算法：每次从就绪队列中选择最先进入该队列的进程进行执行，直到进程完成或因某种原因阻塞才释放处理机；算法简单、效率低，对长作业有利，利于CPU繁忙型作业、不利于I/O繁忙型作业。</p></li><li><p>短作业优先(SJF)调度算法：每次从就绪队列中选择一个估计运行时间最短的进程进行执行。对长作业不利、未考虑作业紧迫度，平均等待时间、平均周转时间最少。</p></li><li><p>优先级调度算法：每次从就绪队列中选择优先级最高的进程进行执行。</p></li><li><p>高响应比优先调度算法：同时考虑每个进程的等待时间和估计的运行时间，在进行进程调度前先计算就绪队列中每个进程的响应比，选择响应比最高的进程进行执行。</p><p>响应比$R_p=\frac{等待时间+要求服务的时间}{要求服务的时间}$</p></li><li><p>时间片轮转调度算法：总是选择就绪队列中第一个进程进行执行(先来先服务)，但仅能运行一个时间片，时间片用完即使进程并未完成运行，也必须释放处理机给下一个就绪进程。被剥夺的进程则重新排队，等待调度。</p></li><li><p>多级反馈队列调度算法：</p><ol><li>设置多个队列，赋予每个队列不同的优先级，第1级队列优先级最高，依次降低;</li><li>赋予每个队列不同的进程执行时间片，第1级队列时间片最短，依次递增；</li><li>新进程首先进入第1级队列末尾排队，按照先来先服务调度算法等待调度，若该进程能在第1级的时间片内完成，则撤离系统，否则转入下一级队列末尾排队，依次类推。</li><li>仅当第1级队列为空时才调度第2级队列的进程执行，依次类推。若处理正在执行第$i$级队列中的进程，当新进程进入优先级较高的$i-1$级别队列时，则新进程抢占处理机，当前第$i$级进程转入第$i$级末尾重新排队。</li></ol></li></ul><h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><p>协调进程之间互相制约的关系。</p><ol><li>临界资源：一次仅允许一个进程使用的资源称为临界资源。对临界资源的访问必须互斥进行。</li><li>同步：需要在某些位置上协调进程之间的<strong>工作次序</strong>而等待、传递信息所产生的制约关系。</li><li><p>互斥：当一个进程使用临界资源时，其他要求进入临界区的进程必须等待。</p><p><strong>准则</strong>：</p></li></ol><ul><li>空闲让进：临界区空闲时，允许一个请求进入临界区的进程立即进入临界区</li><li>忙则等待：当已有进程进入临界区，其他试图进入临界区的进程必须等待<ul><li>有限等待：对访问请求的进程，应保证在有限时间内进入临界区</li></ul></li><li>让权等待：当进程不能进入临界区时，应立即释放处理器，防止进程忙等待</li></ul><p><strong>互斥的基本方法</strong></p><p>1.软件实现方法</p><p><strong>单标志法</strong></p><p>设置公用整型变量turn,用于指示被允许进入临界区的进程编号，进程必须交替进入临界区，否则违背空闲让进</p><pre><code class="lang-c++">//P0进程while(turn!=0); //等待critical section;//临界区turn = 1;remainder section;//P1进程while(turn!=1); //等待critical section;//临界区turn = 0;remainder section;</code></pre><p><strong>双标志法</strong></p><p>设置$flag[k]$,进入临界区前先检查进程$P_k$是否进入临界区,进程之间不需要交替进入，缺点为进程$p_i和p_j$可能同时进入临界区，违背忙等待</p><pre><code class="lang-c++">//Pi进程while(flag[j] == true); //等待flag[i] = true;critical section;//临界区flag[i] = false;remainder section;//Pj进程while(flag[i] == true); //等待flag[j] = true;critical section;//临界区flag[j] = false;remainder section;</code></pre><p>设置$flag[k]$,进入临界区前先设置本身进程标志为true,再检查进程$P_k$是否进入临界区,缺点是由于进程互相“谦让”容易形成饥饿现象，即进程都无法进入临界区</p><pre><code class="lang-c++">//Pi进程flag[i] = true;while(flag[j] == true); //等待critical section;//临界区flag[i] = false;remainder section;//Pj进程flag[j] = true;while(flag[i] == true); //等待critical section;//临界区flag[j] = false;remainder section;</code></pre><p><strong>Peterson 算法</strong></p><p>进入临界区前先设置本身进程标志为true,再设置turn标志，最后检查进程$P_k$是否进入临界区</p><pre><code class="lang-c++">//Pi进程flag[i] = true;turn = j;while(flag[j] == true &amp;&amp; turn == j); //等待critical section;//临界区flag[i] = false;remainder section;//Pj进程flag[j] = true;turn = i;while(flag[i] == true &amp;&amp; turn == i); //等待critical section;//临界区flag[j] = false;remainder section;</code></pre><p>2.硬件实现方法</p><p><strong>中断屏蔽</strong></p><p>CPU只在发生中断时引起进程切换，屏蔽中断能够保证当前运行的进程将临界区的代码顺利执行完毕</p><p><strong>硬件指令</strong></p><p>TestAndSet指令(原子操作)，为每个临界资源设置共享布尔变量lock,true表示资源正被占用</p><pre><code class="lang-c++">bool TestAndSet(bool *lock){    bool old;    old = *lock;    *lock = true;    return old;}//进程while(TestAndSet(&amp;lock)) //等待critical section;//临界区lock = false;remainder section;</code></pre><p><strong>Swap指令</strong></p><pre><code class="lang-c++">Swap(bool *x,bool *y){    bool temp;    temp = *x;    *x = *y;    *y = temp;}//进程key = true;//为每个进程设置局部布尔变量while(key != false) //等待    Swap(*lock,&amp;key)critical section;//临界区lock = false;remainder section;</code></pre><p><strong>信号量</strong></p><p>1.整型信号量：定义为表示资源数目的整型量$S$</p><pre><code class="lang-c++">//申请资源wait(S){    while(S &lt;= 0);    S = S-1;}//释放资源signal(S){    S = S+1;}</code></pre><p>2.记录型信号量：定义为表示资源数目的整型量$value$和进程链表$L$(用于链接等待该资源的进程)</p><pre><code class="lang-c++">typedef struct{    int value;    struct process *L;}semaphore;//申请资源void wait(semaphore S){    S.value--;    if(S.value &lt; 0){        add this process to S.L;        block(S.L);//进程阻塞，放弃处理机    }}//释放资源void signal(semaphore S){    S.value++;    if(S.value &lt;= 0){//仍有进程等待        remove a process P from S.L;        wakeup(P);//唤醒进程    }}</code></pre><p>利用信号量实现进程同步</p><pre><code class="lang-c++">//进程Py中的y语句需要使用进程Px中x语句的运行结果semaphore S = 0；Px(){    ...    x；    singal(S);//通知进程Py,语句x已完成    ...}Py(){    ...    wait(S);//检查语句x是否已完成    y；    ...}</code></pre><p>利用信号量实现进程互斥</p><pre><code class="lang-c++">semaphore S = 1;//初始化信号量 资源数量Px(){    ...    wait(S);//访问资源，加锁    x；//临界区    singal(S);//访问结束，解锁    ...}Py(){    ...    wait(S);//访问资源，加锁    y；//临界区    singal(S);//访问结束，解锁    ...}</code></pre><p>利用信号量实现前驱关系</p><p><img src="\images\system\2.jpg" srcset="/img/loading.gif" alt=""></p><p>$a:S1 \rightarrow S2,b:S1\rightarrow S3;c:S2 \rightarrow S4,d:S2\rightarrow S5;$</p><p>$e:S3 \rightarrow S6,f:S4\rightarrow S6,g:S5 \rightarrow S6$</p><pre><code class="lang-c++">semaphore a=b=c=d=e=f=g=0;//S1(){    ...    singal(a);singal(b);//S1完成}S2(){    ...    wait(a);    ...    singal(c);singal(d);//S2完成}S3(){    ...    wait(b);    ...    singal(e);//S3完成}S4(){    ...    wait(c);    ...    singal(f);//S4完成}S5(){    ...    wait(d);    ...    singal(g);//S5完成}S6(){    wait(e);    wait(f);    wait(g);    ...}</code></pre><p><strong>经典同步问题</strong></p><ol><li><p>生产消费者问题</p><pre><code class="lang-c++">semaphore mutex = 1;//临界区互斥信号量semaphore empty = n;//空闲缓冲区数semaphore full = 0;//满缓冲区数//生产者进程producer(){    while(true){        produce an item in nextp;        wait(empty);//获取空缓冲区单元        wait(mutex);//进入临界区        add nextp ti buffer;//将数据放入缓冲区        singal(mutex);        singal(full);    }}//消费者进程consumer(){    while(true){        wait(full);        wait(mutex);        remove an item from buffer;        singal(mutex);        singal(empty);        consume the item;    }}//empty和full的wait操作必须在mutex前</code></pre></li></ol><ol><li><p>读者-写者问题</p><ul><li>允许多个读者同时对共享文件进行读操作</li><li>只允许一个写者向共享文件写数据</li><li>写者完成写操作之前不允许其他读者进行读操作</li><li>写者执行写操作之前，应让已有读者和写者全部退出</li></ul><pre><code class="lang-c++">//读进程优先int count = 0;//当前读者数量semaphore mutex = 1;//用于更新count时的互斥semaphore rw = 1;//互斥访问共享文件//写者进程writer(){    while(true){        wait(rw);        writing;        signal(rw);    }}//读者进程reader(){    while(true){        wait(mutex);        if(count == 0)//第一个读者读取时            wait(rw);//阻止写进程写操作        count++;        signal(mutex);        reading;        wait(mutex);//读取完毕        count--;        if(count == 0)//当最后一个读进程读取完毕            signal(rw)        signal(mutex);    }}</code></pre><pre><code class="lang-c++">//写进程优先int count = 0;//当前读者数量semaphore mutex = 1;//用于更新count时的互斥semaphore rw = 1;//互斥访问共享文件semaphore w = 1;//用于实现写优先//写者进程writer(){    while(true){        wait(w)        wait(rw);        writing;        signal(rw);        signal(w);    }}//读者进程reader(){    while(true){        wait(w);//无写进程时进入        wait(mutex);        if(count == 0)//第一个读者读取时            wait(rw);//阻止写进程写操作        count++;        signal(mutex);        signal(w);        reading;        wait(mutex);//读取完毕        count--;        if(count == 0)//当最后一个读进程读取完毕            signal(rw)        signal(mutex);    }}</code></pre></li></ol><ol><li><p>哲学家进餐问题</p><pre><code class="lang-c++">semaphore chopstick[5]={1,1,1,1,1};//五根筷子semaphore mutex =  1;//设置取筷子的信号量//i号哲学家进程Pi(){    do{        wait(mutex);        wait(chopstick[i]);//取左边筷子        wait(chopstick[(i+1]%5);//取右边筷子        signal(mutex);        eat;        signal(chopstick[i]);        signal(chopstick[(i+1]%5);        think;    }}</code></pre></li></ol><ol><li><p>吸烟者问题w</p><pre><code class="lang-c++">int random;semaphore offerTobaccoAndPaper;//烟草和纸semaphore offerTobaccoAndGlue;//烟草和胶水semaphore offerPaperAndGlue;//纸和胶水semaphore finish = 0;//记录抽烟完成//供应者进程provider(){    while(true){        random = rand.random(3);//1-3的整数随机数        if(random == 1){            signal(offerTobaccoAndPaper);//提供烟草和纸        }        else if(random == 1){            signal(offerTobaccoAndGlue);//提供烟草和胶水        }        else{            signal(offerPaperAndGlue);//提供纸和胶水        }        wait(finish);    }}//拥有烟草者进程process(){    while(true){        wait(offerPaperAndGlue);        ...        signal(finish);    }}//拥有纸者进程process(){    while(true){        wait(offerTobaccoAndGlue);        ...        signal(finish);    }}//拥有胶水者进程process(){    while(true){        wait(offerTobaccoAndPaper);        ...        signal(finish);    }}</code></pre></li></ol><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>定义：多个进程因竞争不可剥夺资源而造成的互相等待，若无外力作用，进程都将无法向前推进。</p><p>产生死锁的必要条件(同时满足)</p><ul><li>互斥条件：某资源仅由一个进程占有</li><li>不剥夺条件：进程所获得资源在未使用完毕前，不可直接剥夺</li><li>请求和保持条件：进程已获得资源A，同时提出对资源B的请求，单资源B被其他进程占有，此失请求进程被阻塞，但对其资源A保持不放</li><li>循环等待条件：$p<em>i$等待的资源被$p</em>{i+1}$占有,$\dots$,$p_n$等待的资源被$p_0$占有</li></ul><p>死锁处理策略</p><ol><li>预防死锁：设置限制条件，破环产生死锁的必要条件</li><li>避免死锁：资源动态分配中，用某种方法防止系统进入不安全状态</li><li>死锁检测及解除：允许死锁发生，通过系统检测及时地解除死锁</li></ol><p><strong>银行家算法</strong></p><p>可利用资源矢量Available：每类资源可用的数目</p><p>最大需求矩阵Max：每个进程对每类资源的最大需求</p><p>分配矩阵Allocation：每个进程已分配到每类资源数目</p><p>需求矩阵Need：每个进程尚需的每类资源数目 $Need = Max - Allocation$</p><p>假设系统中有5个进程$p_0,p_1,p_2,p_3,p_4$和三类资源${A,B,C}$,各类资源数目分别为$10、5、7$,在$t_0$时刻资源分配情况如下表，求资源分配安全序列。</p><p><img src="\images\system\3.jpg" srcset="/img/loading.gif" alt=""></p><ol><li><p>求出Need矩阵</p><script type="math/tex; mode=display">\begin{bmatrix}7 & 5 & 3\\ 3 & 2 & 2\\ 9 & 0 & 2\\ 2 & 2 & 2\\ 4 & 3 & 3\end{bmatrix}(MAX)-\begin{bmatrix}0 & 1 & 0\\ 2 & 0 & 0\\ 3 & 0 & 2\\ 2 & 1 & 1\\ 0 & 0 & 2\end{bmatrix}(Allocation)=\begin{bmatrix}7 & 4 & 3\\ 1 & 2 & 2\\ 6 & 0 & 0\\ 0 & 1 & 1\\ 4 & 3 & 1\end{bmatrix}(Need)</script></li><li><p>Available向量与Need矩阵各行进行比较，找出比Available向量小的行，如$$</p><script type="math/tex; mode=display">p_1(1,2,2)<(3,2,2)\\p_3(0,1,1)<(3,2,2)</script><p>选择$p_1$(或$p_3$)加入安全序列</p></li><li><p>释放$p_1$所占有的资源，即把$p_1$的Allocation与Available向量相加,等到新的Available向量</p><script type="math/tex; mode=display">(2,0,0)+(3,3,2)=(5,3,2)=Available(new)</script></li><li><p>再用更新后的Available向量和Need向量矩阵重复步骤2</p></li></ol><p>安全序列：$[p_1,p_3,p_4,p_2,p_0]$</p><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统(1) 概述</title>
    <link href="/2019/06/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1)%20%E6%A6%82%E8%BF%B0/"/>
    <url>/2019/06/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1)%20%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>操作系统是指控制和管理整个计算机系统的硬件和软件资源，并合理的组织调度计算机的工作和资源分配，以提供给用户和其他软件方便的接口和环境的程序集合。</p><h1 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h1><p><strong>并发</strong>：两个或多个事件在同一时间间隔内发生。</p><p><strong>共享</strong></p><ul><li>互斥共享：一段时间内只允许一个进程访问资源，其余进程必须等待；</li><li>同时访问：进程交替的对资源进行访问，即分时共享；</li></ul><p><strong>虚拟</strong>：物理上的若干个实体变为若干个逻辑上的对应物，如虚拟内存、虚拟处理器等。</p><p>虚拟技术：时分复用技术，如处理器的分时共享；空分复用技术，如虚拟存储器。</p><p><strong>异步</strong>：为允许多个程序并发执行，进程的执行并非一贯到底，而是走走停停，以不可预知的速度向前推进。</p><h1 id="目标和功能"><a href="#目标和功能" class="headerlink" title="目标和功能"></a>目标和功能</h1><p><strong>作为计算机系统的管理者</strong>:处理及管理、存储器管理、文件管理、设备管理。</p><p><strong>作为用户与计算机硬件件的接口</strong>：命令接口(联机命令接口、脱机命令接口)、程序接口(系统调用、广义指令)。</p><h1 id="操作系统发展分类"><a href="#操作系统发展分类" class="headerlink" title="操作系统发展分类"></a>操作系统发展分类</h1><ol><li><strong>手工操作阶段</strong>：用户独占全机、CPU等待手工操作</li><li><strong>批处理阶段</strong><ul><li>单道批处理系统：系统对作业的处理成批处理,内存中始终保留一道作业；</li><li>多道批处理系统：允许多个程序同时进入内存并在CPU上交替运行，由作业调度程序自动选择作业运行；</li><li>分时操作系统：共享主机、人机交互</li><li>实时操作系统：及时性和可靠性</li><li>网络操作系统和分布式操作系统</li><li>个人操作系统</li></ul></li></ol><h1 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h1><p>操作系统内核工作在核心态，用户程序工作在用户态，从用户态转为核心态的唯一途径是中断或异常。</p><p>访管指令在用户态执行，产生中断事件，转为核心态，但其不是特权指令，特权指令在和心态执行。</p><p><strong>时钟管理</strong>：实现进程的切换。</p><p><strong>中断机制</strong>：进程管理和调度、系统功能调用、设备驱动、文件访问。</p><ul><li>外中断：外设请求、人为干预</li><li>内中断(异常)：指令中断、硬件故障、软件中断</li></ul><p><strong>原语</strong>：底层公用小程序，处于操作系统最底层、程序的运行具有原子性、运行时间短。</p><p><strong>系统控制的数据结构和处理</strong>：作业控制块、进程控制块、设备控制块、链表、消息队列、缓冲区、内存分配表等。</p><p>系统调用需出发trap命令,进入中断处理的程序在核心态执行，属于操作系统程序。</p><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构(2) 线性表</title>
    <link href="/2019/05/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(2)%20%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2019/05/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(2)%20%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h3><p>线性表是具有相同数据类型的$n$个数据元素的有限序列<br>除第一个元素,每个元素有且仅有一个直接前驱,除最后一个元素,每个元素有且仅有一个后继 </p><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>线性表的顺序存储称为顺序表,用一组地址连续的存储单元依次存储线性表中的数据元素，因此逻辑上相邻的两个元素在物理位置上也相邻</p><p><strong>顺序表描述</strong></p><pre><code class="lang-cpp">#define MaxSize 50typedef struct {    ElemType data[MaxSize];//顺序表元素 静态分配    int length;//当前长度}SqList;#define InitSize 100typedef struct {    ElemType *data;//顺序表元素 动态分配数组的指针    int MaxSize,length;//数组最大容量和当前元素个数}SqList;L.data = (ElemType *)malloc(sizeof(ElemType) * InitSize);//cL.data = new ElemType(InitSize);//C++</code></pre><p>顺序表最主要的特点是随机访问,通过首地址和元素序号可在O(1)的时间复杂度内找到指定的元素</p><p><strong>插入操作</strong><br>在顺序表L的第i个位置插入新元素e</p><pre><code class="lang-cpp">bool ListInsert(SqList &amp;L, int i, ElemType e) {    if (i &lt; 1 || i &gt; L.length+1)        return false;    if (L.length &gt; = MaxSize)        return false;    for (int index = L.length; index &gt;= i; index--)        L.data[index] = L.data[index - 1];    L.data[i-1] = e;    L.length++;    return true;}</code></pre><p><strong>删除操作</strong><br>删除顺序表L中第i个位置的元素,删除的元素用引用变量e返回</p><pre><code class="lang-cpp">bool ListDelete(SqList &amp;L, int i, ElemType &amp;e) {    if (i &lt; 1 || i &gt; L.length)        return false;    e = L.data[i - 1];    for (int index = i; index &lt; L.length; index++)        L.data[index-1] = L.data[index];    L.length--;    return true;}</code></pre><p><strong>按值查找</strong><br>在顺序表L中查找一个元素值等于e的元素,并返回其位置(非索引)</p><pre><code class="lang-cpp">int ListDelete(SqList L,ElemType e) {    int index;    for (index = 0; index &lt; L.length; index++)        if (L.data[index] == e)            return index + 1;    return 0;}</code></pre><p>1.长度为$n$的顺序表$L$,编写一个时间复杂度为<script type="math/tex">O(n)</script>、空间复杂度为<script type="math/tex">O(1)</script>的算法，该算法删除线性表中所以值为x的数据元素。</p><pre><code class="lang-c++">void delX(Sqlist &amp;L,ElemType x){    int k = 0 ;    for(int i = 0;i &lt; L.length;i++){        if(L[i] != x){            L.data[k] = L.data[i];            k++;        }    }    L.length = k;}</code></pre><p>2.从有序顺序表中删除所有其值重复的元素，使表中所有的值均不相同。</p><pre><code class="lang-c++">bool delSame(Sqlist &amp;L){    if(L.length = 0)        return false;    int i,j;    for(i = 0,j = 1;j &lt; L.length;j++){        if(L.data[i] != L.data[j])            L.data[++i] = L.data[j];    }    L.length = i;    return true;}</code></pre><p>3.将两个有序顺序表合并成一个新的有序顺序表，并由函数返回其结果顺序表。</p><pre><code class="lang-c++">bool merge(Sqlist A,Sqlist B,Sqlist &amp;C){    if(A.length + B.length &gt; C.maxSize)        return false;    int i = 0,j = 0,k = 0;    while(i &lt; A.length &amp;&amp; j &lt; B.length){        if(A.data[i] &lt;= B.data[j])            C.data[k++] = A.data[i++];        else            C.data[k++] = B.data[j++]    }    while(i &lt; A.length){        C.data[k++] = A.data[i++];    }    while(j &gt; B.length){        C.data[k++] = B.data[j++];    }    C.length = k+1;    return true;}</code></pre><p>4.线性表<script type="math/tex">(a_1,a_2,...,a_n)</script>中的元素递增有序存储于计算机内，设计算法完成在最短的时间内在表中查找数值为x的元素，若存在则将其与后继元素交换，否则插入表中并使表中元素仍然递增有序。</p><pre><code class="lang-c++">void searchExchangeInsert(Sqlist &amp;L,ElemType x){    int low = 0,high = n -1,mid;    while(low &lt;= high){        mid = (low + high) / 2;        if(L.data[mid] == x)            break;        else if(L.data[mid] &lt; x)            low = mid + 1;        else            high = mid - 1;    }    if(L.data[mid] == x &amp;&amp; mid != (n-1)){        ElemType temp = L.data[mid];        L.data[mid] = L.data[mid+1];        L.[mid+1] = temp;    }    if(low &gt; high){        for(int i = n- 1;i &gt; high;i--)            L.data[i+1] = L.data[i];        L.data[i+1] = x;    }}</code></pre><p>5.设将<script type="math/tex">n(n>1)</script>个整数存放到一维数组R中。设计一个高效的算法将R中保存的序列循环左移<script type="math/tex">p(0<p<n)</script>个位置，即将R中的数据由<script type="math/tex">(x_0,x_1,...,x_{n-1})</script>变换为<script type="math/tex">(x_p,x_{p+1},...,x_{n-1},x_0,x_1,...,x_{p-1})</script></p><p>算法思想:</p><p>令<script type="math/tex">A=(x_0,x_1,...,x_{p-1}),B=(x_p,x_{p+1},...,x_{n-1}),C=BA</script>,<script type="math/tex">A^{-1}=(x_{p-1},x_{p-2},...,x_1,x_0)</script></p><script type="math/tex; mode=display">AB \rightarrow A^{-1}B\rightarrow A^{-1}B^{-1}\rightarrow (A^{-1}B^{-1})^{-1}\rightarrow BA</script><pre><code class="lang-c++">void Reverse(int R[],int from,int to){    for(int i = 0; i &lt; (to-from+1)/2;i++){        int temp = R[from+i];        R[from+i] = R[to-i];        R[to-i] = temp;    }}void Converse(int R[],int n,int p){    Reverse(R,0,p-1);    Reverse(R,p,n-1);    Reverse(R,0,n-1);}</code></pre><p>6.长度为L的升序序列S，处在第[L/2]个位置的输称为S的中位数，两个序列的中位数是含它们所有元素升序序列的中位数，现有两个等长的升序序列A和B，设计算法找出序列A和序列B的中位数。</p><p>算法思想：</p><p>设<script type="math/tex">a</script>为A的中位数，<script type="math/tex">b</script>为B的中位数</p><ol><li>若<script type="math/tex">a=b</script>，则<script type="math/tex">a</script>或<script type="math/tex">b</script>即为所求中位数；</li><li>若<script type="math/tex">a<b</script>，舍弃序列A中较小的一半，同时舍弃序列B中较大的一半，两次舍弃的长度相等；</li><li>若<script type="math/tex">a>b</script>，舍弃序列A中较大的一半，同时舍弃序列B中较小的一半，两次舍弃的长度相等；</li><li>在保留的两个升序序列中,重复1，2，3,直到两个序列只含有一个元素为止，较小者为所求中位数；</li></ol><pre><code class="lang-c++">int mediSearch(int A[],int B[],int n){    int sa=0,da=n-1,ma;    int sb=0,db=n-1,mb;    while(sa != da || sb != db){        ma = (sa+da)/2;        mb = (sb+db)/2;        if(A[ma] == B[mb]){            return A[ma];        }        if(A[ma] &lt; B[mb]){            if((sa+da)%2 == 0){//元素个数为奇数                sa = ma;                db = mb;            }            else{                sa = ma + 1;                db = mb;            }        }        else{            if((sb+db)%2 == 0){//元素个数为奇数                da = ma;                sb = mb;            }            else{                da = ma;                sb = mb + 1;            }        }    }    return A[sa] &lt; B[sb]?A[sa]:B[sb];}</code></pre><p>7.已知一个整数序列<script type="math/tex">A=(a_0,a_1,...a_{n-1})</script>，其中<script type="math/tex">0\leqslant a_{i}\leqslant n</script>,若存在<script type="math/tex">a_{p1}=a_{p2}=...a_{pm}=x</script>,且<script type="math/tex">m>n/2</script>,则称<script type="math/tex">x</script>为A的主元素。例如<script type="math/tex">A=(0,5,5,3,5,7,5,5)</script>，5为A的主元素，<script type="math/tex">B=(0,5,5,3,5,1,5,7)</script>,则B中没有主元素。设计算法找出A的主元素并输出，否则输出-1；</p><pre><code class="lang-c++">int majority(int A[],int n){    int i,c,count = 1;//c保存候选主元素    c = A[0];    for(i = 1;i &lt; n;i++){        if(A[i] == c)            count++;        else{            if(count &gt; 0)                count--;            else{                c = A[i];                count = 1 ;            }        }    }    if(count &gt; 0)        for(i = count = 0;i &lt; n; i++){//统计候选主元素实际出现的次数            if(A[i] == c)                count++;        }    if(count &gt; (n/2))        return c；    else        return -1;}</code></pre><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>由于顺序表的插入、删除操作需要移动大量元素,影响运行效率,由此引入线性表的链式存储,链式存储不需要使用地址连续的存储单元,即逻辑上相邻的元素不要求在物理位置上也相邻</p><p><strong>单链表</strong></p><p>通过一组任意的存储单元来存储线性表中的数据元素,每个链表节点除了存放元素本身,还需要存放指向后继的指针,其是非随机存取结构</p><pre><code class="lang-cpp">typedef struct Node{    ElemType data; //XX    struct Node *next;//指针域}Node,*LinkList;</code></pre><p>通常用头指针来标识一个单链表,在单链表第一个节点前附加一个节点称为头节点,头节点的数据域不设任何信息<br><img src="/images/dataStructure/1.jpg" srcset="/img/loading.gif" alt=""><br>头指针和头节点：<br>1.不管带不带头节点,头指针始终指向链表的第一个节点<br>2.引入头节点,统一操作,统一空表和非空表的处理</p><p><strong>采用头插法建立单链表</strong></p><pre><code class="lang-cpp">LinkList createList(LinkList &amp;L){    Node *node;    int x;    L = (LinkList)malloc(sizeof(Node));    L-&gt;next = null;    scanf(&quot;%d&quot;,&amp;x);    while(x != 10){        node = (Node*)malloc(sizeof(Node));        node-&gt;data = x;        node-&gt;next = L-&gt;next;        L-&gt;next = node;        scanf(&quot;%d&quot;,x);    }    return L;}</code></pre><p><strong>采用尾插法建立单链表</strong></p><pre><code class="lang-cpp">LinkList createList(LinkList &amp;L){    int x;    L = (LinkList)malloc(sizeof(Node));    Node *node,*tail = L;    scanf(&quot;%d&quot;,&amp;x);    while(x != 10){        node = (Node*)malloc(sizeof(Node));        node-&gt;data = x;        tail-&gt;next = node;        tail = node;        scanf(&quot;%d&quot;,x);    }    tail-&gt;next = null;    return L;}</code></pre><p><strong>按序号查找节点值</strong></p><pre><code class="lang-cpp">Node* getElem(LinkList L，int i){    int j=1;    Node *p= L-&gt;next;//头节点    if(i == 0)        return L;    if(i &lt; 1)        return null;    while(p &amp;&amp; j &lt; i){ //从第一个节点开始查找        p = p-&gt;next;        j++    }    return p;}</code></pre><p><strong>按值查找表节点</strong></p><pre><code class="lang-cpp">Node* getElem(LinkList L，ElemType  e){    Node *p= L-&gt;next;//头节点    while(p &amp;&amp; p-&gt;data != e){ //从第一个节点开始查找        p = p-&gt;next;    }    return p;}</code></pre><p><strong>插入节点操作</strong></p><pre><code class="lang-cpp">p = getElem(L,i-1);//查找插入位置i的前驱节点s-&gt;next = p-&gt;next;p-&gt;next = s;</code></pre><p><strong>删除节点操作</strong></p><pre><code class="lang-cpp">p = getElem(L,i-1);//查找删除位置i的前驱节点q = p-next;p-&gt;next = q-&gt;next;free(q);</code></pre><p><strong>双链表</strong></p><p>双链表通过prior和next，分别指向前驱节点和后继节点<br>双链表的按值查找和按位查找操作和单链表相同</p><pre><code class="lang-cpp">typedef struct Node{    ElemType data;    struct Node *prior;    struct Node *next;}Node,*DoubleList;</code></pre><p><strong>插入节点操作</strong></p><pre><code class="lang-cpp">p = getElem(L,i-1);//查找插入位置i的前驱节点s-&gt;next = p-&gt;next;p-&gt;next-prior = s;s-&gt;prior = p;p-&gt;next = s;</code></pre><p><strong>删除节点操作</strong></p><pre><code class="lang-cpp">p = getElem(L,i-1);//查找删除位置i的前驱节点q = p-next;p-&gt;next = q-&gt;next;p-&gt;next-&gt;prior = p;free(q);</code></pre><h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>静态链表是由数组来描述线性表的链式存储结构,节点也有数据域data和指针域next</p><pre><code class="lang-cpp">#define MaxSize 50typedef struct{    ElemType data;    int next ;//下一个元素的数组下标}StaticLinkList[MaxSize];</code></pre><ol><li><p>在带头结点的单链表L中，删除所有值为x的结点，并释放其空间。</p><pre><code class="lang-c++">void deleteX(LinkList &amp;L){    Node *p = L-&gt;next,*pre = L;*q;//pre为p的前驱结点    while(p != null){        if(p-&gt;data == x){            q = p;            p = p-&gt;next;            pre-&gt;next = p;            free(q);        }        else{            pre = p;            p = p-&gt;next;        }    }}</code></pre></li><li><p>设L为带头结点的单链表，编写算法实现从尾到头反向输出每个结点的值。</p><pre><code class="lang-c++">//递归方法void reversePrint(LinkList &amp;L){    if(L-&gt;next != nulll){        reversePrint(L-next);    }    printf(L-&gt;data)}//借助栈</code></pre></li><li><p>编写在带头结点的单链表L中删除最小值结点的高效算法，假设最小值唯一。</p><pre><code class="lang-c++">LinkList deleteMinNode(LinkList &amp;L){    Node *p = L-&gt;next,*pre = L;// pre为p的前驱结点    Node *minPre = pre,*min = p;//最小值的前驱和当前最小值    while(p!= null){        if(p-&gt;data &lt; min-&gt;data){            min = p;            minPre = pre;        }        pre = p;        p = p-&gt;next;    }    minPre-&gt;next = min-&gt;next;    free(min);    return L;}</code></pre></li><li><p>试编写算法将带头结点的链表逆置，且空间复杂度为$O(1)$</p><pre><code class="lang-c++">LinkList reverse(LinkList L){    Node *p,*r;//p为工作指针，r为后继指针    p = L-&gt;next;    L-&gt;next = NULL;    while(p != NULL){        r = p-&gt;next;        p-&gt;next = L-&gt;next;        L-&gt;next = p;        p = r;    }}</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构(1) 基本概念</title>
    <link href="/2019/05/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(1)%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2019/05/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(1)%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p><strong>数据</strong></p><p>数据是信息的载体，是描述客观事物的数、字符以及所有能输入到计算机且能被计算机识别和处理的符号集合。</p><p><strong>数据元素</strong></p><p>数据的基本单位，数据元素由数据项组成。如一条学生记录就是一个数据元素，它由姓名、学号、性别等数据项组成。</p><p><strong>数据对象</strong></p><p>具有相同性质的的数据元素集合，是数据的子集。</p><p><strong>抽象数据类型</strong></p><p>一个数学模型且定义在该模型上的一组操作，通常用数据对象、数据关系、基本操作集表示。</p><p><strong>数据结构</strong></p><p>数据结构包括逻辑结构、存储结构和数据的运算，算法的设计取决于选定的逻辑结构，算法的实现依赖于采用的存储结构。</p><blockquote><p>逻辑结构</p></blockquote><p>线性结构：结构中的数据元素只存在一对一的关系(线性表、栈和队列、串、数组、广义表)</p><p>非线性结构：结构中数据元素存在一对多的关系(树)、多对多的关系(图)</p><p>存储结构：顺序存储、链式存储、索引存储、散列存储</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数</title>
    <link href="/2019/04/26/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <url>/2019/04/26/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><p><strong>概念：行列式是一个数，是取自不同行不同列的n个元素的乘积的代数和</strong></p><p>二阶行列式：</p><script type="math/tex; mode=display">\begin{vmatrix}a & b\\c & d\end{vmatrix}=ad-bc</script><p>三阶行列式：</p><script type="math/tex; mode=display">\begin{vmatrix}a_{1} & a_{2} & a_{3}\\ b_{1} & b_{2} & b_{3}\\c_{1} & c_{2} & c_{3}\end{vmatrix}=a_{1}b_{2}c_{3}+a_{2}b_{3}c_{1}+a_{3}b_{1}c_{2}-a_{3}b_{2}c_{1}-a_{2}b_{1}c_{3}-a_{1}b_{3}c_{2}$$(对角线法则)n阶乘行列式：</script><p>\begin{vmatrix}<br>a<em>{11} &amp; a</em>{12} &amp; … &amp; a<em>{1n}\<br>a</em>{21} &amp; a<em>{22} &amp; … &amp; a</em>{2n}\<br>\vdots &amp;\vdots &amp; &amp;\vdots &amp;\<br>a<em>{n1} &amp; a</em>{n2} &amp; … &amp; a<em>{nn}<br>\end{vmatrix}=\sum</em>{j<em>{1}j</em>{2}…j<em>{n}}(-1)^{r(j</em>{1}j<em>{2}…j</em>{n})}a<em>{1j</em>{1}}a<em>{2j</em>{2}}…a<em>{nj</em>{n}}</p><script type="math/tex; mode=display">(完全展开式)$r(j_{1}j_{2}...j_{n})$ 为排列 $j_{1}j_{2}...j_{n}$ 的逆序数**性质**1. 经转置行列式的值不变. $\left | A^{T} \right |=\left | A \right |$2. 两行或两列互换的行列式变号. 3.</script><p>   \begin{vmatrix}<br>   a<em>{11} &amp; a</em>{12} &amp; … &amp; a<em>{1n}\<br>   a</em>{21} &amp; a<em>{22} &amp; … &amp; a</em>{2n}\<br>   \vdots &amp;\vdots &amp; &amp;\vdots &amp;\<br>   a<em>{n1} &amp; a</em>{n2} &amp; … &amp; a<em>{nn}<br>   \end{vmatrix}=-\begin{vmatrix}<br>   a</em>{21} &amp; a<em>{22} &amp; … &amp; a</em>{2n}\<br>   a<em>{11} &amp; a</em>{12} &amp; … &amp; a<em>{1n}\<br>   \vdots &amp;\vdots &amp; &amp;\vdots &amp;\<br>   a</em>{n1} &amp; a<em>{n2} &amp; … &amp; a</em>{nn}<br>   \end{vmatrix}</p><script type="math/tex; mode=display">4. 某行或某列有公因数k,可把k提取到行列式外.</script><p>   \begin{vmatrix}<br>   ka<em>{11} &amp; ka</em>{12} &amp; … &amp; ka<em>{1n}\<br>   a</em>{21} &amp; a<em>{22} &amp; … &amp; a</em>{2n}\<br>   \vdots &amp;\vdots &amp; &amp;\vdots &amp;\<br>   a<em>{n1} &amp; a</em>{n2} &amp; … &amp; a<em>{nn}<br>   \end{vmatrix}=k<br>   \begin{vmatrix}<br>   a</em>{11} &amp; a<em>{12} &amp; … &amp; a</em>{1n}\<br>   a<em>{21} &amp; a</em>{22} &amp; … &amp; a<em>{2n}\<br>   \vdots &amp;\vdots &amp; &amp;\vdots &amp;\<br>   a</em>{n1} &amp; a<em>{n2} &amp; … &amp; a</em>{nn}<br>   \end{vmatrix}</p><script type="math/tex; mode=display">5. 某行或某列所有元素都为两个数之和，则可写成两个行列式之和.   $$\begin{vmatrix}   a_{1} & a_{2}+a_{4} & a_{3}\\    b_{1} & b_{2}+b_{4} & b_{3}\\   c_{1} & c_{2}+c_{4} & c_{3}   \end{vmatrix}=   \begin{vmatrix}   a_{1} & a_{2}& a_{3}\\    b_{1} & b_{2}& b_{3}\\   c_{1} & c_{2}& c_{3}   \end{vmatrix}+   \begin{vmatrix}   a_{1} & a_{4} & a_{3}\\    b_{1} & b_{4} & b_{3}\\   c_{1} & c_{4} & c_{3}   \end{vmatrix}</script><ol><li><p>某行或某列的k倍加至某行或某列，行列式不变.</p><script type="math/tex; mode=display">\begin{vmatrix}a_{11} & a_{12} & ... & a_{1n}\\ a_{21} & a_{22} & ... & a_{2n}\\\vdots &\vdots & &\vdots &\\a_{n1} & a_{n2} & ... & a_{nn}\end{vmatrix}=\begin{vmatrix}a_{11} & a_{12} & ... & a_{1n}\\ a_{21}+ka_{11} & a_{22}+ka_{12} & ... & a_{2n}+ka_{1n}\\\vdots &\vdots & &\vdots &\\a_{n1} & a_{n2} & ... & a_{nn}\end{vmatrix}</script><p><sup><a href="#fn_特别地,某两行或两列相同或某行或某列元素全为0，则行列式为0；某两行或某两列成比例则行列式为0" id="reffn_特别地,某两行或两列相同或某行或某列元素全为0，则行列式为0；某两行或某两列成比例则行列式为0">特别地,某两行或两列相同或某行或某列元素全为0，则行列式为0；某两行或某两列成比例则行列式为0</a></sup>: </p></li><li><p>若$A$是$n$阶矩阵，则$|kA|=k^n|A|$，$|A^*|=|A|^{n-1}$</p></li><li><p>若$A,B$都是$n$阶矩阵，则$|AB|=|A||B|$</p></li><li><p>若$A$是$n$阶可逆矩阵，则$|A^{-1}|=|A|^{-1}$</p></li><li><p>若$n$阶矩阵$A$和$B$相似，则$|A|=|B|$</p></li></ol><p><strong>余子式和代数余子式</strong></p><p>余子式：在$n$阶行列式中，划去元素 $a<em>{ij}$ 所在的第 $i$ 行与第 $j$ 列的所有元素剩下的元素(不改变原来的顺序)所构成的 $n-1$ 阶行列式称为 $a</em>{ij}$ 的余子式,记为$M_{ij}$</p><p>代数余子式：$a<em>{ij}$ 的代数余子式 $A</em>{ij}=(-1)^{i+j}M_{ij}$</p><p>行列式</p><script type="math/tex; mode=display">\begin{vmatrix}a_{11} & a_{12} & a_{13}\\ a_{21} & a_{22} & a_{23}\\a_{31} & a_{32} & a_{33}\end{vmatrix}，a_{22}的余子式M_{22} = \begin{vmatrix}a_{11} &  a_{13}\\ a_{31} &  a_{33}\end{vmatrix}，a_{22}的代数余子式A_{22}=(-1)^{(2+2)}\begin{vmatrix}a_{11} &  a_{13}\\ a_{31} &  a_{33}\end{vmatrix}</script><p>行列式等于它任意一行(列)的各元素与其对应的代数式余子式乘积之和</p><script type="math/tex; mode=display">|A| = a_{i1}A_{i1}+a_{i2}A_{i2}+...+a_{in}A_{in}(按i行展开)\\|A| = a_{1j}A_{1j}+a_{2j}A_{2j}+...+a_{nj}A_{nj}(按j行展开)</script><p><strong>行列式的计算</strong></p><ol><li><p>三角化</p><script type="math/tex; mode=display">\begin{vmatrix}a_{11} & a_{12} & ... & a_{1n}\\ 0 & a_{22} & ... & a_{2n}\\\vdots &\vdots & &\vdots &\\0 & 0 & ... & a_{nn}\end{vmatrix}=\begin{vmatrix}a_{11} & 0 & ... & 0\\ a_{21} & a_{22} & ... & 0\\\vdots &\vdots & &\vdots &\\a_{n1} & a_{n2} & ... & a_{nn}\end{vmatrix}=a_{11}a_{22}...a_{nn}</script><script type="math/tex; mode=display">\begin{vmatrix}a_{11} & a_{12} & ... & a_{1n}\\ a_{21} & ... & a_{2n-1} & 0\\\vdots & &\vdots &\\a_{n1} & 0 & ... & 0\end{vmatrix}=\begin{vmatrix}0 & ... & 0 & a_{1n}\\ 0 & ... & a_{2n-1} & a_{2n}\\\vdots &  &\vdots &\vdots\\a_{n1} & a_{n2} & ... & a_{nn}\end{vmatrix}=(-1)^{\frac{n(n-1)}{2}}a_{1n}a_{2n-1}...a_{n1}</script></li><li><p>公式法(代数余子式) 、递推法 、利用行列式性质、利用矩阵性质</p></li><li><p>利用特征值. $|A| = \prod \lambda_{i}$</p></li><li><p>拉普拉斯展开式</p><script type="math/tex; mode=display">\begin{vmatrix}\mathbf{A} & \mathbf{*} \\ \mathbf{O} & \mathbf{B}\end{vmatrix}=\begin{vmatrix}\mathbf{A} & \mathbf{O} \\ \mathbf{*} & \mathbf{B}\end{vmatrix}=|\mathbf{A}||\mathbf{B}|，\begin{vmatrix}\mathbf{O} & \mathbf{A} \\ \mathbf{B} & \mathbf{*}\end{vmatrix}=\begin{vmatrix}\mathbf{*} & \mathbf{A} \\ \mathbf{B} & \mathbf{O}\end{vmatrix}=(-1)^{nm}|\mathbf{A}||\mathbf{B}|</script><p>$m、n$分别是矩阵$\mathbf{A}、\mathbf{B}$的阶数</p></li><li><p>范德蒙德行列式</p><p>$\begin{vmatrix}<br>1 &amp; 1 &amp; … &amp; 1 \<br>x<em>1 &amp;x_2 &amp;… &amp;x_n \<br>x_1^2 &amp;x_2^2 &amp;… &amp;x_n^2 \<br>\vdots &amp;\vdots&amp;&amp;\vdots \<br>x_1^{n-1} &amp;x_2^{n-1} &amp;… &amp;x_n^{n-1} \<br>\end{vmatrix}=\prod</em>{1\leqslant j\leqslant i\leqslant n}(x_i-x_j)$</p><p>$=(x<em>n-x</em>{n-1})…(x<em>n-x_1)\cdot (x</em>{n-1}-x<em>{n-2})…(x</em>{n-1}-x_1)…(x_3-x_2)(x_3-x_1)(x_2-x_1)$</p></li></ol><p><strong>证明|A| = 0</strong></p><p>Ax = 0 有非零解 、反证法、r(A) &lt; n、0是A的特征值、|A| = -|A|</p><p><strong>行列式的应用</strong></p><ol><li><p>向量组的相关性</p><p>设$\alpha_1,\alpha_2,\cdots,\alpha_n$是$n$个$n$维向量，$A=\alpha_1,\alpha_2,\cdots,\alpha_n$,则$\alpha_1,\alpha_2,\cdots,\alpha_s$线性无关的充分必要条件是$|A|\neq0$</p></li><li><p>矩阵的满秩与可逆</p><p>$A$满秩的充分必要条件是$|A|\neq0$</p><p>$A$可逆的充分必要条件是$|A|\neq0$</p></li><li><p>方程组的解</p><p>$AX=0$只有零解的充分必要条件是$|A|\neq0$</p><p>$AX=b$有唯一解的充分必要条件是$|A|\neq0$</p></li></ol><p><strong>$n$阶行列式的计算</strong></p><p>升阶法、递推法、化为上下三角形法、拆项</p><hr><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><p><strong>概念：$m$x$n$个数排成的$m$行$n$列的集合</strong></p><script type="math/tex; mode=display">\begin{bmatrix}a_{11} & a_{12} & ... & a_{1n}\\ a_{21} & a_{22} & ... & a_{2n}\\\vdots &\vdots & &\vdots &\\a_{m1} & a_{m2} & ... & a_{mn}\end{bmatrix}$$称为$m$x$n$矩阵，当$m= n$,矩阵称为$n$阶矩阵或$n$阶方阵[^行列式是方阵，仅方阵才有行列式]: **矩阵运算**1. $A+B=[a_{ij}+b_{ij}]$ 对应元素相加2. $kA=[ka_{ij}]$ 所有元素都乘以$k$3. $m$x$n$矩阵$A$，$n$x$s$矩阵$B$，$AB=C(m,s),c_{ij}=\sum_{k=1}^{n}a_{ik}b_{kj}$   $\begin{bmatrix}    &  & \\    (i)\cdots&\cdots&\cdots  \\     &  &    \end{bmatrix}   \begin{bmatrix}    & (j)  & \\     & \vdots  & \\     & \vdots  &  \\     & \vdots  &   \end{bmatrix}=   \begin{bmatrix}    & & \\     & c_{ij} &  \\     & &   \end{bmatrix}$例:$\begin{bmatrix}2 & 1 & 1 \\ 1 & 2 & 1\end{bmatrix}\begin{bmatrix}1 & 0 \\ 0 & 2 \\3 & 1 \end{bmatrix}=\begin{bmatrix}2\cdot1+1\cdot0+1\cdot3 & 2\cdot0+1\cdot2+1\cdot1\\ 1\cdot1+2\cdot0+1\cdot3 & 1\cdot0+2\cdot2+1\cdot1\end{bmatrix}=\begin{bmatrix}5 & 3\\ 4 & 5\end{bmatrix}$[^乘法条件:A的列数=B的行数]: 矩阵乘法法则:$A(BC)=(AB)C;\\A(B+C)=AB+AC,(A+B)C=AC+BC;\\ (kA)(lB)=klAB;\\ AE=A,EA=A \\ (A+E)^2=A^2+2A+E$$(A+B)^2=(A+B)(A+B)=A^2+AB+BA+B^2\neq  A^2+2AB+B^2$> 注意:$AB\neq  BA$**矩阵转置**矩阵$A$的行换成同序数的列得到的新矩阵为矩阵$A$的转置矩阵，记为$A^T$$A=\begin{bmatrix}1& 2 & 3 \\ 4& 5& 6\end{bmatrix},A^T=\begin{bmatrix}1 & 4 \\ 2 & 5 \\3 & 6 \end{bmatrix}$(横取竖放)**伴随矩阵**$A$是$n$阶矩阵，行列式$|A|$的每个元素$a_{ij}$的代数余子式$A_{ij}$所构成的矩阵为$A$的伴随矩阵,记为$A^*$$$A=\begin{bmatrix}a_{11}& a_{12}  \\ a_{21}& a_{22} \end{bmatrix}，A^*=\begin{bmatrix}A_{11}& A_{21}  \\ A_{12}& A_{22} \end{bmatrix}$$(横取竖放)> 二阶矩阵的伴随矩阵:主对角线元素互换,副对角线元素变号**逆矩阵**$A$是**$n$阶矩阵**，若存在**$n$阶矩阵B**使得$AB=BA=E$,则称A是可逆矩阵或非奇异矩阵，$B$是$A$的逆矩阵,记为$A^{-1}=B$,且$A$的逆矩阵唯一$A$可逆$\Leftrightarrow |A|\neq 0$​           $\Leftrightarrow r(A)=n$​           $\Leftrightarrow $A的列(行)向量组线性无关​           $\Leftrightarrow A=P_1P_2\cdots P_s,P_i$是初等矩阵​           $\Leftrightarrow A$与单位矩阵等价​           $\Leftrightarrow 0$不是A的特征值矩阵$A$与矩阵$B$等价的充分必要条件是存在可逆矩阵$P$与$Q$，使得$PAQ=B$- $A^{-1}=P_t\cdots P_2P_1$   $P_t\cdots P_2P_1A=E$  $P_t\cdots P_2P_1E=A^{-1} \rightarrow (A|E)\rightarrow \cdots\rightarrow(E|A^{-1})$- $P_t\cdots P_2P_1A=B$  $P_t\cdots P_2P_1E=P$ ($P=P_t\cdots P_2P_1$)  $(A|E)\rightarrow \cdots\rightarrow(B|P)$**正交矩阵**$n$阶矩阵$A$，若满足$AA^T=A^TA=E$，则$A$为正交矩阵**行阶梯矩阵、行最简矩阵****矩阵的初等变换**$E_{i,j}A$：对调$A$的$i,j$行 $AE_{i,j}$：对调$A$的$i,j$列**公式**1. 转置   $(A^T)^T=A ;(A+B)^T=A^T+B^T \\ (kA)^T=kA^T \\ (AB)^T=B^TA^T$2. 可逆   $(A^{-1})^{-1}=A;(kA)^{-1}=\frac{1}{k}A^{-1}  (k\neq 0) \\ (AB)^{-1}=B^{-1}A^{-1};(A^n)^{-1}=(A^{-1})^n$   $(A^{-1})^T=(A^T)^{-1};|A^{-1}|=\frac{1}{|A|}\\A^{-1}=\frac{1}{|A|}A^*$3. 伴随   $$AA^*=A^*A=|A|E</script><script type="math/tex; mode=display">A^*=|A|A^{-1};|A^*|=|A|^{n-1}</script><script type="math/tex; mode=display">(A^*)^{-1}=(A^{-1})^*=\frac{1}{|A|}A\\(A^*)^T=(A^T)^*;(kA)^*= k^{n-1}A^* ;(A^*)^*=|A|^{n-2}A</script><script type="math/tex; mode=display">(AB)^*=B^*A^*</script><p>   $r(A^*)=\begin{cases}<br>    n&amp; \text{ 如果 } r(A)=n \<br>    1&amp; \text{ 如果 } r(A)=n-1 \<br> 0&amp; \text{ 如果 } r(A)&lt;n-1<br>   \end{cases}$</p><ol><li><p>秩</p><p>$r(A)=r(A^T)=r(A^TA)\r(kA)=r(A),k\neq  0 \r(A+B)\leqslant r(A)+r(B)\r(AB)\leqslant min(r(A),r(B))$</p><p>若$A$可逆，则$r(AB)=r(B),r(BA)=r(B)$</p><p>若$A$为$m$x$n$矩阵，$B$为$n$x$s$矩阵，$AB=O$,则 $r(A)+r(B)\leqslant n$</p><p>$r\binom{A}{B}=r(A)+r(B)$</p><p>$r\begin{pmatrix}<br>A &amp; O\<br>O &amp; B<br>\end{pmatrix}=r(A)+r(B)$</p><p>设$A$为$n$阶矩阵，则$r(A)=1$的充分必要条件是存在非零$n$维向量$\alpha,\beta$,使得$A=\alpha\beta^{T}$</p><p>$\alpha^T\beta=tr(A)$(主对角线元素相加)</p><p>$A=\alpha\beta^{T}$，则$A^n=k^{n-1}A$,其中$k=\alpha^T\beta=\beta^{T}\alpha$</p><p>(满秩=矩阵列向量的个数)</p></li><li><p>分块矩阵</p><p>$\begin{bmatrix}<br>A_1 &amp; A_2\<br>A_3 &amp; A_4<br>\end{bmatrix}<br>+\begin{bmatrix}<br>B_1 &amp; B_2\<br>B_3 &amp; B_4<br>\end{bmatrix}=<br>\begin{bmatrix}<br>A_1+B_1  &amp; A_2+B_2 \<br>A_3+B_3  &amp; A_4+B_4<br>\end{bmatrix}$</p><p>$\begin{bmatrix}<br>A &amp; B\<br>C &amp; D<br>\end{bmatrix}<br>\begin{bmatrix}<br>X &amp; Y\<br>Z &amp; W<br>\end{bmatrix}=<br>\begin{bmatrix}<br>AX+BZ  &amp; AY+BW \<br>CX+DZ  &amp; CY+DW<br>\end{bmatrix}$</p><p>$\begin{bmatrix}<br>A &amp; B\<br>C &amp; D<br>\end{bmatrix}^T=<br>\begin{bmatrix}<br>A^T &amp; C^T\<br>B^T &amp; D^T<br>\end{bmatrix}$</p><p>若$B,C$分别是$m$阶与$s$阶矩阵，则$\begin{bmatrix}<br>B &amp; O\<br>O &amp; C<br>\end{bmatrix}^n =<br>\begin{bmatrix}<br>B^n &amp; O\<br>O &amp; C^n<br>\end{bmatrix}$</p><p>若$B,C$分别是$m$阶与$s$阶可逆矩阵，则$\begin{bmatrix}<br>B &amp; O\<br>O &amp; C<br>\end{bmatrix}^{-1}=<br>\begin{bmatrix}<br>B^{-1} &amp; O\<br>O &amp; C^{-1}<br>\end{bmatrix}，\begin{bmatrix}<br>O &amp; B\<br>C &amp; O<br>\end{bmatrix}^{-1}=\begin{bmatrix}<br>O &amp; C^{-1}\<br>B^{-1} &amp; O<br>\end{bmatrix}$</p></li><li><p>对角矩阵</p><p>$\begin{bmatrix}<br>a_1 &amp;  &amp; \<br> &amp;  a_2&amp; \<br> &amp;  &amp; a_3<br>\end{bmatrix}<br>\begin{bmatrix}<br>b_1 &amp;  &amp; \<br> &amp;  b_2&amp; \<br> &amp;  &amp; b_3<br>\end{bmatrix}=<br>\begin{bmatrix}<br>a_1b_1 &amp;  &amp; \<br> &amp;  a_2b_2&amp; \<br> &amp;  &amp; a_3b_3<br>\end{bmatrix}$</p><p>$\begin{bmatrix}<br>a_1 &amp;  &amp; \<br> &amp;  a_2&amp; \<br> &amp;  &amp; a_3<br>\end{bmatrix}^n=<br>\begin{bmatrix}<br>a_1^n &amp;  &amp; \<br> &amp;  a_2^n&amp; \<br> &amp;  &amp; a_3^n<br>\end{bmatrix}$</p><p>$\begin{bmatrix}<br>a_1 &amp;  &amp; \<br> &amp;  a_2&amp; \<br> &amp;  &amp; a_3<br>\end{bmatrix}^{-1}=<br>\begin{bmatrix}<br>\frac{1}{a_1} &amp;  &amp; \<br> &amp;  \frac{1}{a_2} &amp; \<br> &amp;  &amp; \frac{1}{a_3}<br>\end{bmatrix}$</p></li></ol><hr><h1 id="n-维向量"><a href="#n-维向量" class="headerlink" title="$n$维向量"></a>$n$维向量</h1><p><strong>定义1</strong></p><p>设$n$维列向量$\alpha =[a_1,a_2,\cdots,a_n]^T,\beta =[b_1.b_2,\cdots,b_n]^T$,则</p><p>$\alpha+\beta=[a_1+b_1,a_2+b_2,\cdots,a_n+b_n];\ k\alpha=[ka_1,ka_2,\cdots,ka_n]$</p><p>$(\alpha,\beta)=\alpha^T\beta=a_1b_1+a_2b_2+\cdots+a_nb_n$</p><p>$\begin{Vmatrix}<br>\alpha<br>\end{Vmatrix}=\sqrt{\alpha^T\alpha}=\sqrt{a_1^2+a_2^2+\cdots+a_n^2}$</p><p><strong>定义2</strong></p><p>设$\alpha_1,\alpha_2,\cdots,\alpha_s$是$n$维向量，$k_1,k_2,\cdots,k_s$是一组实数，称$k_1\alpha_1+k_2\alpha_2+\cdots+k_s\alpha_s$是$\alpha_1,\alpha_2,\cdots,\alpha_s$的线性组合，若$k_1\alpha_1+k_2\alpha_2+\cdots+k_s\alpha_s=\beta$,则称$\beta$是$\alpha_1,\alpha_2,\cdots,\alpha_s$的线性组合</p><p><strong>定义3</strong></p><p>设$\alpha_1,\alpha_2,\cdots,\alpha_s$是$n$维向量，如果存在不全为零的数使得$k_1\alpha_1+k_2\alpha_2+\cdots+k_s\alpha_s=0$，则称向量组$\alpha_1,\alpha_2,\cdots,\alpha_s$线性相关，当且仅当$k_1=k_2=\cdots=k_s=0$时，称向量组$\alpha_1,\alpha_2,\cdots,\alpha_s$线性无关</p><p><strong>定理1</strong></p><p>$k_1\alpha_1+k_2\alpha_2+\cdots+k_s\alpha_s=\beta$</p><p>$\Leftrightarrow$ 非齐次线性方程组$[\alpha_1,\alpha_2,\cdots,\alpha_s]\begin{bmatrix}<br>x_1\<br>x_2\<br>\vdots \<br>x_s<br>\end{bmatrix}=\beta$有解</p><p>$\Leftrightarrow$秩$r[\alpha_1,\alpha_2,\cdots,\alpha_s]=r[\alpha_1,\alpha_2,\cdots,\alpha_s,\beta]$</p><p><strong>定理2</strong></p><p>$\alpha_1,\alpha_2,\cdots,\alpha_s$线性相关</p><p>$\Leftrightarrow$ 齐次线性方程组$[\alpha_1,\alpha_2,\cdots,\alpha_s]\begin{bmatrix}<br>x_1\<br>x_2\<br>\vdots \<br>x_s<br>\end{bmatrix}=0$有非零解</p><p>$\Leftrightarrow$秩$r[\alpha_1,\alpha_2,\cdots,\alpha_s]&lt;s$</p><p><strong>推论</strong></p><p>1.$n$个$n$维向量$\alpha_1,\alpha_2,\cdots,\alpha_n$线性相关的充分必要条件是行列式$|\alpha_1,\alpha_2,\cdots,\alpha_n|=0$</p><p>2.向量组$\alpha_1,\alpha_2,\cdots,\alpha_n$线性相关的充分必要条件是$\alpha_1,\alpha_2,\cdots,\alpha_n$中至少有一个向量可由其余向量线性表示</p><p>3.含零向量的向量组一定线性相关</p><p>4.若一个向量组线性无关，则该向量组的任何部分向量组都线性无关</p><p>5.若向量组有部分向量组线性相关，则该向量组一定线性相关</p><p>6.$n$个$n$维向量$\alpha_1,\alpha_2,\cdots,\alpha_n$线性无关的充分必要条件是行列式$|\alpha_1,\alpha_2,\cdots,\alpha_n|\neq 0$</p><p>7.两个向量线性相关的充分必要条件是两个向量成比例</p><p>8.若$A$的任意两行两列成比例，则$A=\alpha\beta^T$</p><hr><h1 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h1><p><strong>定理</strong></p><p>齐次线性方程组$AX=0$ (零解和非零解)</p><ul><li>只有零解的充分必要条件是$r(A)=n$(A为普通矩阵),$|A|\neq0$(A为方阵)</li><li>有非零解的充分必要条件是$r(A) &lt;  n$(A为普通矩阵),$|A|= 0$(A为方阵)</li></ul><p>非齐次线性线性方程组$AX=b$(无解和有解)，增广矩阵$\overline{A}=(A\vdots b)$</p><ul><li><p>有解的充分必要条件是$r(A)=r(\overline{A})$</p><p>若$r(A)=r(\overline{A})=n$ 方程组有唯一解,$|A|\neq0$ (A为方阵时 )</p><p>若$r(A)=r(\overline{A}) &lt; n$ 方程组有无数个解，$|A|= 0$ (A为方阵时)</p></li><li><p>无解的充分必要条件是$r(A)\neq r(\overline{A})$</p></li></ul><p><strong>线性方程组解的结构</strong></p><ol><li>设$X_1,X_2,\cdots,X_s$为齐次线性方程组$AX=0$的一组解，则$k_1X_1+k_2X_2+\cdots+k_sX_s$也为$AX = 0$的解</li><li>设$\eta_0$为非齐次线性方程组$AX=b$的一个解，$X_1,X_2,\cdots,X_s$为齐次线性方程组$AX=0$的一组解，则$k_1X_1+k_2X_2+\cdots+k_sX_s+\eta_0$为$AX=b$的一个解</li><li>设$\eta_1，\eta_2$为非齐次线性方程组$AX=b$的两个解，则$\eta_2-\eta_1$为$AX = 0$的一个解</li><li>设$X_1,X_2,\cdots,X_s$为非齐次线性方程组$AX=b$的一组解，则$k_1X_1+k_2X_2+\cdots+k_sX_s$也为$AX = b$的解的充分必要条件是$k_1+k_2+\cdots+k_s=1$</li><li>设$X_1,X_2,\cdots,X_s$为非齐次线性方程组$AX=b$的一组解，则$k_1X_1+k_2X_2+\cdots+k_sX_s$为$AX = 0$的解的充分必要条件是$k_1+k_2+\cdots+k_s=0$</li></ol><p><strong>解方程组</strong></p><p>化为行阶梯型或行最简</p><p><strong>公共解</strong></p><p>$AX=b$，$BX=d$ 两个方程组的解的交集为其公共解</p><p>解法:</p><ul><li>$\begin{pmatrix}<br>A\<br>B<br>\end{pmatrix}X=\begin{pmatrix}<br>b\<br>d<br>\end{pmatrix}$ 该方程组的解即为公共解</li><li>先求出(1)的解再代入(2)，解即为公共解</li><li>分别求出(1)(2)的通解，令两个方程组的通解相等，从而求出公共解</li></ul><p><strong>同解</strong></p><p>$AX=O$，$BX=O$ ,(1)的解也是(2)的解</p><p>(1)、(2)同解的必要条件是$r(A)=r(B)$</p><hr><h1 id="特征值与特征向量"><a href="#特征值与特征向量" class="headerlink" title="特征值与特征向量"></a>特征值与特征向量</h1><p><strong>定义</strong></p><p>1.设$A$是$n$阶矩阵，如果存在一个数$\lambda$及非零$n$维列向量$\alpha$ ,使得$A\alpha=\lambda\alpha$成立，则称$\lambda$是$A$的一个特征值，$\alpha$是矩阵$A$属于特征值$\lambda$的一个特征向量. <strong>$A$有$n$个特征值(包括重数)</strong></p><p>$|\lambda E-A|=0$为$A$的特征方程，通过此方程可求出$A$特征值，</p><p>$(\lambda_iE-A)X=0$的基础解系为$\lambda_i$对应的线性无关的特征向量</p><p>任何特征值都对应无数个特征向量，但其线性无关的特征向量不超过其重数</p><p>2.设$A,B$都是$n$阶矩阵，如果存在可逆矩阵$P$,使得$P^{-1}AP=B$，则称矩阵$A,B$相似,记作 $A\sim B$</p><p>$P^{-1}A^nP=B^n,A^n=PB^nP^{-1}$</p><p>3.已知$B=P^{-1}AP$，$A$的特征值为$\lambda_1,\lambda_2,\dots,\lambda_n$，其对应的特征特征向量为$\alpha_1,\alpha_2,\dots,\alpha_n$,</p><p>则 $BP^{-1}=P^{-1}A \rightarrow BP^{-1}\alpha_i=P^{-1}A\alpha_i \rightarrow BP^{-1}\alpha_i=\lambda_iP^{-1}\alpha_i$</p><p>即$B$的特征向量为$\beta_i=P^{-1}\alpha_i$</p><p><strong>矩阵相似的性质</strong></p><ol><li><p>$A\sim A$</p></li><li><p>若$A\sim B$,则$B\sim A$</p></li><li><p>若$A\sim B$，则$A^T\sim B^T$</p><p>且$A，B$可逆，则$A^{-1}\sim B^{-1}$，<script type="math/tex">A^*\sim B^*</script></p></li><li><p>若$A\sim B$，$B\sim C$,则$A\sim C$</p></li><li><p>若$A\sim B$，$r(A)=r(B)$,$|\lambda E-A|=|\lambda E-B|$</p></li><li><p>若$A\sim B$，则$|A|=|B|,tr(A)=tr(B)$</p></li></ol><p><strong>特征值与特征向量的性质​</strong></p><p>设$A$为$n$阶矩阵，$\lambda_1,\lambda_2,\cdots,\lambda_n$为其特征值</p><ol><li>$\lambda_1+\lambda_2+\cdots+\lambda_n=tr(A)$</li><li>$\lambda_1\lambda_2\cdots\lambda_n=|A|$</li></ol><p>设$A$为$n$阶矩阵，且$A\alpha=\lambda_0\alpha$,$f(x)=a_nx^n+\cdots+a_1x+a_0$,令$f(A)=a_nA^n+\cdots+a_1A+a_0E$,则</p><ol><li>若$A$可逆，则$A^{-1}\alpha=\frac{1}{\lambda_0}\alpha$,即$\frac{1}{\lambda_0}$为$A^{-1}$的特征值，$\alpha$为$A^{-1}$的特征向量</li><li>若$A$可逆，则$$A^<em>\alpha=\frac{|A|}{\lambda_0}\alpha$b,即a$\frac{|A|}{\lambda_0}$}为{$A^</em>$b的特征值，$\alpha$为$A^*$的特征向量</li><li>$f(A)\alpha=f(\lambda_0)\alpha$,即$f(\lambda_0)$为$f(A)$的特征值，$\alpha$为 $f(A)$的特征向量</li></ol><p>$A$可逆时，$A^{-1},A^*,A$的特征向量相同</p><p><strong>设$A$为$n$阶矩阵,$A$的不同特征值对应的特征向量线性无关</strong></p><p><strong>施密特正交化</strong></p><p>把一组<strong>线性无关</strong>的向量组化为一组<strong>两两正交</strong>且规范化的向量组的过程称为施密特正交化</p><p>设$\alpha_1,\alpha_2,\cdots,\alpha_n$线性无关，</p><ol><li><p>正交化</p><p>令$\beta<em>1=\alpha_1,\beta_2=\alpha_2-\frac{(\alpha_2,\beta_1)}{(\beta_1,\beta_1)}\beta_1,\cdots$<br>t   $\beta_n=\alpha_n-\frac{(\alpha_n,\beta_1)}{(\beta_1,\beta_1)}\beta_1-\frac{(\alpha_n,\beta_2)}{(\beta_2,\beta_2)}\beta_2-\cdots-\frac{(\alpha_n,\beta</em>{n-1})}{(\beta<em>{n-1},\beta</em>{n-1})}\beta_{n-1}$</p><p>则$\beta_1,\beta_2,\cdots,\beta_n$两两正交</p></li><li><p>规范化</p><p>令$\gamma_1=\frac{1}{|\beta_1|}\beta_1, \gamma_2=\frac{1}{|\beta_2|}\beta_2,\cdots,\gamma_n=\frac{1}{|\beta_n|}\beta_n$</p><p>则$\gamma_1,\gamma_2,\cdots,\gamma_n$为两两正交且规范化的向量组</p></li></ol><p><strong>正交矩阵</strong></p><p>设$Q$为$n$阶矩阵，若$Q^TQ=E或QQ^T=E$,称$Q$为正交矩阵</p><p>设$Q=(\gamma_1,\gamma_2,\cdots,\gamma_n)$为$n$阶矩阵,则$Q$为正交矩阵的充分必要条件是$\gamma_1,\gamma_2,\cdots,\gamma_n$为两两正交且规范化的向量组</p><p>若$Q$为正交矩阵，则$Q^{-1}=Q^T$,$|Q|=\pm1,特征值为-1或1；且Y=QX，则|Y|=|X|$</p><p><strong>实对称矩阵 $A^T=A$</strong></p><ol><li>实对称矩阵的特征值都是实数</li><li><strong>实对称矩阵的不同特征值对应的特征向量正交</strong></li><li>实对称矩阵一定可以相似对角化，特别地若$A^T=A$,则存在正交矩阵$Q$使得$Q^TAQ=\begin{bmatrix}<br>\lambda_1 &amp; 0 &amp; \cdots &amp; 0\<br>0 &amp; \lambda_2 &amp; \cdots &amp; 0\<br>\vdots &amp; \vdots &amp; \vdots &amp; \vdots\<br>0 &amp; 0 &amp; 0 &amp; \lambda_n<br>\end{bmatrix}$ ,$\lambda_1,\lambda_2,\cdots\lambda_n$为实对称矩阵$A$的特征值</li></ol><p><strong>矩阵可相似对角化</strong></p><ul><li>矩阵$A$的特征值都是单值</li><li>矩阵$A$为实对称矩阵</li><li>矩阵$A$有$n$个线性无关的特征向量</li><li>矩阵$A$特征值的重数与其对应的线性无关的特征向量个数相等，即$n-r(\lambda_i E-A)=重数,\lambda_i为重根特征值$</li></ul><p>设$A$为$n$阶矩阵，则$A$可相似对角化(与对角矩阵相似)的充分必要条件是$A$有$n$个线性无关的特征向量</p><ol><li><p>由$|\lambda E-A|=0$求出$A$的特征值 $\lambda_1,\lambda_2,\cdots,\lambda_n $</p></li><li><p>由$(\lambda_i E-A)X=0$求出$A$的特征向量$\delta_1,\delta_2,\cdots,\delta_m  $</p></li><li><p>若$m&lt;n$时，矩阵$A$不可对角化；若$m=n$时，矩阵$A$可相似对角化</p><p>由$A\delta_i=\lambda_i\delta_i $得</p><p>$(A\delta_1,A\delta_2,\cdots,A\delta_n)=(\lambda_1\delta_1,\lambda_2\delta_2 ,\cdots,\lambda_n\delta_n )$ 即</p><p>$A(\delta_1,\delta_2,\cdots,\delta_n)=(\delta_1,\delta_2,\cdots,\delta_n)\begin{bmatrix}<br>\lambda_1 &amp; 0 &amp; \cdots &amp; 0\<br>0 &amp; \lambda_2 &amp; \cdots &amp; 0\<br>\vdots &amp; \vdots &amp; \vdots &amp; \vdots\<br>0 &amp; 0 &amp; 0 &amp; \lambda_n<br>\end{bmatrix}$</p><p>令$P=(\delta_1,\delta_2,\cdots,\delta_n)$,则$P$可逆，且$P^{-1}AP=\begin{bmatrix}<br>\lambda_1 &amp; 0 &amp; \cdots &amp; 0\<br>0 &amp; \lambda_2 &amp; \cdots &amp; 0\<br>\vdots &amp; \vdots &amp; \vdots &amp; \vdots\<br>0 &amp; 0 &amp; 0 &amp; \lambda_n<br>\end{bmatrix}$</p></li></ol><p><strong>实对称矩阵的对角化</strong></p><ol><li>若求可逆矩阵$P$，则按上述步骤即可</li><li>若求正交矩阵$Q$,将$\delta_1,\delta_2,\cdots,\delta_n$施密特正交化和规范化，令$Q=(\delta_1,\delta_2,\cdots,\delta_n)$,则$Q^TAQ=\begin{bmatrix}<br>\lambda_1 &amp; 0 &amp; \cdots &amp; 0\<br>0 &amp; \lambda_2 &amp; \cdots &amp; 0\<br>\vdots &amp; \vdots &amp; \vdots &amp; \vdots\<br>0 &amp; 0 &amp; 0 &amp; \lambda_n<br>\end{bmatrix}$</li></ol><p><strong>矩阵相似的判断</strong></p><p>$A,B$相似的必要条件是$|\lambda E-A|=|\lambda E-B|$,即$A,B$具有相同的特征值</p><p>若$A,B$特征值相同，判断$A,B$相似一般分如下情形：</p><ol><li>若$A,B$都可相似对角化，则$A \sim B$</li><li>若$A,B$一个可相似对角化，一个不可相似对角化，则$A,B$一定不相似</li><li>若$A,B$都不可相似对角化，一般不讨论</li></ol><hr><h1 id="二次型"><a href="#二次型" class="headerlink" title="二次型"></a>二次型</h1><p><strong>定义1</strong></p><p>含有$n$个变量$x_1,x_2,\cdots,x_n$的二次齐次函数</p><p>$f(x<em>1,x_2,\cdots,x_n)=a</em>{11}x<em>1^2+a</em>{22}x<em>2^2+\cdots+a</em>{nn}x<em>n^2+2a</em>{12}x<em>1x_2+2a</em>{13}x<em>1x_3+\cdots+2a</em>{1n}x<em>1x_n+2a</em>{23}x<em>2x_3+\cdots+2a</em>{2n}x<em>2x_n+\cdots+2a</em>{n-1,n}x_{n-1}x_n$ </p><p>称为$n$元二次型.若规定$a<em>{ij}=a</em>{ji}$，则二次型有矩阵表示$f(x_1,x_2,\cdots,x_n)=x^TAx$,</p><p>其中$x=[x<em>1,x_2,\cdots,x_n]^T,A=[a</em>{ij}]$且$A^T=A$,称$A$为二次型的矩阵</p><p>例如：$f(x_1,x_2)=x_1^2+5x_2^2+6x_1x_2$，有</p><p>​            $f(x_1,x_2)=x_1^2+3x_1x_2+3x_1x_2+5x_2^2$</p><p>​                              $=x_1(x_1+3_x2)+x_2(3x_1+5x_2)$</p><p>​                              $=[x_1,x_2] \begin{bmatrix}x_1 &amp; 3x_2\ 3x_1 &amp; 5x_2 \end{bmatrix}$</p><p>​                             $=[x_1,x_2] \begin{bmatrix}1 &amp; 3\ 3 &amp; 5 \end{bmatrix} \begin{bmatrix}x_1\ x_2\end{bmatrix}=x^TAx$</p><p>若对任何$x\neq0$,恒有$x^TAx&gt;0$，则称二次型为正定二次型</p><ul><li><p>若二次型中只含有变量的平方项，即$x^TAx=d_1x_1^2+d_2x_2^2+\cdots+d_nx_n^2$称为二次型的标准形</p></li><li><p>若标准形中，平方项的系数$d<em>j$为1，-1或0，即$x^TAx=x_1^2+x_2^2+\cdots+x_p^2-x</em>{p+1}x^2+\cdots-x_{p+q}^2$ 称为二次型的规范形</p></li><li>标准形中，正平方项的个数$p$称为二次型的正惯性指数，负平方项的个数$q$称为二次型的负惯性指数，系数不为0的个数为二次型的秩</li></ul><p><strong>定义2</strong></p><p>若</p><script type="math/tex; mode=display">\left\{\begin{matrix}x_1=c_{11}y_1+c_{12}y_2+c_{13}y_3\\ x_2=c_{21}y_1+c_{22}y_2+c_{23}y_3\\ x_3=c_{31}y_1+c_{32}y_2+c_{33}y_3\end{matrix}\right.满足|C|=\begin{bmatrix}c_{11} & c_{12} & c_{13}\\c_{21} & c_{22} & c_{23}\\ c_{31} & c_{32} & c_{33}\end{bmatrix} \neq0$$ 称$x=[x_1,x_2,x_3]^T到y=[y_1,y_2,y_3]$的坐标变换，即</script><p>\begin{bmatrix}<br>x<em>1\<br>x_2\<br>x_3<br>\end{bmatrix}=\begin{bmatrix}<br>c</em>{11} &amp; c<em>{12} &amp; c</em>{13}\<br>c<em>{21} &amp; c</em>{22} &amp; c<em>{23}\<br>c</em>{31} &amp; c<em>{32} &amp; c</em>{33}<br>\end{bmatrix}\begin{bmatrix}<br>y_1\<br>y_2\<br>y_3<br>\end{bmatrix} 或x=Cy$$<br>两个$n$阶矩阵$A$和$B$，如果存在可逆矩阵$C$使得$C^TAC=B$则称矩阵$A$和$B$合同，并称$A$到$B$的变换为合同变换，$C$为合同变换矩阵</p><p><strong>定理1</strong></p><p>变量$x=[x_1,x_2,\dots,x_n]^T$的$n$元二次型$x^TAx$经坐标变换$x=Cy$后，化为变量$y=[y_1,y_2,\cdots,y_n]$的$n$元二次型$y^TBy$.</p><p>$x^TAx=(Cy)^TA(Cy)=y^TC^TACy=y^TBy$,其中$B=C^TAC$</p><p><strong>定理2</strong></p><p>任意的$n$元二次型$x^TAx$都可以通过坐标变换化成标准形</p><p>对任一个$n$元二次型$x^TAx$，其中$A$是$n$阶实对称矩阵，必存在正交变换$x=Qy$ ($Q$是正交矩阵)，使得$x^TAx$化为标准形$\lambda_1y_1^2+\lambda_2y_2^2+\cdots+\lambda_ny_n^2$</p><p><strong>定理3</strong></p><p>任一$n$阶是对称矩阵$A$，总可以合同于一个对角矩阵，即$C^TAC=\begin{bmatrix}<br>d_1 &amp; 0 &amp; \cdots &amp; 0\<br>0 &amp; d_2 &amp; \cdots &amp; 0\<br>\vdots &amp; \vdots &amp; \vdots &amp; \vdots\<br>0 &amp; 0 &amp; 0 &amp; d_n<br>\end{bmatrix}$</p><p><strong>定理4</strong>​</p><p>$n$元二次型$x^TAx$正定的充分必要条件:</p><ol><li>$A$的正惯性指数是$n$</li><li>$A$与$E$合同，且存在可逆矩阵$C$，使得$C^TAC=E$</li><li>$A$的所有特征值均为正数</li><li>$A$的各阶顺序主子式均大于零</li></ol><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小贴士</title>
    <link href="/2019/03/15/%E5%B0%8F%E8%B4%B4%E5%A3%AB/"/>
    <url>/2019/03/15/%E5%B0%8F%E8%B4%B4%E5%A3%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p>Q： Visual Studio 编译工程报错:error C4996: ‘strtok’: This function or variable may be unsafe. Consider using strtok_s instead<br>A：工程属性 —&gt;C/C++ —&gt; 预处理器 —&gt; 预处理器定义,添加宏定义</p><pre><code class="lang-cpp">_CRT_SECURE_NO_WARNINGS</code></pre><hr><p>Q： pthread.h中报错：C2011“timespec”:“struct”类型重定义<br>A：tim.h已定义，pthread.h添加如下代码：</p><pre><code class="lang-cpp">#if !defined( PTHREAD_H )#define PTHREAD_H#define HAVE_STRUCT_TIMESPEC</code></pre><hr><p>Q：Visual Studio 工程编译dll,接口的定义<br>A：接口的头文件应如下声明：</p><pre><code class="lang-cpp">#define LIB_API __declspec(dllexport) //导出函数extern &quot;C&quot; {    LIB_API char*   say();}</code></pre><hr><p>Q：C++调用DLL</p><ul><li><p>dll的创建</p><pre><code class="lang-c++">//test.h#ifdef __cplusplusextern &quot;C&quot; {#endif__declspec(dllexport) int add(int a,int b);#ifdef __cplusplus}#endif  // __cplusplus</code></pre><pre><code class="lang-c++">//test.cpp#include &quot;test.h&quot;int add(int a,int b) {    return a + b;}</code></pre><p>编译上述工程为dll，即生成test.dll，并复制到调用该dll工程的编译目录</p></li><li><p>dll的使用</p><pre><code class="lang-c++">#include&lt;Windows.h&gt;#includ&lt;iostream&gt;typedef int (*padd)(int,int);int main(int argc, char *argv[]){    HMODULE test = LoadLibrary(&quot;test.dll&quot;);    if (test != NULL){        padd add = (padd)GetProcAddress(test,&quot;add&quot;);        if (add != NULL){                std::cout &lt;&lt; add(1,0) &lt;&lt; std::endl;        }    }}</code></pre></li></ul><hr><p>Q:cmake 简单编译命令</p><pre><code class="lang-bash">sudo tar -zxvf testcd testsudo mkdir buildcd build/sudo cmake -DCMAKE_INSTALL_PREFIX=/home/test .. #安装目录sudo make -j4 #编译sudo make install #安装sudo ldconfig #更新软连接</code></pre><hr><p>Q: mac安装LLVM</p><pre><code class="lang-bash">$ cd where-you-want-llvm-to-live$ svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm$ cd llvm/tools$ svn co http://llvm.org/svn/llvm-project/cfe/trunk clang$ cd llvm/tools/clang/tools$ svn co http://llvm.org/svn/llvm-project/clang-tools-extra/trunk extra$ cd llvm/projects$ svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt$ cd llvm$ mkdir build$ cd build$ cmake -G &quot;Unix Makefiles&quot; ..$ make$ make install</code></pre><hr><p>Q:cJSON的使用</p><pre><code class="lang-c++">#include &quot;cJSON.h&quot;cJSON  *root = cJSON_CreateObject();cJSON  *bboxs = cJSON_CreateArray();char *resultJson;cJSON_AddNumberToObject(root, &quot;status&quot;, 1);cJSON_AddStringToObject(root, &quot;msg&quot;, &quot;detect ok&quot;);cJSON_AddItemToObject(root, &quot;bboxs&quot;, bboxs);for (int i = 0; i &lt; 2; i++){  cJSON  *bbox;  cJSON_AddItemToArray(bboxs, bbox = cJSON_CreateObject());  cJSON_AddNumberToObject(bbox, &quot;score&quot;, 99);  cJSON_AddNumberToObject(bbox, &quot;x&quot;, 1);  cJSON_AddNumberToObject(bbox, &quot;y&quot;, 2);  cJSON_AddNumberToObject(bbox, &quot;width&quot;, 3);  cJSON_AddNumberToObject(bbox, &quot;height&quot;, 4);}resultJson = cJSON_PrintUnformatted(result);</code></pre><hr><p>Q:c#调用dll</p><p>note:若dll为X64,则c#应编译x64,否则报错</p><pre><code class="lang-c#">using System;using System.Collections.Generic;using System.Linq;using System.Runtime.InteropServices;using System.Text;using System.Threading.Tasks;namespace test{    class Program    {        [DllImport(@&quot;facedetection.dll&quot;, EntryPoint = &quot;facedetect&quot;)]        extern static string facedetect(string src);        static void Main(string[] args)        {            string result = facedetect(&quot;test.jpg&quot;);            Console.WriteLine(result);            Console.ReadKey();        }    } }</code></pre><hr><p>Q：opencv Mat和byte互转</p><pre><code class="lang-c++">unsigned char* matToBytes(Mat image){   int size = image.total() * image.elemSize();     unsigned char* bytes = new unsigned char[size];  // you will have to delete[] that later     std::memcpy(bytes, image.data, size * sizeof(unsigned char));     return bytes;}Mat bytesToMat(unsigned char* bytes,int width,int height){    Mat image = Mat(height,width,CV_8UC3,bytes).clone(); // make a copy    return image;}</code></pre><hr><p>Q:opencv Mat 转std::vector std::vector转std::string</p><pre><code class="lang-c++">cv::Mat output = output.reshape(1, 1);std::vector&lt;double&gt; vetor = (std::vector&lt;double&gt;)output;std::stringstream ss;ss &lt;&lt; std::setprecision(16);//精度设置std::copy(vector.begin(), vector.end(), std::ostream_iterator&lt;double&gt;(ss, &quot;,&quot;));std::string values = ss.str();values.pop_back();//去掉末尾多余的分隔符std::cout &lt;&lt; values;Mat convertToMat(std::string str) {    std::vector&lt;double&gt; v;    std::stringstream ss(str);    ss &lt;&lt; std::setprecision(16);    std::string token;    while (std::getline(ss, token, &#39;,&#39;)) {        v.push_back(std::stod(token));    }    Mat output = cv::Mat(v, true).reshape(1, 1);    return output;}cv::FileStorage fs(&quot;../features.xml&quot;, cv::FileStorage::WRITE);fs &lt;&lt; &quot;features&quot; &lt;&lt; output;fs.release();</code></pre><hr><p>Q: opencv 截取图片的矩形区域</p><pre><code class="lang-c++">rectangle(image, Rect(x, y, w, h), Scalar(0, 255, 0), 2);Mat dst = image(cv::Range(y,y+h),cv::Range(x,x+w));</code></pre><hr><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p>Q：python打包发布</p><p>1.项目根目录新建setup.py</p><pre><code class="lang-python">from distutils.core import setupsetup( name=&#39;test&#39;,  #打包的输出文件名 version=&#39;1.0.0&#39;, py_modules=[&#39;test&#39;] #打包的.py文件)</code></pre><p>依赖文件 requirements.txt生成</p><p>pip freeze &gt; requirements.txt</p><pre><code class="lang-text">opencv==3.4.2numpy==1.16.4scikit-image==0.15.0</code></pre><p>或者 conda list -e &gt; requirements.txt</p><pre><code class="lang-tex">numpy=1.16.4opencv=3.4.2scikit-image=0.15.0</code></pre><p>2.项目根目录下执行命令</p><pre><code class="lang-bash">sudo python setup.py sdist</code></pre><p>生成dist目录且包含test-1.0.0.tar.gz分发包</p><p>3.安装：解压分发包并定位到解压目录后执行安装命令</p><pre><code class="lang-bash">pip install -r requirements.txt #安装依赖 或者 conda install --yes --file requirements.txtsudo python setup.py install</code></pre><p>4.使用</p><p>import test<br>test.sayHello();//#调用模块的sayHello方法</p><hr><p>Q:jupyter notebook 运行于指定的conda环境上</p><pre><code class="lang-bash">conda install nb_conda</code></pre><p>重启jupyter notebook 选择kernel即可</p><blockquote><blockquote><hr><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><p>Q：iframe父/子页面互相调用方法</p></blockquote></blockquote><pre><code class="lang-html">document.getElementById(&quot;iframeId&quot;).contentWindow.childMethod()/childVariable;parent.parentMethod()/parentVariable</code></pre><hr><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p>Q：springboot切面编程实例</p><pre><code class="lang-java">@Aspect@Component@Slf4jpublic class WebLogAspect {    //定义一个切入点，对该包下的所有函数方法执行前，执行@Before()    @Pointcut(&quot;execution(public * com.jp.controller..*.*(..))&quot;)    public void webLog(){}    @Before(&quot;webLog()&quot;)    public void doBefore(JoinPoint joinPoint) throws Throwable {        // 接收到请求，记录请求内容        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();        HttpServletRequest request = attributes.getRequest();        // 记录下请求内容        log.info(&quot;URL : &quot; + request.getRequestURL().toString());        log.info(&quot;HTTP_METHOD : &quot; + request.getMethod());        log.info(&quot;IP : &quot; + request.getRemoteAddr());        log.info(&quot;CLASS_METHOD : &quot; + joinPoint.getSignature().getDeclaringTypeName() + &quot;.&quot; + joinPoint.getSignature().getName());        log.info(&quot;ARGS : &quot; + Arrays.toString(joinPoint.getArgs()));    }    @AfterReturning(returning = &quot;ret&quot;, pointcut = &quot;webLog()&quot;)    public void doAfterReturning(Object ret) throws Throwable {        // 处理完请求，返回内容        log.info(&quot;RESPONSE : &quot; + ret);    }}</code></pre><p>Q：Mac，MavenReportException: Error while creating archive: Unable to find javadoc command: The environment variable JAVA_HOME is not correctly set</p><p>在pom.xml文件中添加javadoc命令的位置</p><pre><code>&lt;properties&gt;     &lt;javadocExecutable&gt;/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/bin/javadoc&lt;/javadocExecutable&gt;&lt;/properties&gt;</code></pre><hr><h1 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h1><p>Q：利用nginx共享文件夹</p><p>nginx.conf添加如下配置</p><pre><code>server {    listen       8000;    server_name  localhost;    charset utf-8;    location / {    root /home;#共享根目录下的home文件夹    # 索引    autoindex on;    # 显示文件大小    autoindex_exact_size on;    # 显示文件时间    autoindex_localtime on;    #index  index.html index.htm;  }}</code></pre><p>Q:更改ubuntu源为阿里云源</p><pre><code class="lang-bash">sudo cp /etc/apt/sources.list /etc/apt/sources.list.baksudo vim /etc/apt/source.listdeb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-propertiesdeb http://archive.canonical.com/ubuntu xenial partnerdeb-src http://archive.canonical.com/ubuntu xenial partnerdeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverseapt-get update #ormv /etc/apt/sources.list /etc/apt/sources.list.bakecho &quot;deb http://mirrors.163.com/debian/ jessie main non-free contrib&quot; &gt;&gt; /etc/apt/sources.listecho &quot;deb http://mirrors.163.com/debian/ jessie-proposed-updates main non-free contrib&quot; &gt;&gt;/etc/apt/sources.listecho &quot;deb-src http://mirrors.163.com/debian/ jessie main non-free contrib&quot; &gt;&gt;/etc/apt/sources.listecho &quot;deb-src http://mirrors.163.com/debian/ jessie-proposed-updates main non-free contrib&quot; &gt;&gt;/etc/apt/sources.listapt-get update</code></pre><p>Q:oracle导入dmp备份文件</p><pre><code>[root@centos ～]# su - oracle[oracle@centos ～]# sqlplus 请输入用户名:  sys as sysdba输入口令:SQL&gt; CREATE USER 用户 IDENTIFIED BY 密码;User created.SQL&gt; GRANT CONNECT, RESOURCE, DBA TO 用户;Grant succeeded.SQL&gt; CONNECT 用户@orcl #新用户测试登陆</code></pre><p>复制*.dmp文件到linux并加权</p><pre><code>[root@centos ～]# chmod 777 *.dmp</code></pre><p>导入dmp数据库备份文件</p><pre><code>[root@centos ～] su - oracle[oracle@centos ～]imp 用户名/密码@orcl file=/home/*.dmp ignore=y full=y; Import terminated successfully with warnings.(成功)</code></pre><hr><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小贴士</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>opencv3(1-2) linux配置opencv3开发环境</title>
    <link href="/2019/03/11/opencv3(1-2)%20linux%E9%85%8D%E7%BD%AEopencv3%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <url>/2019/03/11/opencv3(1-2)%20linux%E9%85%8D%E7%BD%AEopencv3%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p><strong>环境</strong><br>ubuntu<br>cmake<br>cmake-gui<br>opencv-3.3.1 下载地址:<a href="https://opencv.org/releases.html" target="_blank" rel="noopener">https://opencv.org/releases.html</a><br>opencv_contrib-3.3.1 下载地址:<a href="https://github.com/opencv/opencv_contrib/releases" target="_blank" rel="noopener">https://github.com/opencv/opencv_contrib/releases</a></p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul><li>更新系统<pre><code class="lang-bash">sudo apt-get updatesudo apt-get upgrade</code></pre></li><li>安装cmake及必要依赖<pre><code class="lang-bash">sudo apt-get install build-essentialsudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-devsudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev</code></pre></li><li>安装cmake-gui<pre><code class="lang-bash">sudo apt-get install cmake-qt-gui</code></pre></li><li>解压opencv以及opecv_contrib至同一目录<br><img src="/images/opencv3/2-1.png" srcset="/img/loading.gif" alt=""></li><li>opencv目录内新建build目录<br><img src="/images/opencv3/2-2.png" srcset="/img/loading.gif" alt=""><br>build目录内打开终端运行cmake-gui<pre><code class="lang-bash">cmake-gui</code></pre></li></ul><h1 id="编译-安装"><a href="#编译-安装" class="headerlink" title="编译 / 安装"></a>编译 / 安装</h1><ul><li><p>配置源码目录以及编译目录<br><img src="/images/opencv3/2-3.png" srcset="/img/loading.gif" alt=""></p></li><li><p>执行Configure<br>Unix Makefiles - &gt; Use default native compilers(默认) - &gt; Finish<br><img src="/images/opencv3/2-4.png" srcset="/img/loading.gif" alt=""></p></li><li><p>配置编译属性<br>CMAKE_BUILD_TYPE：RELEASE<br>CMAKE_INSTALL_PREFIX：/home/jiaopan/app/opencv #配置安装目录 可默认<br><img src="/images/opencv3/2-5.png" srcset="/img/loading.gif" alt=""><br>OPENCV_EXTRA_MODULES_PATH：/home/jiaopan/app/opencv3/opencv_contrib-3.3.1/modules #opencv_contrib的modules目录<br><img src="/images/opencv3/2-6.png" srcset="/img/loading.gif" alt=""></p></li><li><p>执行Generate 生成配置文件</p></li><li><p>build目录内打开终端 执行make命令开始编译 ，100%时编译成功<br><img src="/images/opencv3/2-7.png" srcset="/img/loading.gif" alt=""></p></li><li><p>编译成功，执行make install 命令进行安装</p></li><li><p>编译时问题</p><pre><code class="lang-bash">#1.问题1collect2: error: ld returned 1 exit statusmodules/core/CMakeFiles/opencv_perf_core.dir/build.make:882: recipe for target &#39;bin/opencv_perf_core&#39; failedmake[2]: *** [bin/opencv_perf_core] Error 1CMakeFiles/Makefile2:2627: recipe for target &#39;modules/core/CMakeFiles/opencv_perf_core.dir/all&#39; failedmake[1]: *** [modules/core/CMakeFiles/opencv_perf_core.dir/all] Error 2Makefile:160: recipe for target &#39;all&#39; failedmake: *** [all] Error 2#解决：缺少ffmpeg#安装ffmpegsudo add-apt-repository ppa:djcj/hybrid  sudo apt-get update  sudo apt-get install ffmpeg</code></pre></li></ul><h1 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h1><pre><code class="lang-bash">sudo vim /etc/ld.so.conf.d/opencv.conf #添加 /home/jiaopan/app/opencv/lib内容 ，即opencv安装目录下的lib目录路径sudo ldconfig #更新动态链接库sudo vim /etc/bash.bashrc #末尾添加如下内容PKG_CONFIG_PATH=$PKG_CONFIG_PATH:opencv安装目录/lib/pkgconfig export PKG_CONFIG_PATH#-----------------------------------------source /etc/profile #更新环境变量 pkg-config --cflags --libs opencv #测试是否安装成功</code></pre><p>安装成功:<br><img src="/images/opencv3/2-8.png" srcset="/img/loading.gif" alt=""></p><h1 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h1><ul><li>eclipse for c/c++ 新建C/C++项目</li><li><p>添加opencv包含目录<br><img src="/images/opencv3/2-9.png" srcset="/img/loading.gif" alt=""></p></li><li><p>引入库文件 可通过pkg-config —libs opencv 命令查看库文件<br><img src="/images/opencv3/2-10.png" srcset="/img/loading.gif" alt=""></p></li><li>复制到图片到项目根路径下<br><img src="/images/opencv3/2-11.png" srcset="/img/loading.gif" alt=""></li><li>测试代码<pre><code class="lang-cpp">#include&lt;iostream&gt;#include &lt;opencv2/opencv.hpp&gt;int main(){  // 读入一张图片  cv::Mat image=cv::imread(&quot;dog.jpg&quot;);  // 在窗口中显示  cv::imshow(&quot;test&quot;,image);  // 等待6000 ms后窗口自动关闭  cv::waitKey(6000);  return 0;}</code></pre></li><li>右键项目 build project 执行编译</li><li>编译成功，右键项目执行run as local C/C++ Application<br><img src="/images/opencv3/2-12.png" srcset="/img/loading.gif" alt=""></li></ul><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>opencv3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>opencv3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译C/C++为dll供Java调用</title>
    <link href="/2019/03/10/eclipse%E7%BC%96%E8%AF%91C-C++%E4%B8%BAdll%E4%BE%9BJava%E8%B0%83%E7%94%A8/"/>
    <url>/2019/03/10/eclipse%E7%BC%96%E8%AF%91C-C++%E4%B8%BAdll%E4%BE%9BJava%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="开发环境准备"><a href="#开发环境准备" class="headerlink" title="开发环境准备"></a>开发环境准备</h1><ul><li>下载 Eclipse IDE for C/C++<br>地址:<a href="https://www.eclipse.org/downloads/packages/" target="_blank" rel="noopener">https://www.eclipse.org/downloads/packages/</a><br><img src="/images/2019/3/10/1.jpg" srcset="/img/loading.gif" alt=""></li><li>安装mingw64<br>地址:<a href="http://www.mingw-w64.org/doku.php/download" target="_blank" rel="noopener">http://www.mingw-w64.org/doku.php/download</a><br><img src="/images/2019/3/10/2.jpg" srcset="/img/loading.gif" alt=""><br>1）配置mingw64环境变量<br>C_INCLUDE_PATH : mingw64安装目录\include<br>LIBRARY_PATH :mingw64安装目录\lib<br><img src="/images/2019/3/10/3.jpg" srcset="/img/loading.gif" alt=""><br>2）系统变量的path变量中添加 mingw64安装目录\bin<br>注意:以防万一,本文也将include和lib目录也加入了path变量中<br><img src="/images/2019/3/10/4.jpg" srcset="/img/loading.gif" alt=""><br>3）测试 cmd里执行如下命令<pre><code class="lang-bash">gcc -v</code></pre>输出版本信息则安装成功<br><img src="/images/2019/3/10/5.jpg" srcset="/img/loading.gif" alt=""></li></ul><h1 id="编译C-C-为dll"><a href="#编译C-C-为dll" class="headerlink" title="编译C/C++为dll"></a>编译C/C++为dll</h1><p><strong>eclipse环境下</strong></p><ul><li>eclipse新建项目<br><img src="/images/2019/3/10/6.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/2019/3/10/7.jpg" srcset="/img/loading.gif" alt=""></li><li>新建源代码文件<br><img src="/images/2019/3/10/8.jpg" srcset="/img/loading.gif" alt=""></li><li>编写方法<br><img src="/images/2019/3/10/9.jpg" srcset="/img/loading.gif" alt=""></li><li>右键项目 properties 配置<br>1）Tool Chain Editor的配置<br><img src="/images/2019/3/10/10.jpg" srcset="/img/loading.gif" alt=""><br>2）settings的配置<br><img src="/images/2019/3/10/11.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/2019/3/10/12.jpg" srcset="/img/loading.gif" alt=""><pre><code class="lang-bash">-Wl,--add-stdcall-alias -static-libgcc -static-libstdc++ -shared</code></pre><img src="/images/2019/3/10/13.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/2019/3/10/14.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/2019/3/10/15.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/2019/3/10/16.jpg" srcset="/img/loading.gif" alt=""></li><li>右键项目 build project 执行编译<br><img src="/images/2019/3/10/17.jpg" srcset="/img/loading.gif" alt=""><br>编译成功<br><img src="/images/2019/3/10/18.jpg" srcset="/img/loading.gif" alt=""><br>在eclipse的工作目录 test项目下的debug目录可以找到编译好的dll文件<br><img src="/images/2019/3/10/19.jpg" srcset="/img/loading.gif" alt=""></li></ul><p><strong>visual studio 2015环境下</strong></p><ul><li>新建win32项目<br><img src="/images/2019/3/10/22.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/2019/3/10/23.jpg" srcset="/img/loading.gif" alt=""></li><li>新建头文件<pre><code class="lang-cpp">#pragma once#ifdef DLL_IMP#define DLL_API __declspec(dllexport) //导出函数#endif // DLL_APIextern &quot;C&quot; {  DLL_API char*   say();}</code></pre><img src="/images/2019/3/10/24.jpg" srcset="/img/loading.gif" alt=""></li><li>新建源文件<pre><code class="lang-cpp">#define DLL_IMP#include &quot;say.h&quot;#include&lt;stdio.h&gt;char*  say(){  printf(&quot;hello&quot;);  return &quot;ok&quot;;}</code></pre><img src="/images/2019/3/10/25.jpg" srcset="/img/loading.gif" alt=""></li><li>设置属性 编译为dll<br><img src="/images/2019/3/10/26.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/2019/3/10/27.jpg" srcset="/img/loading.gif" alt=""><h1 id="Java调用dll"><a href="#Java调用dll" class="headerlink" title="Java调用dll"></a>Java调用dll</h1></li><li>下载JNA jna.jar 地址:<a href="https://mvnrepository.com/artifact/com.sun.jna/jna/3.0.9" target="_blank" rel="noopener">https://mvnrepository.com/artifact/com.sun.jna/jna/3.0.9</a></li><li>新建Java项目 引入jna.jar 并将dll拷贝到项目根路径下(否则需要填写dll的绝对路径)<br><img src="/images/2019/3/10/20.jpg" srcset="/img/loading.gif" alt=""></li><li>编写调用接口类</li></ul><pre><code class="lang-java">import com.sun.jna.Library;import com.sun.jna.Native;public interface Clibrary extends Library{    //使用eclipse环境下生成的dll    Clibrary instance = (Clibrary) Native.loadLibrary(&quot;libtest&quot;, Clibrary.class);    //dll中的方法 声明需一致    void sayHello();     //使用vs 2015生成的dll    //Clibrary instance = (Clibrary) Native.loadLibrary(&quot;yolo-dll&quot;, Clibrary.class);    //String say();}</code></pre><ul><li>编写Main类 调用方法执行</li></ul><pre><code class="lang-java">public class Main {    public static void main(String[] args) {        Clibrary.instance.sayHello();    }}</code></pre><p>执行结果 如图<br><img src="/images/2019/3/10/21.jpg" srcset="/img/loading.gif" alt=""></p><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JNA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo搭建GitHub博客</title>
    <link href="/2019/03/10/hexo%E6%90%AD%E5%BB%BAGitHub%E5%8D%9A%E5%AE%A2/"/>
    <url>/2019/03/10/hexo%E6%90%AD%E5%BB%BAGitHub%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>前提环境:Node.js、Git已安装</p><h1 id="通过github创建repository-格式-博客名称-github-io"><a href="#通过github创建repository-格式-博客名称-github-io" class="headerlink" title="通过github创建repository 格式:博客名称.github.io"></a>通过github创建repository 格式:博客名称.github.io</h1><p><img src="/images/github/1.jpg" srcset="/img/loading.gif" alt=""></p><h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><ul><li>新建blog文件夹,并打开git bash<br><img src="/images/github/2.jpg" srcset="/img/loading.gif" alt=""></li><li><p>执行命令</p><pre><code class="lang-bash">npm install hexo -g #安装hexo命令hexo -v #检查是否安装成功</code></pre><p><img src="/images/github/3.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>初始化hexo</p><pre><code class="lang-bash">hexo init #初始化blog文件夹npm install #安装必要组件#执行如下命令 开启本地体验hexo ghexo s  #访问http://localhost:4000 即可看到默认博客页面</code></pre></li></ul><h1 id="关联hexo-github"><a href="#关联hexo-github" class="headerlink" title="关联hexo - github"></a>关联hexo - github</h1><ul><li>设置git的username和email<pre><code class="lang-bash">git config --global user.name &#39;jiaopan&#39; #设置用户名git config --global user.email &#39;807854982@qq.com&#39; #设置邮箱</code></pre></li><li>生成公钥<pre><code class="lang-bash">ssh-keygen -t rsa -C “807854982@qq.com”#连续按三次回车键</code></pre>红框处为密钥保存的路径<br><img src="/images/github/4.jpg" srcset="/img/loading.gif" alt=""><pre><code class="lang-bash">cd ~/.ssh #cd到密钥目录#添加密钥到ssh-agenteval &quot;$(ssh-agent -s)&quot;ssh-add ~/.ssh/id_rsa</code></pre></li><li>配置github SSH<br>登录github,在settings里添加SSH<br><img src="/images/github/5.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/github/6.jpg" srcset="/img/loading.gif" alt=""><br>将生成的id_rsa.pub内容复制到SSH key里 点击add SSH 即可<br><img src="/images/github/7.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/github/8.jpg" srcset="/img/loading.gif" alt=""><br>测试是否可连 出现用户名则成功<pre><code class="lang-bash">ssh -T git@github.com</code></pre><img src="/images/github/9.jpg" srcset="/img/loading.gif" alt=""></li><li>配置_config.yml<br><img src="/images/github/10.jpg" srcset="/img/loading.gif" alt=""><br>更改如下配置:<pre><code class="lang-bash">url:  https://jiaopaner.github.io #  repository deploy:type: gitrepo: git@github.com:JiaoPaner/jiaopaner.github.io.gitbranch: master</code></pre></li></ul><h1 id="文章发布"><a href="#文章发布" class="headerlink" title="文章发布"></a>文章发布</h1><ul><li>安装扩展<pre><code class="lang-bash">npm install hexo-deployer-git --save</code></pre></li><li>创建文章<pre><code class="lang-bash">hexo new post &#39;文章名&#39; #在blog/source/post</code></pre>在blog目录下的 source/_posts将会生成对应的MD文件.打开MD文件进行文章编辑即可<br><img src="/images/github/11.jpg" srcset="/img/loading.gif" alt=""></li><li>发布文章<pre><code class="lang-bash">hexo d -g</code></pre>成功后,访问博客地址 <a href="https://jiaopaner.github.io">https://jiaopaner.github.io</a> 即可看到</li></ul><h1 id="博客主题"><a href="#博客主题" class="headerlink" title="博客主题"></a>博客主题</h1><ul><li>通过<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a> 主题目录下载主题 </li><li>主题内有下载地址和安装方法,一般为github地址,下载其压缩包或git clone到本地</li><li>复制到blog目录下的themes内(本博客为next主题)<br><img src="/images/github/12.jpg" srcset="/img/loading.gif" alt=""></li><li><p>修改_config.yml  theme值为themes下主题目录名<br><img src="/images/github/13.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>更新即可</p><pre><code class="lang-bash">hexo d -g</code></pre></li></ul><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux下mysql的安装</title>
    <link href="/2019/03/06/linux%E4%B8%8Bmysql%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <url>/2019/03/06/linux%E4%B8%8Bmysql%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="linux下mysql安装步骤"><a href="#linux下mysql安装步骤" class="headerlink" title="linux下mysql安装步骤"></a>linux下mysql安装步骤</h1><p>1.ubuntu系统<br>1) 输入如下命令</p><pre><code class="lang-bash">sudo apt-get updatesudo apt-get install mysql-server</code></pre><blockquote><p>安装好软件包后,会弹出设置root账户密码的提示</p></blockquote><p>2) 测试是否安装成功(mysql 的socket处于 listen 状态则表示安装成功)</p><pre><code class="lang-bash">sudo netstat -tap | grep mysql</code></pre><p><img src="/images/note/6.jpg" srcset="/img/loading.gif" alt=""></p><p>3) 登陆mysql</p><pre><code class="lang-bash">sudo mysql -uroot -p #执行命令后再输入密码</code></pre><p><img src="/images/note/7.jpg" srcset="/img/loading.gif" alt=""></p><blockquote><p>登陆成功</p></blockquote><p><img src="/images/note/8.jpg" srcset="/img/loading.gif" alt=""></p><p>4) 设置mysql可远程连接</p><blockquote><p>修改配置文件</p></blockquote><pre><code class="lang-bash">sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</code></pre><blockquote><p>注释bind-address</p></blockquote><p><img src="/images/note/9.jpg" srcset="/img/loading.gif" alt=""></p><pre><code class="lang-bash">sudo mysql -uroot -p #登陆mysqlmysql&gt; show databases #查看已有的数据库mysql&gt; use mysql; #跳转到名为mysql的数据库mysql&gt; update user set host=&#39;%&#39; where user=&#39;root&#39;;# %:任意主机#给予root账户在任意主机下可访问数据库的权限mysql&gt; grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;设置的密码&#39; with grant option;mysql&gt; flush privileges;mysql&gt;exit;</code></pre><p><img src="/images/note/10.jpg" srcset="/img/loading.gif" alt=""></p><blockquote><p>重启mysql</p></blockquote><pre><code class="lang-bash">sudo service mysql</code></pre><p>2.Centos7(待更新)</p><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux下jdk安装</title>
    <link href="/2019/03/06/linux%E4%B8%8Bjdk%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <url>/2019/03/06/linux%E4%B8%8Bjdk%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="linux下JDK安装步骤"><a href="#linux下JDK安装步骤" class="headerlink" title="linux下JDK安装步骤"></a>linux下JDK安装步骤</h1><p>1.检查是否已安装JDK</p><pre><code class="lang-bash">[root@localhost ~] java -version</code></pre><p><img src="/images/note/1.jpg" srcset="/img/loading.gif" alt=""></p><blockquote><p>若默认已安装openjdk，将其卸载</p></blockquote><pre><code class="lang-bash">[root@localhost ~] yum remove *openjdk*</code></pre><p><img src="/images/note/2.jpg" srcset="/img/loading.gif" alt=""></p><p>2.安装oracle JDK1.8</p><pre><code class="lang-bash">[root@localhost ~]# cd /usr/local #跳转到local目录[root@localhost local]# mkdir jdk8 #创建jdk8目录</code></pre><blockquote><p>复制下载好的linux版JDK1.8到 /usr/local/jdk8目录</p></blockquote><p><img src="/images/note/3.jpg" srcset="/img/loading.gif" alt=""></p><blockquote><p>解压</p></blockquote><pre><code class="lang-bash">[root@localhost local]# cd jdk8[root@master jdk8]# tar -zxvf jdk-8u151-linux-x64.tar.gz</code></pre><blockquote><p>配置jdk环境变量</p></blockquote><pre><code class="lang-bash">[root@master jdk8]# vim /etc/profileexport JAVA_HOME=/usr/local/jdk8/jdk1.8.0_151export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/libexport PATH=$PATH:$JAVA_HOME/bin</code></pre><p><img src="/images/note/4.jpg" srcset="/img/loading.gif" alt=""></p><blockquote><p>环境变量生效</p></blockquote><pre><code class="lang-bash">[root@master jdk8]# source /etc/profile</code></pre><blockquote><p>检查是否安装成功</p></blockquote><pre><code class="lang-bash">[root@master jdk8]# java -version</code></pre><p><img src="/images/note/5.jpg" srcset="/img/loading.gif" alt=""></p><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jdk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode(11) ReverseWordsInAStringIII</title>
    <link href="/2018/07/26/leetcode(11)%20ReverseWordsInAStringIII/"/>
    <url>/2018/07/26/leetcode(11)%20ReverseWordsInAStringIII/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字图像处理(2) 灰度变换与空间滤波</title>
    <link href="/2018/07/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86(2)%20%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2/"/>
    <url>/2018/07/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86(2)%20%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2/</url>
    
    <content type="html"><![CDATA[<p>空间域,即包含图像像素的平面,空间域技术直接在图像像素上操作,空间域处理可由下式表示:<br>g(x,y) = T[f(x,y)]<br>其中f(x,y)为输入图像,g(x,y)为处理后的图像,T是在点(x,y)的邻域上定义的关于f的一种算子</p><h3 id="灰度变换"><a href="#灰度变换" class="headerlink" title="灰度变换"></a>灰度变换</h3><p>s = T(r)<br>s和r分别表示g和f在任意点(x,y)处的灰度</p><h4 id="灰度变换函数"><a href="#灰度变换函数" class="headerlink" title="灰度变换函数"></a>灰度变换函数</h4><ul><li>图像反转  (图像灰度级范围[0,L-1])<br>s = L - 1 -r<br>该式反转一幅图像的灰度级,可得到等效的照片底片,适用于增强嵌入在图像暗区域中的白色或灰色细节<br><img src="/images/cv/34.jpg" srcset="/img/loading.gif" alt=""></li><li>对数变换<br>s = clog(1+r) (c为常数)<br>该式将范围较窄的低灰度值映射为范围较宽的灰度值，适用于增强图像中的暗像素值<br><img src="/images/cv/35.jpg" srcset="/img/loading.gif" alt=""></li><li>幂律(伽马)变换<br>s = cr^γ (c和γ为正常数)<br>γ &lt; 1 提高灰度级，在正比函数上方，使图像变亮<br>γ &gt; 1 降低灰度级，在正比函数下方，使图像变暗<br><img src="/images/cv/36.png" srcset="/img/loading.gif" alt=""><br>γ = 0.6,0.4,0.3 | c = 1<br><img src="/images/cv/37.jpg" srcset="/img/loading.gif" alt=""><br>γ = 3,4,5 | c = 1<br><img src="/images/cv/38.jpg" srcset="/img/loading.gif" alt=""></li></ul><h4 id="分段线性变换函数"><a href="#分段线性变换函数" class="headerlink" title="分段线性变换函数"></a>分段线性变换函数</h4><ul><li><p>对比度拉伸 扩展低对比度图像灰度级动态范围<br>点(s1,r1)和点(s2,r2)的位置控制变换函数的形状<br>若r1=s1,r2=s2,则变换为线性函数,将产生无变化的灰度级<br>若r1=r2,s1=0,s2=L-1,则变换为阈值处理函数,将产生一幅二值图像<br>(s1,r1)和点(s2,r2)的中间值产生不同程度的灰度级扩展<br><img src="/images/cv/39.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>灰度级分层 突出图像中指定灰度范围的亮度<br>将感兴趣范围内的所有灰度值显示为一个值(如白色),而其他值显示为另一个值(如黑色)<br><img src="/images/cv/40.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/cv/41.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>比特平面分层<br>像素由比特组成的数字,在256级灰度图像中,每个像素由8比特组成,通过突出特定比特来增强图像<br><img src="/images/cv/42.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/cv/43.jpg" srcset="/img/loading.gif" alt=""><br>存储4个高阶比特平面允许以接受的细节重建图像<br><img src="/images/cv/44.jpg" srcset="/img/loading.gif" alt=""></p></li></ul><h3 id="直方图处理"><a href="#直方图处理" class="headerlink" title="直方图处理"></a>直方图处理</h3><p>灰度级范围为[0，L-1]数字图像直方图是离散函数h(r_k) = n_k，其中r_k是第k个灰度级(灰度值),n_k是图像中灰度级为r_k的像素个数,归一化的直方图为p(r_k) = n_k / (MN)<br><img src="/images/cv/45.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/cv/46.jpg" srcset="/img/loading.gif" alt=""><br>暗图像的直方图的分量集中在灰度级的低端,亮图像的直方图分量则倾向于灰度级的高端<br>高对比度图像直方图分量覆盖很宽的灰度级范围,且像素分布均匀,反之,低对比度图像直方图的分量覆盖较窄的灰度级范围,且像素分布不均匀<br>结论:若一幅图像倾向于占据整个可能的灰度级且分布均匀,则图像具有高对比度且灰色调具有较大变化</p><h4 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h4><p>作用:使得图像的像素占有全部可能的灰度级且分布均匀,能够具有高对比度<br>方法:灰度级变换  s = T(r)<br>T(r)满足下列两个条件：<br>（1）T(r)在区间0 ≤ r ≤ L-1中为单值且单调递增<br>（2）当 0 ≤ r ≤ L-1时,0 ≤ T(r)  ≤  L-1<br>条件(1)保证原图各灰度级在变换后仍保持从黑到白(或从白到黑)的排列次序<br>条件(2)保证变换前后灰度值动态范围的一致性<br><img src="/images/cv/51.jpg" srcset="/img/loading.gif" alt=""><br>图像的灰度级可看成是区间[0,L-1]内的随机变量,随机变量的基本描绘是其概率密度函数<br>令p_r(r)为r的概率密度函数,p_s(s)是s的概率密度函数,p_r(r)和T(r)已知,在感兴趣的值域上T(r)是连续可微的,则<br><img src="/images/cv/50.jpg" srcset="/img/loading.gif" alt=""><br>有如下变换函数T(r)<br><img src="/images/cv/47.jpg" srcset="/img/loading.gif" alt=""><br>莱布尼茨准则可得<br><img src="/images/cv/48.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/cv/49.jpg" srcset="/img/loading.gif" alt=""><br>p_s(s)为均匀概率密度函数，即证明经上述灰度变换函数T(r),得到随机变量s由均匀概率密度函数表征<br><img src="/images/cv/52.jpg" srcset="/img/loading.gif" alt=""><br>对于离散值,处理其概率(直方图值)与求和代替处理概率密度函数与积分<br>一幅数字图像中灰度级r_k出现的概率近视为<br><img src="/images/cv/53.jpg" srcset="/img/loading.gif" alt=""><br>变换函数为<br><img src="/images/cv/54.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>例子</strong><br><img src="/images/cv/55.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/cv/56.jpg" srcset="/img/loading.gif" alt=""><br>均衡后的图像中有790个像素取s0=1值,同理有1023个像素取s1=3值,….<br><img src="/images/cv/57.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="直方图规定化"><a href="#直方图规定化" class="headerlink" title="直方图规定化"></a>直方图规定化</h4><p>直方图规定化是指经过处理后的图像具有规定的直方图形状<br>令p_r(r)为输入图像估计,p_z(z)为图像所具有的指定概率密度函数<br>有如下变换函数T(r)<br><img src="/images/cv/47.jpg" srcset="/img/loading.gif" alt=""><br>定义有如下特性的随机变量z<br><img src="/images/cv/58.jpg" srcset="/img/loading.gif" alt=""><br>由G(z) = T(r)，z必须满足如下条件<br><img src="/images/cv/59.jpg" srcset="/img/loading.gif" alt=""><br>由一幅给定图像得到一幅其灰度级具有指定概率密度函数图像的步骤:<br>1.有输入图像得到p_r(r)，并由T(r)求得s值<br>2.由指定的PDF求得G(z)<br>3.求得G(z)的反函数z = G^{-1}(s)<br>4.利用T(r)对输入图像进行均衡得到输出图像,对均衡后的图像中具有s值的每个像素<br>   执行反函数z = G^{-1}(s)<br>对于离散值:<br><img src="/images/cv/54.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/cv/60.jpg" srcset="/img/loading.gif" alt=""><br>对一个q值:<br><img src="/images/cv/61.jpg" srcset="/img/loading.gif" alt=""><br>反函数为:<br><img src="/images/cv/62.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>例子</strong><br><img src="/images/cv/55.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/cv/63.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/cv/64.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/cv/65.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/cv/66.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/cv/67.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="空间滤波"><a href="#空间滤波" class="headerlink" title="空间滤波"></a>空间滤波</h3><p>空间滤波器由一个邻域(较小的矩形)和对该邻域包围的图像像素执行预定义操作组成,滤波产生一个新像素,新像素的坐标等于邻域中心的坐标,像素值是滤波操作的结果.滤波器在图像上执行的是线性操作则称为线性空间滤波器,否则称为非线性空间滤波器.<br>例如,如下3 x 3领域的线性空间滤波器的处理机理，在图像中任意一点(x,y),滤波器的响应g(x,y)是滤波器系数与该滤波器包围的图像像素的乘积之和:<br><img src="/images/cv/68.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/cv/69.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="空间相关与卷积"><a href="#空间相关与卷积" class="headerlink" title="空间相关与卷积"></a>空间相关与卷积</h4><p>相关是滤波器模板移过图像并计算每个位置乘积之和的处理,卷积的机理类似,但其滤波器首先要旋转180°<br>如下,显示了一个一维图像函数和一个一维滤波器,执行操作时,存在未覆盖的的部分函数,若滤波器的尺寸为m，则在需要在f的一侧补m-1个0<br><img src="/images/cv/70.jpg" srcset="/img/loading.gif" alt=""><br>二维图像函数和二维滤波器<br><img src="/images/cv/71.jpg" srcset="/img/loading.gif" alt=""><br><strong>总结</strong><br>大小为m x n的滤波器和一幅图像f(x,y)做相关操作,可表示为:<br>a = (m-1)/2,b = (n-1)/2 ，为表示方便,假设m和n是奇整数<br><img src="/images/cv/72.jpg" srcset="/img/loading.gif" alt=""><br>类似地，卷积表示为:<br><img src="/images/cv/73.jpg" srcset="/img/loading.gif" alt=""></p><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>数字图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode(10) Binary Gap</title>
    <link href="/2018/07/18/leetcode(10)%20Binary%20Gap/"/>
    <url>/2018/07/18/leetcode(10)%20Binary%20Gap/</url>
    
    <content type="html"><![CDATA[<p>difficult：easy #868<br>Given a positive integer N, find and return the longest distance between two consecutive 1’s in the binary representation of N.<br>If there aren’t two consecutive 1’s, return 0.</p><p>Example 1:</p><pre><code class="lang-cpp">Input: 22Output: 2</code></pre><p>Explanation:<br>22 in binary is 0b10110.<br>In the binary representation of 22, there are three ones, and two consecutive pairs of 1’s.<br>The first consecutive pair of 1’s have distance 2.<br>The second consecutive pair of 1’s have distance 1.<br>The answer is the largest of these two distances, which is 2.</p><p>Example 2:</p><pre><code class="lang-cpp">Input: 5Output: 2</code></pre><p>Explanation:<br>5 in binary is 0b101.</p><p>Example 3:</p><pre><code class="lang-cpp">Input: 6Output: 1</code></pre><p>Explanation:<br>6 in binary is 0b110.</p><p>Example 4:</p><pre><code class="lang-cpp">Input: 8Output: 0</code></pre><p>Explanation:<br>8 in binary is 0b1000.<br>There aren’t any consecutive pairs of 1’s in the binary representation of 8, so we return 0.<br>Note:1 &lt;= N &lt;= 10^9</p><p><strong>解法一:</strong></p><pre><code class="lang-cpp">#include&lt;vector&gt;int binaryGap(int N) {    int distance = 0;    std::vector&lt;int&gt; index;    for (int i = 1; N != 0;i++) {        if (N % 2 != 0)            index.push_back(i);        N = N &gt;&gt; 1;    }    for(int i = 0;i &lt; index.size()-1;i++){        int max = index[i + 1] - index[i];        if (max &gt; distance)            distance = max;    }    return distance;}</code></pre><p><strong>解法二:</strong></p><pre><code class="lang-cpp">int binaryGap(int N) {    int last = -1,distance = 0;    for (int i = 1; N != 0; i++) {        if (N % 2 != 0) {            if (last &gt; 0)                distance = (i - last) &gt; distance ? (i - last) : distance;            last = i;        }        N = N &gt;&gt; 1;    }    return distance;}</code></pre><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode(9) Array Partition I</title>
    <link href="/2018/07/18/leetcode(9)%20Array%20Partition%20I/"/>
    <url>/2018/07/18/leetcode(9)%20Array%20Partition%20I/</url>
    
    <content type="html"><![CDATA[<p>difficult：easy #561<br>Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.</p><p>Example 1:<br>Input: [1,4,3,2]</p><p>Output: 4<br>Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).<br>Note:<br>n is a positive integer, which is in the range of [1, 10000].<br>All the integers in the array will be in the range of [-10000, 10000].</p><p><strong>解法:</strong></p><pre><code class="lang-cpp">#include&lt;vector&gt;void quicksort(std::vector&lt;int&gt; &amp; array, int left, int right);int arrayPairSum(std::vector&lt;int&gt;&amp; nums) {    int result = 0;    quicksort(nums, 0, nums.size() - 1);    for (int i = 0; i &lt; nums.size(); i += 2) {        result += nums[i];    }    return result;}void quicksort(std::vector&lt;int&gt; &amp; array, int left, int right){    int i, j, t, temp;    if (left &gt; right)        return;    temp = array[left];    i = left;    j = right;    while (i != j){        while (array[j] &gt;= temp &amp;&amp; i &lt; j)            j--;        while (array[i] &lt;= temp &amp;&amp; i &lt; j)            i++;        if (i&lt;j) {            t = array[i];            array[i] = array[j];            array[j] = t;        }    }    array[left] = array[i];    array[i] = temp;    quicksort(array, left, i - 1);    quicksort(array, i + 1, right);}</code></pre><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode(8) SelfDividingNumbers</title>
    <link href="/2018/07/16/leetcode(8)%20SelfDividingNumbers/"/>
    <url>/2018/07/16/leetcode(8)%20SelfDividingNumbers/</url>
    
    <content type="html"><![CDATA[<p>difficult：easy #728<br>A self-dividing number is a number that is divisible by every digit it contains.<br>For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.<br>Also, a self-dividing number is not allowed to contain the digit zero.<br>Given a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.</p><p>Example :</p><pre><code class="lang-cpp">Input: left = 1, right = 22Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]</code></pre><p>Note:<br>The boundaries of each input argument are 1 &lt;= left &lt;= right &lt;= 10000</p><p><strong>解法一：</strong></p><pre><code class="lang-cpp">#include&lt;vector&gt;std::vector&lt;int&gt; selfDividingNumbers(int left, int right) {    std::vector&lt;int&gt; result;    while (left &lt;= right){        int x = left;        bool flag = true;        while (x != 0 &amp;&amp; flag){            int pos = x % 10;            if (pos == 0){                flag = false;                break;            }            if (left % pos != 0) {                flag = false;            }            x = x / 10;        }        if (flag)            result.push_back(left);        left++;    }    return result;}</code></pre><p><strong>解法二:</strong></p><pre><code class="lang-cpp">#include&lt;vector&gt;#include&lt;sstream&gt;#include &lt;string&gt;std::vector&lt;int&gt; selfDividingNumbers(int left, int right) {    std::vector&lt;int&gt; result;    while (left &lt;= right) {        std::string str;        std::stringstream buf;        buf &lt;&lt; left;        buf &gt;&gt; str;        bool flag = true;        for(char c : str){            if (c == &#39;0&#39; || left % (c - &#39;0&#39;) &gt; 0){                flag = false;                break;            }        }        if (flag){            result.push_back(left);        }        left++;    }    return result;}</code></pre><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字图像处理(1) 图像基础</title>
    <link href="/2018/07/13/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86(1)%20%E5%9B%BE%E5%83%8F%E5%9F%BA%E7%A1%80/"/>
    <url>/2018/07/13/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86(1)%20%E5%9B%BE%E5%83%8F%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="图像采样和量化"><a href="#图像采样和量化" class="headerlink" title="图像采样和量化"></a>图像采样和量化</h3><p><img src="/images/cv/6.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="图像采样"><a href="#图像采样" class="headerlink" title="图像采样"></a>图像采样</h4><p>数字化坐标值称为采样,对二维空间中连续的图像在水平和垂直方向上等间距地分割成矩形网状结构，所形成的微小方格称为像素点,小方格中的值由灰度值(方格区域亮度的平均值)表示,采样的实质就是用多少个像素点来描述一幅图像.<br>采样时，若横向的像素数(列数)为M,纵向的像素数(行数)为N,则图像总像素数为M*N个像素；</p><p>采样间隔越大，即行列数少,则图像像素数越少，空间分辨率低，质量差，严重时出现马赛克效应；<br>采样间隔越小，即行列数大,则图像像素数越多，空间分辨率高，图像质量好，数据量大；<br>如下图,上述采样点分别为a:1024x1024 , b:512x512 , c:256x256 , d:128x128 , e:64x64, f:32x32<br><img src="/images/cv/1.png" srcset="/img/loading.gif" alt=""></p><p>采样过程:<br><img src="/images/cv/2.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/cv/4.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="图像量化"><a href="#图像量化" class="headerlink" title="图像量化"></a>图像量化</h4><p>采样后所得各像素的灰度模拟量到离散量的转换为图像灰度量化<br>像素灰度级/灰度值/灰度:表示像素明暗程度的整数<br>灰度级数:数字图像中不同灰度值的个数(G）<br>若连续的灰度值用<script type="math/tex">z</script>表示,则满足于z<em>{i} &lt; z &lt; z</em>{i+1} 的z值都量化为整数值z<em>{i}，z</em>{i}称为像素灰度值<br>量化后的的灰度值用比特位数(g:存储图像灰度值所需的比特位数)表示,即$G=2^{g}$,如黑-灰-白的连续变化灰度值,用8位比特量化则为0~255个灰度值,代表相应的浓淡程度<br><img src="/images/cv/5.jpg" srcset="/img/loading.gif" alt=""><br>图像的数据量 = M x N x G bit</p><p>数字图像根据灰度级数的差异可分为黑白图像、灰度图像、彩色图像</p><ul><li>黑白图像<br>图像的每个灰度值/像素只能是黑或白,无中间值的过渡,故称二值图,灰度级数为2,灰度值为0或1<br><img src="/images/cv/7.jpg" srcset="/img/loading.gif" alt=""></li><li>灰度图像<br>图像的灰度级数大于2,但不包含彩色信息<br><img src="/images/cv/8.jpg" srcset="/img/loading.gif" alt=""></li><li>彩色图像<br>每个灰度值由R、G、B分量构成,其中R、G、B由不同的灰度值来描述<br><img src="/images/cv/9.jpg" srcset="/img/loading.gif" alt=""></li></ul><p>量化等级越高,图像层次越丰富图像质量越好,反之图像质量差,如下图,量化等级依次递减所得的图像<br><img src="/images/cv/11.jpg" srcset="/img/loading.gif" alt=""></p><hr><h3 id="数字图像表示"><a href="#数字图像表示" class="headerlink" title="数字图像表示"></a>数字图像表示</h3><p>一幅M×N的图像可以表示为矩阵,矩阵中的每个元素为图像的灰度值(像素值)<br><img src="/images/cv/10.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="空间和灰度分辨率"><a href="#空间和灰度分辨率" class="headerlink" title="空间和灰度分辨率"></a>空间和灰度分辨率</h3><p>空间分辨率是图像中可辨别最小细节的度量,其中每单位距离线对数和每单位距离点数(像素数)是最通用的度量 —— 采样程度<br>灰度分辨率是指在灰度级中可分辨的最小变化 —— 量化程度</p><h3 id="图像内插"><a href="#图像内插" class="headerlink" title="图像内插"></a>图像内插</h3><p>图像内插是在诸如放大、收缩、旋转和几何校正等任务中广泛应用的工具<br>从根本上看,内插是用已知数据来估计未知位置数值的处理<br>源图像大小为M * N,目标图像为A * B,则两幅图像的边长比分别为:M/A和N/B,目标图像(i,j)像素可通过边长比对应回源图像,其对应坐标为(i * M / A,j * N / B)，显然,对应的坐标一般不是整数，而非整数的坐标无法在图像上使用.</p><h4 id="最近邻内插法"><a href="#最近邻内插法" class="headerlink" title="最近邻内插法"></a>最近邻内插法</h4><p>假设一幅500x500的图像放大1.5倍到750x750，创建一个750x750的网格,其与原图有相同的间隔,然后将其收缩,使它准确地与原图匹配,显然收缩后的750x750网格的像素间隔小于原图的像素间隔,为了覆盖的每一个点赋以灰度值,因此在原图中寻找最接近的像素,并把该像素的灰度值赋给750x750网格中的新像素,完成像素的赋值后,再将图像扩展到规定的大小.<br>蓝色为原图网格,红色为放大后的网格<br><img src="/images/cv/12.jpg" srcset="/img/loading.gif" alt=""><br>取最近的像素灰度值赋值给新像素<br><img src="/images/cv/13.jpg" srcset="/img/loading.gif" alt=""></p><p>C++代码实现</p><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;opencv2\opencv.hpp&gt;using namespace cv;int main() {    Mat src = imread(&quot;D:/learn/jiaopan/source/images/opencv3/blob.jpg&quot;);//原图    imshow(&quot;src&quot;, src);    std::cout &lt;&lt; src.rows;    //创建网格矩阵    Mat dst = Mat::zeros(Size(750, 750), CV_8UC3);    //放大比例    double fRows = 750 / (float)src.rows;    double fCols = 750 / (float)src.cols;    int primaryX = 0, primaryY = 0;    //最近邻内插法    for (int i = 0; i != dst.rows; i++) {        for (int j = 0; j != dst.cols; j++){            primaryX = cvRound(i / (double)fRows);            primaryY = cvRound(j / (double)fCols);            if (primaryX &lt; src.rows &amp;&amp; primaryX &gt;= 0 &amp;&amp; primaryY &gt;= 0 &amp;&amp; primaryY &lt; src.cols){                dst.at&lt;cv::Vec3b&gt;(i, j)[0] = src.at&lt;cv::Vec3b&gt;(primaryX, primaryY)[0];                dst.at&lt;cv::Vec3b&gt;(i, j)[1] = src.at&lt;cv::Vec3b&gt;(primaryX, primaryY)[1];                dst.at&lt;cv::Vec3b&gt;(i, j)[2] = src.at&lt;cv::Vec3b&gt;(primaryX, primaryY)[2];            }        }    }    imshow(&quot;dst&quot;, dst);    waitKey(0);    return 0;}</code></pre><p><img src="/images/cv/14.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="双线性插值"><a href="#双线性插值" class="headerlink" title="双线性插值"></a>双线性插值</h4><p>双线性插值通过寻找距离对应坐标最近的四个像素点计算该点灰度值或者RGB值,如对应坐标是(2.5,4.5)，则最近的四个像素为 (2,4) , (2,5) , (3,4) , (3,5).<br>如图，已知Q11  (x1, y1), Q12  (x1, y2), Q21 (x2, y1),  Q22  (x2, y2)，插值的点为P点<br><img src="/images/cv/15.png" srcset="/img/loading.gif" alt=""><br>X方向<br><img src="/images/cv/16.svg" srcset="/img/loading.gif" alt=""><br>Y方向<br><img src="/images/cv/18.svg" srcset="/img/loading.gif" alt=""><br>先在 x 方向插值，再在 y 方向插值，其结果与按照上述顺序双线性插值的结果一致<br>若四个已知点坐标分别为 (0, 0)、(0, 1)、(1, 0) 和 (1, 1)，插值公式可化简为<br><img src="/images/cv/19.svg" srcset="/img/loading.gif" alt=""><br>其矩阵运算公式为<br><img src="/images/cv/20.svg" srcset="/img/loading.gif" alt=""></p><p>双线性插值的结果不是线性的，它是两个线性函数的积，在单位正方形上，双线性插值可以记作<br><img src="/images/cv/22.svg" srcset="/img/loading.gif" alt=""><br><img src="/images/cv/23.jpg" srcset="/img/loading.gif" alt=""><br>一般情况:<br><img src="/images/cv/21.png" srcset="/img/loading.gif" alt=""></p><p>代码实现</p><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;opencv2\opencv.hpp&gt;using namespace cv;int main() {    Mat src = imread(&quot;D:/learn/jiaopan/source/images/opencv3/blob.jpg&quot;);//原图    imshow(&quot;src&quot;, src);    //创建网格矩阵    Mat dst = Mat::zeros(Size(750, 750), CV_8UC3);    //放大比例    double fRows = 750 / (float)src.rows;    double fCols = 750 / (float)src.cols;    int primaryX = 0, primaryY = 0;    //双线性插值    float m = 0;    float n = 0;    CvScalar a, b, c, d;    for (int i = 0; i != dst.rows; i++) {        for (int j = 0; j != dst.rows; j++) {            m = cvRound(i / (double)fRows);            n = cvRound(j / (double)fCols);            double ux = m - (int)m;            double uy = n - (int)n;            if (m &gt;= 0 &amp;&amp; m &lt;= src.rows - 1 &amp;&amp; n &gt;= 0 &amp;&amp; n &lt;= src.cols - 1) {                a = src.at&lt;cv::Vec3b&gt;((int)m, (int)n);                b = src.at&lt;cv::Vec3b&gt;((int)m, (int)n + 1) - src.at&lt;cv::Vec3b&gt;((int)m, (int)n);                c = src.at&lt;cv::Vec3b&gt;((int)m + 1, (int)n) - src.at&lt;cv::Vec3b&gt;((int)m, (int)n);                d = src.at&lt;cv::Vec3b&gt;((int)m + 1, (int)n + 1) - src.at&lt;cv::Vec3b&gt;((int)m + 1, (int)n) - src.at&lt;cv::Vec3b&gt;((int)m, (int)n + 1) + src.at&lt;cv::Vec3b&gt;((int)m, (int)n);                b.val[0] = b.val[0] * uy;                b.val[1] = b.val[1] * uy;                b.val[2] = b.val[2] * uy;                c.val[0] = c.val[0] * ux;                c.val[1] = c.val[1] * ux;                c.val[2] = c.val[2] * ux;                d.val[0] = d.val[0] * ux*uy;                d.val[1] = d.val[1] * ux*uy;                d.val[2] = d.val[2] * ux*uy;            }            dst.at&lt;cv::Vec3b&gt;(i, j)[0] = (int)(a.val[0] + b.val[0] + c.val[0] + d.val[0]);            dst.at&lt;cv::Vec3b&gt;(i, j)[1] = (int)(a.val[1] + b.val[1] + c.val[1] + d.val[1]);            dst.at&lt;cv::Vec3b&gt;(i, j)[2] = (int)(a.val[2] + b.val[2] + c.val[2] + d.val[2]);        }    }    imshow(&quot;dst&quot;, dst);    waitKey(0);    return 0;}</code></pre><p><img src="/images/cv/24.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="双三次内插"><a href="#双三次内插" class="headerlink" title="双三次内插"></a>双三次内插</h4><p>双三次内插包括16个最近邻点,在保持细节方面比双线性内插更好<br><img src="/images/cv/27.png" srcset="/img/loading.gif" alt=""><br><a href="https://en.wikipedia.org/wiki/Bicubic_interpolation" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bicubic_interpolation</a></p><h3 id="像素间的基本关系"><a href="#像素间的基本关系" class="headerlink" title="像素间的基本关系"></a>像素间的基本关系</h3><h4 id="相邻像素"><a href="#相邻像素" class="headerlink" title="相邻像素"></a>相邻像素</h4><p>位于坐标(x,y)处的像素p有4个水平和垂直的相邻像素(4邻域 N4(p)),其坐标公式如下</p><pre><code class="lang-cpp">(x+1,y),(x-1,y),(x,y+1),(x,y-1)</code></pre><p>p的4个对角相邻像素(对角邻域)的坐标公式如下:</p><pre><code class="lang-cpp">(x+1,y+1),(x+1,y-1),(x-1,y+1),(x-1,y-1)</code></pre><h4 id="邻接性"><a href="#邻接性" class="headerlink" title="邻接性"></a>邻接性</h4><p>令V是用于定义邻接性的灰度值集合,在二值图像中,把具有1值的像素归为邻接像素,则V = {1}<br><img src="/images/cv/28.png" srcset="/img/loading.gif" alt=""><br>4邻接:若q在集合N4(p)中，则具有V中数值(1)的两个像素p和q是4邻接<br>8邻接:若q在集合N8(p)中，则具有V中数值(1)的两个像素p和q是8邻接(8邻域=4邻域+对角邻域）<br>m邻接:若q在N4(p)中，或者在ND(p)中，且集合N4(p) ∩ N4(q) 没有V中数值(1)的像素，则具有V中数值的两个像素p和q是m邻接的</p><h4 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a>距离度量</h4><p>对于像素p、q和z，分别具有坐标(x,y)，(s,t)和(u,v)，若<br>(1) D(p,q) ≥ 0 (D(p,q)=0，当且仅当p =q)<br>(2) D(p,q) = D(q,p)<br>(3) D(p,z) ≤ D(p,q) + D(q,z)<br>则称D是距离函数或度量</p><h5 id="欧式距离"><a href="#欧式距离" class="headerlink" title="欧式距离"></a>欧式距离</h5><p><img src="/images/cv/29.jpg" srcset="/img/loading.gif" alt=""><br>距离点(x,y)的距离小于或等于某个值r的像素点是在圆心为(x,y)且半径为r的圆平面内</p><h5 id="城市距离"><a href="#城市距离" class="headerlink" title="城市距离"></a>城市距离</h5><p><img src="/images/cv/30.jpg" srcset="/img/loading.gif" alt=""><br>距离点(x,y)的距离小于或等于某个值r的像素点形成一个中心为(x,y)的菱形<br>如图,与点(x,y)的距离小于或等于2的像素<br><img src="/images/cv/31.jpg" srcset="/img/loading.gif" alt=""></p><h5 id="棋盘距离"><a href="#棋盘距离" class="headerlink" title="棋盘距离"></a>棋盘距离</h5><p><img src="/images/cv/32.jpg" srcset="/img/loading.gif" alt=""><br>距离点(x,y)的距离小于或等于某个值r的像素点形成一个中心为(x,y)的方形<br>如图,与点(x,y)的距离小于或等于2的像素<br><img src="/images/cv/33.jpg" srcset="/img/loading.gif" alt=""></p><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>数字图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>blob detect</title>
    <link href="/2018/07/12/blob%20detect/"/>
    <url>/2018/07/12/blob%20detect/</url>
    
    <content type="html"><![CDATA[<h3 id="斑点检测"><a href="#斑点检测" class="headerlink" title="斑点检测"></a>斑点检测</h3><p>斑点:与周围区域存在颜色差异或灰度差异的区域<br>斑点检测的主要思路是检测出图像中比周围像素灰度大或者比周围区域灰度值小的区域<br>　　1.基于求导的微分方法<br>　　2.基于局部极值的分水岭算法,基于此OPENCV中提供simpleBlobDetector特征检测器</p><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;opencv2\opencv.hpp&gt;using namespace cv;int main() {    Mat im = imread(&quot;D:/learn/jiaopan/source/images/opencv3/blob.jpg&quot;,IMREAD_GRAYSCALE);    imshow(&quot;im&quot;, im);    Ptr&lt;SimpleBlobDetector&gt; detector = SimpleBlobDetector::create();    std::vector&lt;KeyPoint&gt; keypoints;    detector-&gt;detect(im, keypoints);    Mat im_with_keypoints;    drawKeypoints(im, keypoints, im_with_keypoints, Scalar(0, 255, 0), DrawMatchesFlags::DRAW_RICH_KEYPOINTS);    imshow(&quot;keypoints&quot;, im_with_keypoints);    waitKey(0);    return 0;}</code></pre><p>原图<br><img src="/images/opencv3/blob.jpg" srcset="/img/loading.gif" alt=""><br>灰度图<br><img src="/images/opencv3/blob2.jpg" srcset="/img/loading.gif" alt=""><br>斑点检测图<br><img src="/images/opencv3/blob3.jpg" srcset="/img/loading.gif" alt=""></p><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>opencv3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>opencv samples</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode(7) PeakIndexInMountainArray</title>
    <link href="/2018/07/12/leetcode(7)%20PeakIndexInMountainArray/"/>
    <url>/2018/07/12/leetcode(7)%20PeakIndexInMountainArray/</url>
    
    <content type="html"><![CDATA[<p>difficult：easy #852<br>Let’s call an array A a mountain if the following properties hold:</p><ul><li>A.length &gt;= 3</li><li>There exists some 0 &lt; i &lt; A.length - 1 such that A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]<br>Given an array that is definitely a mountain, return any i such that A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1].</li></ul><pre><code class="lang-cpp">Example 1:Input: [0,1,0]Output: 1Example 2:Input: [0,2,1,0]Output: 1</code></pre><p>Note:<br>3 &lt;= A.length &lt;= 10000<br>0 &lt;= A[i] &lt;= 10^6<br>A is a mountain, as defined above.</p><p><strong>解法一:</strong></p><pre><code class="lang-cpp">#include&lt;vector&gt;int peakIndexInMountainArray(std::vector&lt;int&gt;&amp; A) {    int start = (A.size() - 1) / 2;    while (start != 0 || start != A.size() - 1) {        if (A[start - 1] &lt; A[start] &amp;&amp; A[start] &lt; A[start + 1])            start++;        else if (A[start - 1] &gt; A[start] &amp;&amp; A[start] &gt; A[start + 1])            start--;        else if (A[start - 1] &lt;= A[start] &amp;&amp; A[start] &gt;= A[start + 1])            return start;    }}</code></pre><p><strong>解法二(二分查找):</strong></p><pre><code class="lang-cpp">int peakIndexInMountainArray(std::vector&lt;int&gt;&amp; A) {    int start = 0, end = A.size() - 1;    while (start &lt; end){        int mid = start +(end-start) / 2;        if (A[mid] &lt; A[mid + 1])            start = mid + 1;        else            end = mid;    }    return start;}</code></pre><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode(6)  JudgeRouteCircle</title>
    <link href="/2018/07/11/leetcode(6)%20%20JudgeRouteCircle/"/>
    <url>/2018/07/11/leetcode(6)%20%20JudgeRouteCircle/</url>
    
    <content type="html"><![CDATA[<p>difficult：easy #657<br>Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place.</p><p>The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle.</p><p>Example 1:</p><pre><code class="lang-cpp">Input: &quot;UD&quot;Output: true</code></pre><p>Example 2:</p><pre><code class="lang-cpp">Input: &quot;LL&quot;Output: false</code></pre><p><strong>解法一：</strong></p><pre><code class="lang-cpp">#include&lt;string&gt;#include&lt;map&gt;bool judgeCircle(std::string moves) {    std::map&lt;char, int&gt; action = { {&#39;R&#39;,0},{&#39;L&#39;,0},{&#39;U&#39;,0},{&#39;D&#39;,0} };    for (int i = 0; i &lt; moves.size(); i++) {        action[moves[i]]++;    }    return action[&#39;R&#39;] == action[&#39;L&#39;] &amp;&amp; action[&#39;U&#39;] == action[&#39;D&#39;];}</code></pre><p><strong>解法二：</strong></p><pre><code class="lang-cpp">#include&lt;string&gt;#include&lt;map&gt;bool judgeCircle(std::string moves) {    int x = 0, y = 0;    for (char move:moves) {        if (move == &#39;U&#39;) y--;        else if (move == &#39;D&#39;) y++;        else if (move == &#39;R&#39;) x--;        else if (move == &#39;L&#39;) x++;    }    return x == 0 &amp;&amp; y == 0;}</code></pre><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>opencv3(3) opencv数据类型</title>
    <link href="/2018/07/10/opencv3(3)%20opencv%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2018/07/10/opencv3(3)%20opencv%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><ul><li>Point 坐标类<br>Point有两种,2维Point和3维Point，Point可以转换为其他数据类型,比如vector或者matrix<br><img src="/images/opencv3/22.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"></li><li>Scala<br>Scalar继承于vector<br>Scalar(b, g, r) ：b-&gt;蓝色分量 g-&gt;绿色分量 r-&gt;红色分量<br>Scalar(0, 0, 255) -&gt; 红色像素点<br><img src="/images/opencv3/23.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"></li><li>Size 大小类<br>Size和Point类似,两者可以互相转换,不同之处在于Point的数据成员名为x和y,Size的数据成员名为width和height<br><img src="/images/opencv3/24.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"></li><li>Rect 矩形类<br>Rect成员包含Point类型的x,y和Size类型的width,height<br><img src="/images/opencv3/25.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"></li><li>RotatedRect 旋转矩形类<br>RotatedRect包含中心点(Point),大小(Size),旋转角度<br><img src="/images/opencv3/26.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"></li><li>InputArray OutputArray<br>InputArray和OutputArray区别在于 InputArray为只读,上述基础数据类型都可转换为 InputArray或OutputArray,以此保持函数的简洁性<h3 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h3><img src="/images/opencv3/27.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"><br><img src="/images/opencv3/28.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"></li><li>cv::alignPtr() 指针对齐<pre><code class="lang-cpp">// Return aligned pointer of type T*template&lt;T&gt; T* cv::alignPtr( T* ptr, // pointer, unaligned                                               int n = sizeof(T)); // align to block size, a power of 2</code></pre></li><li>cv::allocate() 分配具有T类型的对象数组(C风格）<pre><code class="lang-cpp">// Return pointer to allocated buffertemplate&lt;T&gt; T* cv::allocate( size_t sz); // buffer size, multiples of sizeof(T)</code></pre></li><li>cv::fastAtan2() 计算向量方向 x(向量的x坐标) y(向量的y坐标)<pre><code class="lang-cpp">float cv::fastAtan2(float y, float x );</code></pre></li><li>cvCeil() 返回不小于x的最小整数值<pre><code class="lang-cpp">int cvCeil(float x);</code></pre></li><li>cvRound() 返回与x最接近的整数值<pre><code class="lang-cpp">int cvRound( double x );</code></pre></li><li>cvFloor() 返回不大于x的最大整数值<pre><code class="lang-cpp">int cvFloor( float x};</code></pre></li><li>cv::cubeRoot() 计算x的立方根<pre><code class="lang-cpp">float cv::cubeRoot( float x);</code></pre></li><li>cv::format() 格式化输出<pre><code class="lang-cpp">string cv::format(const char* fmt, ... );</code></pre></li></ul><hr><h3 id="帮助类"><a href="#帮助类" class="headerlink" title="帮助类"></a>帮助类</h3><ul><li>TermCriteria 算法终止条件类<br>TermCriteria( int type, int maxCount, double epsilon) 类型 迭代次数 超参数</li><li>Range 整数序列<br>Range(0,4) —-&gt; 0,1,2,3</li></ul><hr><h3 id="Mat-N维稠密矩阵"><a href="#Mat-N维稠密矩阵" class="headerlink" title="Mat N维稠密矩阵"></a>Mat N维稠密矩阵</h3><h4 id="构造矩阵"><a href="#构造矩阵" class="headerlink" title="构造矩阵"></a>构造矩阵</h4><pre><code class="lang-cpp">Mat();Mat(int rows, int cols, int type);Mat(Size size, int type);Mat(int rows, int cols, int type, const Scalar&amp; s);Mat(Size size, int type, const Scalar&amp; s);Mat(int ndims, const int* sizes, int type);Mat(int ndims, const int* sizes, int type, const Scalar&amp; s);Mat(const Mat&amp; m);Mat(const Mat&amp; m, const Rect&amp; roi);Mat(const Mat&amp; m, const Range* ranges);</code></pre><p>int rows, int cols:二维矩阵的行列数 -&gt;图像分辨率<br>int type：存储元素的数据类型和通道数 CV_[位数][是否带符号][类型前缀]C[通道数]<br>const Scalar&amp; s:矩阵每个元素以s向量(颜色)填充 向量维度由通道数决定</p><pre><code class="lang-cpp">Mat matrix(2, 2, CV_8UC3, Scalar(0, 0, 255));Mat matrix(2, 2, CV_8UC2, Scalar(1,2));</code></pre><p>matrix = [  0,   0, 255,   0,   0, 255 ;  0,   0, 255,   0,   0, 255]<br>matrix = [  1,   2,   1,   2 ; 1,   2,   1,   2]</p><pre><code class="lang-cpp">Mat m；m.create(3,10,CV_32FC3)m.setTo(Scalar(1.0f,1.0f,1.0f));//设置第一个通道的值</code></pre><pre><code class="lang-cpp">Mat matrix = Mat::eye(4, 4, CV_64F);Mat matrix = Mat::ones(4, 4, CV_32F);Mat matrix = Mat::zeros(3, 3, CV_8SC1);</code></pre><p>[1, 0, 0, 0;<br> 0, 1, 0, 0;<br> 0, 0, 1, 0;<br> 0, 0, 0, 1]<br>[1, 1, 1, 1;<br> 1, 1, 1, 1;<br> 1, 1, 1, 1;<br> 1, 1, 1, 1]<br>[  0,   0,   0;<br>0,   0,   0;<br>0,   0,   0]</p><pre><code class="lang-cpp">Mat matrix = (Mat_&lt;double&gt;(3, 3) &lt;&lt; 1, 2, 3, 4, 5, 6, 7, 8, 9);</code></pre><p>[1, 2, 3;<br> 4, 5, 6;<br> 7, 8, 9]</p><p>利用clone() 或者 copyTo()</p><pre><code class="lang-cpp">Mat RowClone = matrix.row(1).clone();cout &lt;&lt; &quot;RowClone = &quot; &lt;&lt; endl &lt;&lt; &quot; &quot; &lt;&lt; RowClone &lt;&lt; endl &lt;&lt; endl;</code></pre><h4 id="获取矩阵元素"><a href="#获取矩阵元素" class="headerlink" title="获取矩阵元素"></a>获取矩阵元素</h4><p><img src="/images/opencv3/29.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/opencv3/30.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h4><p><img src="/images/opencv3/31.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="矩阵操作"><a href="#矩阵操作" class="headerlink" title="矩阵操作"></a>矩阵操作</h4><p><img src="/images/opencv3/32.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/opencv3/33.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="打印矩阵"><a href="#打印矩阵" class="headerlink" title="打印矩阵"></a>打印矩阵</h4><pre><code class="lang-cpp">Mat matrix(2,2, CV_8UC3, Scalar(0,0,255));</code></pre><p>默认风格</p><pre><code class="lang-cpp">std::cout &lt;&lt; matrix &lt;&lt; std::endl;</code></pre><p>[  0,   0, 255,   0,   0, 255;<br>   0,   0, 255,   0,   0, 255]</p><p>Python风格</p><pre><code class="lang-cpp">std::cout &lt;&lt; format(matrix,Formatter::FMT_PYTHON) &lt;&lt; std::endl;</code></pre><p>[[[  0,   0, 255],<br>  [  0,   0, 255]],<br> [[  0,   0, 255],<br>  [  0,   0, 255]]]</p><p>Numpy风格</p><pre><code class="lang-cpp">std::cout &lt;&lt; format(matrix, Formatter::FMT_NUMPY) &lt;&lt; std::endl;</code></pre><p>array([[[  0,   0, 255], [  0,   0, 255], [  0,   0, 255]],<br>       [[  0,   0, 255], [  0,   0, 255], [  0,   0, 255]],<br>       [[  0,   0, 255], [  0,   0, 255], [  0,   0, 255]]], dtype=’uint8’)</p><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>opencv3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>opencv3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode(5)  HammingDistance</title>
    <link href="/2018/07/10/leetcode(5)%20%20HammingDistance/"/>
    <url>/2018/07/10/leetcode(5)%20%20HammingDistance/</url>
    
    <content type="html"><![CDATA[<p>difficult：easy #461</p><p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p><p>Given two integers x and y, calculate the Hamming distance.</p><p>Example:</p><pre><code class="lang-cpp">Input: x = 1, y = 4Output: 2Explanation:1   (0 0 0 1)4   (0 1 0 0)       ↑    ↑</code></pre><p>The above arrows point to positions where the corresponding bits are different.<br><strong>解法一</strong></p><pre><code class="lang-cpp">int hammingDistance(int x, int y) {    int res = 0, exc = x ^ y;    while (exc){        ++res;        exc &amp;= (exc - 1);    }    return res;}</code></pre><p><strong>解法二</strong></p><pre><code class="lang-cpp">//递归法int hammingDistance(int x, int y) {    if ((x ^ y) == 0) return 0;    return (x ^ y) % 2 + hammingDistance(x / 2, y / 2);}</code></pre><p><strong>解法三</strong></p><pre><code class="lang-cpp">int hammingDistance(int x, int y) {    int result = x ^ y;    int binary = 0;    while (result) {        binary += result % 2;        result = result / 2;    }    return binary;}</code></pre><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode(4)  uniqueMorseCodeWords</title>
    <link href="/2018/07/10/leetcode(4)%20%20uniqueMorseCodeWords/"/>
    <url>/2018/07/10/leetcode(4)%20%20uniqueMorseCodeWords/</url>
    
    <content type="html"><![CDATA[<p>difficult：easy #804</p><p>International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: “a” maps to “.-“, “b” maps to “-…”, “c” maps to “-.-.”, and so on.</p><p>For convenience, the full table for the 26 letters of the English alphabet is given below:</p><pre><code class="lang-cpp">[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;]</code></pre><p>Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, “cab” can be written as “-.-.-….-“, (which is the concatenation “-.-.” + “-…” + “.-“). We’ll call such a concatenation, the transformation of a word.</p><p>Return the number of different transformations among all words we have.<br><strong>Example:</strong></p><pre><code class="lang-cpp">Input: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]Output: 2Explanation: The transformation of each word is:&quot;gin&quot; -&gt; &quot;--...-.&quot;&quot;zen&quot; -&gt; &quot;--...-.&quot;&quot;gig&quot; -&gt; &quot;--...--.&quot;&quot;msg&quot; -&gt; &quot;--...--.&quot;</code></pre><p>There are 2 different transformations, “—…-.” and “—…—.”.<br><strong>Note:</strong></p><pre><code class="lang-cpp">The length of words will be at most 100.Each words[i] will have length in range [1, 12].words[i] will only consist of lowercase letters.</code></pre><p><strong>解法1:</strong></p><pre><code class="lang-cpp">#include&lt;string&gt;#include&lt;vector&gt;#include&lt;set&gt;int uniqueMorseRepresentations(std::vector&lt;std::string&gt;&amp; words) {    std::vector&lt;std::string&gt; morse = { &quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot; };    std::set&lt;std::string&gt; seen;    for(std::string word:words){        std::string code;        for(char c : word){            code.append(morse[c - &#39;a&#39;]);//&#39;a&#39;-&gt;97        }        seen.insert(code);    }    return seen.size();}</code></pre><p><strong>解法2：</strong></p><pre><code class="lang-cpp">#include&lt;map&gt;#include&lt;string&gt;#include&lt;vector&gt;int uniqueMorseRepresentations(std::vector&lt;std::string&gt;&amp; words) {    std::string alpha = &quot;abcdefghijklmnopqrstuvwxyz&quot;;    std::vector&lt;std::string&gt; morse = { &quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot; };    std::map&lt;char, std::string&gt; alpha_code;    int index = 0;    for (auto i = alpha.begin(); i &lt; alpha.end(); i++) {        alpha_code[*i] = morse[index++];    }    std::set&lt;std::string&gt; seen;    for (std::string str : words) {        std::string str_code;        for (char c : str) {            str_code += alpha_code[c];        }        seen.insert(str_code);    }    return seen.size();}</code></pre><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode(3) Jewels and Stones</title>
    <link href="/2018/07/08/leetcode(3)%20Jewels%20and%20Stones/"/>
    <url>/2018/07/08/leetcode(3)%20Jewels%20and%20Stones/</url>
    
    <content type="html"><![CDATA[<p>difficult：easy #771</p><p>You’re given strings J representing the types of stones that are jewels, and S representing the stones you have.  Each character in S is a type of stone you have.  You want to know how many of the stones you have are also jewels.</p><p>The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so “a” is considered a different type of stone from “A”.<br>Example 1:</p><pre><code class="lang-cpp">Input: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;Output: 3</code></pre><p>Example 2:</p><pre><code class="lang-cpp">Input: J = &quot;z&quot;, S = &quot;ZZ&quot;Output: 0</code></pre><p>Note:<br>S and J will consist of letters and have length at most 50.<br>The characters in J are distinct.</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><pre><code class="lang-cpp">#include&lt;string&gt;int numJewelsInStones(std::string J, std::string S) {    int num = 0;    for (auto i = S.begin(); i &lt; S.end(); i++) {        if (J.find(*i) != std::string::npos)            num++;    }    return num;}</code></pre><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode(2) Reverse Integer</title>
    <link href="/2018/07/06/leetcode(2)%20Reverse%20Integer/"/>
    <url>/2018/07/06/leetcode(2)%20Reverse%20Integer/</url>
    
    <content type="html"><![CDATA[<p>difficult：easy #728<br>Given a 32-bit signed integer, reverse digits of an integer.<br>Example 1:</p><pre><code class="lang-cpp">Input: 123Output: 321</code></pre><p>Example 2:</p><pre><code class="lang-cpp">Input: -123Output: -321</code></pre><p>Example 3:</p><pre><code class="lang-cpp">Input: 120Output: 21</code></pre><p>Note:<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−$2^{31}$ , $2^{31}$ − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><pre><code class="lang-cpp">int reverse(int x) {    int result = 0;    while (x != 0 ) {        int num = x % 10;        if (result &gt; INT_MAX / 10 || (result == INT_MAX / 10 &amp;&amp; num &gt; 7)) return 0;        if (result &lt; INT_MIN / 10 || (result == INT_MIN / 10 &amp;&amp; num &lt; -8)) return 0;        x = x / 10;        result = result * 10 + num;    }    return result;}</code></pre><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode(1) Two-Sum</title>
    <link href="/2018/07/06/leetcode(1)%20Two-Sum/"/>
    <url>/2018/07/06/leetcode(1)%20Two-Sum/</url>
    
    <content type="html"><![CDATA[<p>difficult：easy #1<br>Given an array of integers, return indices of the two numbers such that they add up to a specific target.<br>You may assume that each input would have exactly one solution, and you may not use the same element twice.<br>Example:</p><pre><code class="lang-cpp">Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].</code></pre><h3 id="解法1-暴力法"><a href="#解法1-暴力法" class="headerlink" title="解法1 暴力法"></a>解法1 暴力法</h3><p>时间复杂度 O(<script type="math/tex">n^2</script>)</p><pre><code class="lang-cpp">std::vector&lt;int&gt; sum::twoSum(std::vector&lt;int&gt;&amp; nums, int target){    std::vector&lt;int&gt; result;    for (int i = 0; i &lt; nums.size(); i++) {      for (int j = i + 1; j &lt; nums.size(); j++) {        int sum = nums[i] + nums[j];        if (sum == target) {          result.push_back(i);          result.push_back(j);        }      }    }    return result;}</code></pre><h3 id="解法2-HashMap"><a href="#解法2-HashMap" class="headerlink" title="解法2 HashMap"></a>解法2 HashMap</h3><p>时间复杂度 O(<script type="math/tex">n</script>)</p><pre><code class="lang-cpp">vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {    std::map&lt;int,int&gt; nums_map;    std::vector&lt;int&gt; result;    for (int i = 0; i &lt; nums.size(); i++){        nums_map[nums[i]] = i;    }    for (int i = 0; i &lt; nums.size(); i++){        int value = target - nums[i];        if (nums_map.find(value) != nums_map.end() &amp;&amp; nums_map[value] != i) {            result.push_back(i);            result.push_back(nums_map[value]);            return result;        }    }}</code></pre><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker入门指南</title>
    <link href="/2018/06/13/Docker%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2018/06/13/Docker%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/docker.jpg" srcset="/img/loading.gif" alt="&quot;docker&quot;">  </p><p><strong>1.Docker简介</strong></p><p>问题引入:当我们在本机开发好应用程序以后需要发布到服务器，但是服务器并非和我们本机系统有着一样的运行环境，如缺少数据库、缺少各种依赖包、依赖软件版本过低等等问题，需要花很长时间重新在服务器配置好运行环境，得不偿失.那么有没有方法能够将我们开发程序时本机上所有的运行环境打包，直接部署到服务器上程序就能运行的机制呢?</p><p>Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，Docker是一个开源的应用容器引擎，基于Go语言，并遵从Apache2.0协议开源.容器是完全使用沙箱机制，相互之间不会有任何接口(类似iPhone的 app)，更重要的是容器性能开销极低.[来源网络]</p><p>通过上述定义可以知道，Docker似乎类似于虚拟机，可以在Docker中打包安装任何应用并运行，比如tomcat、Java、mysql等.但它并不等同于虚拟机，为了区分Docker和虚拟机，我们先来了解虚拟机的运行机制，如下图所示：</p><p><img src="/images/docker3.png" srcset="/img/loading.gif" alt="virtualbox"></p><blockquote><p>基础设施（Infrastructure):个人电脑，数据中心的服务器，或者是云主机</p><p>操作系统（Host Operating System）：MacOS，Windows或者Linux发行版</p><p>虚拟机管理系统（Hypervisor)：virtualBox,VMWare</p><p>从操作系统（Guest Operating System）:运行在virtualBox,VMWare中的虚拟机</p><p>依赖(bins/libs)：安装python，mysql等需要的依赖项</p><p>应用(APP)：Web 应用、后台应用、数据库应用等</p></blockquote><p>可以看出若隔离不同的应用，需要安装并启动不同的虚拟机，虚拟机的启动速度慢而且开销极大.Docker容器运行的应用不仅处于隔离状态，而且启动速度极快(毫秒级)，而且开销极小.下图为Docker的运行机制:</p><p><img src="/images/docker1.png" srcset="/img/loading.gif" alt="docker"></p><blockquote><p>基础设施（Infrastructure):个人电脑，数据中心的服务器，或者是云主机</p><p>操作系统（Host Operating System）：Linux</p><p>Docker守护进程（Docker Daemon）：Docker守护进程取代了Hypervisor，运行在操作系统之上的后台进程，负责管理Docker容器,等同于virtualBox,VMWare</p><p>依赖(bins/libs)：应用的所有依赖都打包在Docker镜像中，Docker容器是基于Docker镜像创建的</p><p>应用(APP)：应用的源代码及其依赖都打包在Docker镜像中，不同的应用需要不同的Docker镜像.不同的应用运行在不同的Docker容器中，它们是相互隔离的</p></blockquote><p>Docker守护进程可以直接与主操作系统进行通信，为各个Docker容器分配资源,它还可以将容器与主操作系统隔离，并将各个容器互相隔离。<br>虚拟机启动需要数分钟，而Docker容器可以在数毫秒内启动,由于没有臃肿的从操作系统,Docker可以节省大量的磁盘空间以及其他系统资源。</p><hr><p><strong>2.Docker安装(基于Ubuntu)</strong></p><p>在创建Docker容器前需要先安装Docker容器引擎，类似于虚拟机的virtualBox或VMWare.</p><pre><code class="lang-bash">#查看内核版本 docker安装需要大于3.1$ uname -r4.13.0-36-generic#更新软件源$ sudo apt-get update#安装dockersudo apt-get install docker.io #查看安装的docker版本(无错则安装成功)$ docker --versionDocker version 1.13.1, build 092cba3#运行hello-wolrd实例(该命令运行时会从镜像仓库中拉取docker镜像)$ sudo docker run hello-worldlatest: Pulling from library/hello-world9bb5a5d4561a: Pull complete Digest: sha256:f5233545e43561214ca4891fd1157e1c3c563316ed8e237750d59bde73361e77Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.....#查看已有的镜像$ sudo docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEhello-world         latest              e38bc07ac18e        2 months ago        1.85 kB#hello-world即从镜像仓库中拉取的镜像 docker run hello-world:latest 启动容器</code></pre><hr><p><strong>3.容器和镜像</strong><br>如下图所示，容器是由镜像实例化而来，类似于面向对象的概念，镜像看作类，容器则为类实例化后的对象.一个Docker镜像可以构建于另一个Docker镜像之上,好比类的继承机制.<br><img src="http://upload-images.jianshu.io/upload_images/2156466-b4341e9da2e6e170.jpg?imageMogr2/auto-orient/strip%7CimageView2/2" srcset="/img/loading.gif" alt="images"><br>docker的镜像概念类似虚拟机的镜像,是一个只读的模板,一个独立的文件系统,包括运行容器所需的数据，且可以用来创建新的容器(docker create <image -id >)，为指定的镜像添加一个可读写层.例如：一个镜像可以包含一个完整的ubuntu操作系统环境,类似于虚拟机的.iso文件.<br>docker利用容器来运行应用,docker容器是由docker镜像创建的运行实例,docker容器类似利用.iso文件安装后的虚拟机，可以执行各种读写操作,每个容器间是相互隔离的，容器中会运行特定的运用，包含特定应用的代码及所需的依赖文件,可以把容器看作一个简易版的linux环境.可以用同一个镜像启动多个Docker容器.</p><hr><p><strong>4.docker命令</strong></p><pre><code class="lang-bash">#查看已有的镜像$ sudo docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEhello-world         latest              e38bc07ac18e        2 months ago        1.85 kB#启动容器 $ docker run hello-world #run 创建基于该镜像的容器并启动#启动指定版本容器$ docker run hello-world:latest#查看已启动的容器$ docker ps  #查看存在的容器$ docker ps -a #启动已存在的容器$ docker start 容器ID#启动容器(守护方式/后台启动)$ docker run -d 容器ID$ docker start -d 容器ID#重新进入容器$ docker attach 容器ID#运行的容器种启动新进程$ docker exec -i -t 容器ID /bin/bash#停止守护容器$ docker stop 容器ID #等待容器停止$ docker kill 容器ID #立即停止容器#删除容器$ docker rm 容器ID#容器端口映射docker -P / docker --publish-all=true|false #映射所有端口$ docker run -P -i -t ubuntu #宿主机端口随机docker -p #映射指定端口$ docker run -p 80 -i -t ubuntu  #宿主机端口随机$ docker run -p 8080:80 -i -t ubuntu  #宿主机端口:容器端口$ docker run -p 0.0.0.0:80 -i -t ubuntu  #宿主机ip:容器端口$ docker run -p 0.0.0.0:8080:80 -i -t ubuntu  #宿主机ip:宿主机端口:容器端口#根据当前容器状态 创建新的镜像docker commit -m=&#39;ssh install&#39; -a=&#39;jiaopan&#39; cb57c338f1c9 kyleson/jpos#-m 说明文字#-a 作者#cb57c338f1c9 容器ID#kyleson/jpos 镜像名称#-p 提交时暂停容器#上传镜像到docker hub$ sudo docker login$ sudo docker push kyleson/jpos</code></pre><p><strong>5.docker实例</strong></p><h1 id="远程登陆docker容器"><a href="#远程登陆docker容器" class="headerlink" title="远程登陆docker容器"></a>远程登陆docker容器</h1><pre><code class="lang-bash">#1.创建并启动docker容器 $ docker run -p 2222:22 -i -t ubuntu:latest /bin/bash #避免重复创建容器 启动已有容器时使用start命令#2.安装ssh$ apt-get install openssh-server#3.修改ssh_config $ vim /etc/ssh/sshd_config PermitRootLogin yes #允许root用户以任何认证方式登录PasswordAuthentication yes#notes:#PermitRootLogin without-password #只允许root用公钥认证方式登录#PermitRootLogin no #不允许root用户以任何认证方式登录#4.启动ssh$ service ssh restart ##5.#修改root密码$ passwd root#6.查看容器ip$ ifconfig#7.返回宿主机且保持容器的运行ctrl+p ctrl+q #8.宿主机测试ssh登陆容器$ ssh -p root@容器ip #9.远程登陆容器$ ssh -p 2222 root@容器宿主机ip #宿主机2222端口以映射到容器的22端口</code></pre><p>至此,便可像登陆虚拟机一样玩转容器</p><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
