<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>opencv颜色转换(RGB-HSV)</title>
    <link href="/2020/12/03/opencv%E9%A2%9C%E8%89%B2%E8%BD%AC%E6%8D%A2(RGB-HSV)/"/>
    <url>/2020/12/03/opencv%E9%A2%9C%E8%89%B2%E8%BD%AC%E6%8D%A2(RGB-HSV)/</url>
    
    <content type="html"><![CDATA[<p>opencv中HSV的取值范围：H:[0,180],S:[0,255],V:[0,255]</p><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;opencv2/opencv.hpp&gt;int main() {    //std::cout &lt;&lt; cv::getVersionString() &lt;&lt; std::endl;    cv::Mat image = cv::imread(&quot;cv_blue.jpg&quot;);    cv::cvtColor(image,image,CV_BGR2RGB);    /**     * H: [0,180],S:[0,255],V:[0,255]     */    cv::Mat temp = image.clone();    cv::cvtColor(temp,temp,CV_RGB2HSV);    int h = temp.at&lt;cv::Vec3b&gt;(0,0)[0];    int s = temp.at&lt;cv::Vec3b&gt;(0,0)[1];    int v = temp.at&lt;cv::Vec3b&gt;(0,0)[2];    std::cout &lt;&lt; &quot;h:&quot; &lt;&lt; h / 180.0 &lt;&lt; &quot;, s:&quot; &lt;&lt; s / 255.0&lt;&lt;&quot;, v:&quot; &lt;&lt; v / 255.0 &lt;&lt; std::endl;    int red = static_cast&lt;int&gt;(image.at&lt;cv::Vec3b&gt;(0,0)[0]);    int green = static_cast&lt;int&gt;(image.at&lt;cv::Vec3b&gt;(0,0)[1]);    int blue = static_cast&lt;int&gt;(image.at&lt;cv::Vec3b&gt;(0,0)[2]);    std::cout &lt;&lt; &quot;red:&quot; &lt;&lt; red &lt;&lt; &quot;, green:&quot; &lt;&lt; green &lt;&lt;&quot;, blue:&quot; &lt;&lt; blue &lt;&lt; std::endl;}h:0.666667, s:1, v:0.996078red:0, green:0, blue:254</code></pre>]]></content>
    
    
    <categories>
      
      <category>opencv3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>opencv samples</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程</title>
    <link href="/2020/12/02/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2020/12/02/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><pre><code class="lang-java">Thread thread = new Thread(&quot;thread-1&quot;){    @Override    public void run() {        logger.info(&quot;hello world&quot;);    }};thread.start();</code></pre><pre><code class="lang-java">Runnable runnable = new Runnable() {    public void run() {        logger.info(&quot;hello world&quot;);    }};Thread thread = new Thread(runnable,&quot;thread&quot;);thread.start();</code></pre><pre><code class="lang-java">Runnable runnable = ()-&gt;{    logger.info(&quot;hello world&quot;);};Thread thread = new Thread(runnable,&quot;thread&quot;);thread.start();</code></pre><pre><code class="lang-java">FutureTask&lt;String&gt; task = new FutureTask&lt;String&gt;(new Callable&lt;String&gt;() {    @Override    public String call() throws Exception {        logger.info(&quot;running start...&quot;);        Thread.sleep(1000);        logger.info(&quot;running end...&quot;);        return &quot;ok&quot;;    }});Thread thread = new Thread(task,&quot;thread&quot;);thread.start();logger.info(task.get());//等待线程返回的结果</code></pre><h3 id="Thread常见方法"><a href="#Thread常见方法" class="headerlink" title="Thread常见方法"></a>Thread常见方法</h3><ul><li>start():启动新的线程，线程处于就绪状态</li><li>run():线程启动调用的方法 <blockquote><p>直接调用run方法时则由主线程进行执行</p></blockquote></li><li>join():等待线程运行结束(调用线程加入当前线程执行）</li><li>setPriority():设置线程优先级</li><li>getState():获取线程状态</li><li>sleep(n):线程休眠n毫秒，结束后处于就绪状态</li><li>yield():让出CPU控制权</li><li>interrupt():线程中断状态设为true<blockquote><p>sleep/wait/join状态下，线程抛出InterruptedException，sleep清除打断标记</p></blockquote></li><li>interrupted()：返回当前线程的中断状态；将当前线程的中断状态设为false，即清除打断标记</li><li>isInterrupted()：返回当前线程的中断状态，不清除打断标记</li></ul><pre><code class="lang-java">Thread thread = new Thread( new Runnable(){    public void run(){        // 若未发生中断，就正常执行任务        while(!Thread.currentThread.isInterrupted()){            // 正常任务代码……        }        // 中断的处理代码……        doSomething();    }} ).start();doSomething();thread.interrupt();</code></pre><ul><li>setDaemon():设置为守护线程(非守护线程执行完毕，守护线程即停止)</li></ul><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><pre><code class="lang-java">synchronized (对象){    //临界区            }</code></pre><blockquote><p>线程进入临界区需要获得锁，临界区的代码执行完才会释放锁，并唤醒阻塞线程</p></blockquote><pre><code class="lang-java">static int count = 0;static Object lock = new Object();public static void main(String[] args){    Thread increment = new Thread(()-&gt;{        synchronized (lock){            count++;        }    });    Thread decrement = new Thread(()-&gt;{        synchronized (lock){            count--;        }    });    increment.start();    decrement.start();    increment.join();    decrement.join();    logger.info(&quot;count:&quot;+count);//count始终为0}</code></pre><pre><code class="lang-java">class Utils{    private int count = 0;    public void increment(){        synchronized (this){            count++;        }    }    public void decrement(){        synchronized (this){            count--;        }    }    public int getCount(){        return this.count;    }}public static void main(String[] args) {    Utils utils = new Utils();    Thread inc = new Thread(()-&gt;{        utils.increment();    });    Thread dec = new Thread(()-&gt;{        utils.decrement();    });    inc.start();    dec.start();    inc.join();    dec.join();    logger.info(&quot;count:&quot;+utils.getCount());}</code></pre><pre><code class="lang-java">public synchronized void increment(){    //doSomething}public void increment(){    synchronized (this){        //doSomething    }}//以上等价public static synchronized void increment(){    //doSomething}public void increment(){    synchronized (Utils.class){        //doSomething    }}//以上等价</code></pre><blockquote><p>name.Class和this不是同一个对象，类对象只有一个，this为实例，可以有多个</p></blockquote><p><strong>Monitor(重量级锁)</strong></p><p><img src="/images/Monitor.png" srcset="/img/loading.gif" alt=""><br><img src="/images/monitor2.png" srcset="/img/loading.gif" alt=""></p><p>加synchronized对象会和一个对应的Monitor对象关联(对象的MarkWord置为Monitor对象的指针)，当线程成为Monitor的owner时才能执行临界区的代码，即获得锁，否则阻塞，添加到EntryList中，当owner为空时竞争锁。<br>WaitSet中的线程为已经获得过锁，但条件不满足放弃锁，进入waiting状态。owner线程调用notify()时唤醒WaitSet中的线程。</p><p><strong>轻量级锁</strong></p><p>线程访问临界区的时间错开，置锁对象的MarkWord为栈帧中琐记录值来上锁<br><br>锁重入：同一线程对同一对象再加锁<br><br>偏向锁：用threadId替换锁对象的markWord，若有锁重入，即再次加锁时检测锁对象的MarkWord是否等于threadId，一致则仅在栈帧中添加一条琐记录</p><pre><code class="lang-java">public void increment(){    synchronized (this){                count++;        decrement();     }}public void decrement(){    synchronized (this){        count--;    }}</code></pre><p><strong>锁膨胀</strong></p><p>Thread-1尝试进行轻量级加锁，但Thread-0已加锁，则Thread-1为Object对象申请Monitor锁对象，进行重量级加锁，Thread-1进入Monitor的EntryList</p><p><img src="/images/lock0.png" srcset="/img/loading.gif" alt=""></p><p>Thread-0进入轻量级锁流程，由于此时为重量级加锁，失败<br><br>执行重量级解锁流程，即置Monitor对象的owner为空，并唤醒EntryList中的阻塞线程</p><p><img src="/images/lock1.png" srcset="/img/loading.gif" alt=""></p><h3 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait/notify"></a>wait/notify</h3><p>只有获得锁的线程才能调用wait/notify方法,即需在synchronized代码块中调用(此时为重量级锁)<br><br>wait()会释放锁，sleep()不会释放锁</p><pre><code class="lang-java">static Logger logger = Logger.getLogger(&quot;log&quot;);static Object lock = new Object();public static void main(String[] args) throws ExecutionException, InterruptedException {    Thread thread = new Thread(()-&gt;{        synchronized (lock){            logger.info(&quot;执行...&quot;);            try {                lock.wait();            } catch (InterruptedException e) {                e.printStackTrace();            }            logger.info(&quot;被唤醒，执行...&quot;);        }    });    thread.start();    Thread.sleep(1000);    synchronized (lock){        logger.info(&quot;主线程执行...&quot;);        logger.info(&quot;唤醒子线程...&quot;);        lock.notify();    }}十二月 04, 2020 3:51:24 下午 Main lambda$main$0信息: 执行...十二月 04, 2020 3:51:25 下午 Main main信息: 主线程执行...十二月 04, 2020 3:51:25 下午 Main main信息: 唤醒子线程...十二月 04, 2020 3:51:25 下午 Main lambda$main$0信息: 被唤醒，执行...</code></pre><h3 id="同步-保护性暂停"><a href="#同步-保护性暂停" class="headerlink" title="同步-保护性暂停"></a>同步-保护性暂停</h3><pre><code>class GuardObject {    private String response;    public String get() {        synchronized (this){            while (response == null)                try {                    this.wait();                }catch (Exception e){                    e.printStackTrace();                }            return response;        }    }    //等待超时方法    public String get(long timeout) {        synchronized (this){            long begin = System.currentTimeMillis();            long passedTime = 0;            while (response == null){                long waitTime = timeout - passedTime;                if(waitTime &lt;= 0) break;                try {                    this.wait(waitTime);                }catch (Exception e){                    e.printStackTrace();                }                passedTime = System.currentTimeMillis() - begin;            }            return response;        }    }    public void set(String response) {        synchronized (this){           this.response = response;           this.notifyAll();        }    }}public static void main(String[] args){    GuardObject guardObject = new GuardObject();    new Thread(()-&gt;{        String res = guardObject.get();        //String res = guardObject.get(1000);        logger.info(&quot;response:&quot;+res.toString());    }).start();    new Thread(()-&gt;{            //Thread.sleep(2000);        guardObject.set(&quot;I set something.&quot;);    }).start();}信息: response:I set something.</code></pre><h3 id="生产者-消费者"><a href="#生产者-消费者" class="headerlink" title="生产者-消费者"></a>生产者-消费者</h3><pre><code class="lang-java">class MessageQueue {    Logger logger = Logger.getLogger(&quot;log&quot;);    private LinkedList&lt;Message&gt; queue = new LinkedList&lt;&gt;();    private int capcity;    public  MessageQueue(int capcity){        this.capcity = capcity;    }    public Message take(){        synchronized (queue){            while (queue.isEmpty()){                try {                    logger.info(&quot;queue is empty,waiting...&quot;);                    queue.wait();                }catch (Exception e){                    e.printStackTrace();                }            }            Message message = queue.removeFirst();            logger.info(&quot;consume message,&quot;+message);            queue.notifyAll();            return  message;        }    }    public void put(Message message){        synchronized (queue){            while (queue.size() == capcity){                try {                    logger.info(&quot;queue is full,waiting...&quot;);                    queue.wait();                }catch (Exception e){                    e.printStackTrace();                }            }            queue.addLast(message);            logger.info(&quot;add message,&quot;+message);            queue.notifyAll();        }    }    @Override    public String toString() {        return &quot;MessageQueue{&quot; +                &quot;queue=&quot; + queue +                &quot;, capcity=&quot; + capcity +                &#39;}&#39;;    }}final class Message{    private int id;    private String value;    public Message(int id,String value){        this.id = id;        this.value = value;    }    public int getId() {        return id;    }    public String getValue() {        return value;    }}static Logger logger = Logger.getLogger(&quot;log&quot;);public static void main(String[] args){    final MessageQueue messageQueue = new MessageQueue(5);    //三个生产者线程    for (int i = 0; i &lt; 3; i++) {        int id = i;        new Thread(()-&gt;{            messageQueue.put(new Message(id,&quot;value:&quot;+id));        },&quot;生产者&quot;+i).start();    }    //消费者线程    new Thread(()-&gt;{        while (true){            Message message = messageQueue.take();            logger.info(message.toString());        }    }).start();}十二月 10, 2020 3:46:38 下午 MessageQueue put信息: add message,Message@483b79f5十二月 10, 2020 3:46:38 下午 MessageQueue take信息: consume message,Message@483b79f5十二月 10, 2020 3:46:38 下午 Main lambda$main$1信息: Message@483b79f5十二月 10, 2020 3:46:38 下午 MessageQueue put信息: add message,Message@6a6daa45十二月 10, 2020 3:46:38 下午 MessageQueue put信息: add message,Message@3555b188十二月 10, 2020 3:46:38 下午 MessageQueue take信息: consume message,Message@6a6daa45十二月 10, 2020 3:46:38 下午 Main lambda$main$1信息: Message@6a6daa45十二月 10, 2020 3:46:38 下午 MessageQueue take信息: consume message,Message@3555b188十二月 10, 2020 3:46:38 下午 Main lambda$main$1信息: Message@3555b188十二月 10, 2020 3:46:38 下午 MessageQueue take信息: queue is empty,waiting...</code></pre><h3 id="Park-Unpark"><a href="#Park-Unpark" class="headerlink" title="Park/Unpark"></a>Park/Unpark</h3><pre><code class="lang-java">LockSupport.park();//暂停当前线程LockSupport.unpark(Thread thread);//恢复某个线程的运行</code></pre><pre><code class="lang-java">static Logger logger = Logger.getLogger(&quot;log&quot;);public static void main(String[] args) throws InterruptedException {    Thread thread = new Thread(()-&gt;{        logger.info(&quot;start...&quot;);        try {            Thread.sleep(1000);        } catch (InterruptedException e) {            e.printStackTrace();        }        logger.info(&quot;park...&quot;);        LockSupport.park();        logger.info(&quot;resume...&quot;);    });    thread.start();    Thread.sleep(2000);    logger.info(&quot;unpark...&quot;);    LockSupport.unpark(thread);}十二月 10, 2020 4:55:48 下午 Main lambda$main$0信息: start...十二月 10, 2020 4:55:49 下午 Main lambda$main$0信息: park...十二月 10, 2020 4:55:50 下午 Main main信息: unpark...十二月 10, 2020 4:55:50 下午 Main lambda$main$0信息: resume...</code></pre><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>产生死锁的必要条件</strong>：互斥条件、请求和保持条件、不剥夺条件、环路等待条件</p><pre><code class="lang-text">#哲学家进餐问题semaphore chopstick[5]={1,1,1,1,1};//五根筷子semaphore mutex =  1;//设置取筷子的信号量//i号哲学家进程Pi(){    do{        wait(mutex);        wait(chopstick[i]);//取左边筷子        wait(chopstick[(i+1]%5);//取右边筷子        signal(mutex);        eat;        signal(chopstick[i]);        signal(chopstick[(i+1]%5);        think;    }}</code></pre><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><pre><code class="lang-java">ReentrantLock reentrantLock = new ReentrantLock();reentrantLock.lock();//获得锁try {    //临界区}finally {    reentrantLock.unlock();//释放锁}</code></pre><p><strong>ReentrantLock 可重入</strong></p><pre><code class="lang-java">static Logger logger = Logger.getLogger(&quot;log&quot;);private static ReentrantLock reentrantLock = new ReentrantLock();public static void main(String[] args) throws InterruptedException {    reentrantLock.lock();    try {        logger.info(&quot;start&quot;);        enter();    }finally {        reentrantLock.unlock();    }}public static void enter(){    reentrantLock.lock();    try {        logger.info(&quot;enter&quot;);        exit();    }finally {        reentrantLock.unlock();    }}public static void exit(){    reentrantLock.lock();    try {        logger.info(&quot;exit&quot;);    }finally {        reentrantLock.unlock();    }}十二月 11, 2020 3:29:48 下午 Main main信息: start十二月 11, 2020 3:29:48 下午 Main enter信息: enter十二月 11, 2020 3:29:48 下午 Main exit信息: exit</code></pre><p><strong>ReentrantLock 可中断</strong></p><pre><code class="lang-java"> static Logger logger = Logger.getLogger(&quot;log&quot;);private static ReentrantLock reentrantLock = new ReentrantLock();public static void main(String[] args) throws InterruptedException {    Thread thread = new Thread(()-&gt;{        try {            logger.info(&quot;尝试获得锁...&quot;);            reentrantLock.lockInterruptibly();//可打断        } catch (InterruptedException e) {            logger.warning(&quot;被打断.。.&quot;);            e.printStackTrace();            return;        }        try {            logger.info(&quot;获得锁...&quot;);        }finally {            reentrantLock.unlock();        }    },&quot;thread&quot;);    thread.start();    thread.interrupt();}十二月 11, 2020 3:28:52 下午 Main lambda$main$0信息: 尝试获得锁...十二月 11, 2020 3:28:52 下午 Main lambda$main$0警告: 被打断.。.java.lang.InterruptedException    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:1220)    at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335)    at Main.lambda$main$0(Main.java:21)    at java.lang.Thread.run(Thread.java:748)</code></pre><p><strong>ReentrantLock 锁超时</strong></p><pre><code class="lang-java">static Logger logger = Logger.getLogger(&quot;log&quot;);private static ReentrantLock reentrantLock = new ReentrantLock();public static void main(String[] args) throws InterruptedException {    Thread thread = new Thread(()-&gt;{        logger.info(&quot;尝试获得锁...&quot;);        if(!reentrantLock.tryLock()){            logger.info(&quot;获得锁失败&quot;);            return;        }        try {            logger.info(&quot;获得锁...&quot;);        }finally {            reentrantLock.unlock();        }    },&quot;thread&quot;);    reentrantLock.lock();//主线程先获得锁    thread.start();}十二月 11, 2020 3:36:11 下午 Main lambda$main$0信息: 尝试获得锁...十二月 11, 2020 3:36:11 下午 Main lambda$main$0信息: 获得锁失败static Logger logger = Logger.getLogger(&quot;log&quot;);private static ReentrantLock reentrantLock = new ReentrantLock();public static void main(String[] args) throws InterruptedException {    Thread thread = new Thread(()-&gt;{        logger.info(&quot;尝试获得锁...&quot;);        try {            if(!reentrantLock.tryLock(1, TimeUnit.SECONDS)){                logger.info(&quot;获得锁失败&quot;);                return;            }        } catch (InterruptedException e) {            logger.info(&quot;获得锁失败&quot;);            e.printStackTrace();            return;        }        try {            logger.info(&quot;获得锁...&quot;);        }finally {            reentrantLock.unlock();        }    },&quot;thread&quot;);    reentrantLock.lock();//主线程先获得锁    thread.start();}十二月 11, 2020 3:38:11 下午 Main lambda$main$0信息: 尝试获得锁...十二月 11, 2020 3:38:12 下午 Main lambda$main$0信息: 获得锁失败</code></pre><p><strong>ReentrantLock 条件变量</strong></p><pre><code class="lang-java">static Logger logger = Logger.getLogger(&quot;log&quot;);static ReentrantLock reentrantLock = new ReentrantLock();static Condition condition_s = reentrantLock.newCondition();static Condition condition_g = reentrantLock.newCondition();static boolean has_s = false;static boolean has_g = false;public static void main(String[] args) throws InterruptedException {    new Thread(()-&gt;{        reentrantLock.lock();        try {            logger.info(&quot;is there a s ?&quot;);            while (!has_s){                condition_s.await();//等待s条件            }            if(has_s){                logger.info(&quot;get s&quot;);            }        } catch (InterruptedException e) {            e.printStackTrace();        } finally {            reentrantLock.unlock();        }    }).start();    new Thread(()-&gt;{        reentrantLock.lock();        try {            logger.info(&quot;is there a g ?&quot;);            while (!has_s){                condition_g.await();//等待g条件            }            if(has_s){                logger.info(&quot;get g&quot;);            }        } catch (InterruptedException e) {            e.printStackTrace();        } finally {            reentrantLock.unlock();        }    }).start();    Thread.sleep(2000);    new Thread(()-&gt;{        reentrantLock.lock();        try {            logger.info(&quot;add s&quot;);            has_s = true;            condition_s.signal();        }finally {            reentrantLock.unlock();        }    }).start();    Thread.sleep(1000);    new Thread(()-&gt;{        reentrantLock.lock();        try {            logger.info(&quot;add g&quot;);            has_g = true;            condition_g.signal();        }finally {            reentrantLock.unlock();        }    }).start();}十二月 11, 2020 4:30:39 下午 Main lambda$main$0信息: is there a s ?十二月 11, 2020 4:30:39 下午 Main lambda$main$1信息: is there a g ?十二月 11, 2020 4:30:41 下午 Main lambda$main$2信息: add s十二月 11, 2020 4:30:41 下午 Main lambda$main$0信息: get s十二月 11, 2020 4:30:42 下午 Main lambda$main$3信息: add g十二月 11, 2020 4:30:42 下午 Main lambda$main$1信息: get g</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言.001</title>
    <link href="/2020/05/18/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.001/"/>
    <url>/2020/05/18/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.001/</url>
    
    <content type="html"><![CDATA[<p>基础知识：汇编语言第三版-王爽<br><br>汇编指令：机器码的助记符，有对应的机器码；<br><br>伪指令：无对应的机器码，由编译器执行；<br><br>其他符号：如+、-、*、/,由编译器识别，无对应机器码；<br></p><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p><strong>通用寄存器</strong>：AX,BX,CX(循环计数寄存器),DX<br><a href="\images\2019\4\18\ax.png"></a></p><p><strong>段寄存器</strong><br>CS(代码段寄存器)：IP(指令指针寄存器) - 提供CPU执行指令的地址<br><br>DS(数据段寄存器)：偏移地址 - 提供数据的存储地址<br><br>SS(栈顶段寄存器)：SP（栈顶指针寄存器）- 提供栈顶元素的存储地址<br><br>ES(附加段寄存器)<br></p><h1 id="Start-hello-world"><a href="#Start-hello-world" class="headerlink" title="Start hello world"></a>Start hello world</h1><pre><code class="lang-asm">DSEG    SEGMENTMESS    DB   &#39;Hello,World!&#39; ,0DH,0AH,24HDSEG    ENDSSSEG    SEGMENT PARA STACK         DW  256 DUP(?)SSEG    ENDSCSEG    SEGMENT        ASSUME  CS:CSEG,DS:DSEGBEGIN:  MOV AX,DSEG        MOV DS,AX        MOV DX,OFFSET MESS        MOV AH,9        INT 21H        MOV AH,4CH         INT 21HCSEG    ENDS        END  BEGIN</code></pre><p><strong>编译-链接-执行</strong><br><a href="\images\2019\4\18\1.png"></a><br><a href="\images\2019\4\18\2.png"></a></p>]]></content>
    
    
    <categories>
      
      <category>汇编语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-Java</title>
    <link href="/2020/04/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Java/"/>
    <url>/2020/04/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Java/</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><ul><li>饿汉式</li></ul><pre><code class="lang-java">#1class Singleton{    private final static Singleton instance = new Singleton();    public static Singleton getInstance(){        return instance;    }}#2public class Singleton{    private static Singleton instance;    static {        instance = new Singleton();    }    public static Singleton getInstance(){        return instance;    }}</code></pre><ul><li>懒汉式</li></ul><pre><code class="lang-java">#1 线程不安全public class Singleton{    private static Singleton instance;    public static Singleton getInstance(){        if(instance == null)            instance = new Singleton();        return instance;    }}#2 线程安全 效率低public class Singleton{    private static Singleton instance;    public static synchronized Singleton getInstance(){        if(instance == null)            instance = new Singleton();        return instance;    }}#3 双重检测public class Singleton{    private static volatile Singleton instance;    public static synchronized Singleton getInstance(){        if(instance == null){            synchronized (Singleton.class){                if(instance == null){                    instance = new Singleton();                }            }        }        return instance;    }}#4 静态内部类class Singleton{   private static class SingletonInstance{        private static final Singleton instance = new Singleton();    }    public static synchronized Singleton getInstance(){        return SingletonInstance.instance;    }}</code></pre><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><pre><code class="lang-java">#简单工厂模式public interface Shape {   void draw();}public class Rectangle implements Shape {   @Override   public void draw() {      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);   }}public class Circle implements Shape {   @Override   public void draw() {      System.out.println(&quot;Inside Circle::draw() method.&quot;);   }}public class ShapeFactory {   public Shape getShape(String shapeType){      if(shapeType == null){         return null;      }              if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;)){         return new Circle();      }else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;)){         return new Square();      }      return null;   }}#抽象工厂模式public interface Shape {   void draw();}public class Rectangle implements Shape {   @Override   public void draw() {      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);   }}public interface Color {   void fill();}public class Red implements Color {   @Override   public void fill() {      System.out.println(&quot;Inside Red::fill() method.&quot;);   }}public abstract class AbstractFactory {   public abstract Color getColor(String color);   public abstract Shape getShape(String shape) ;}public class ShapeFactory extends AbstractFactory {   @Override   public Shape getShape(String shapeType){      if(shapeType == null){         return null;      }              if(shapeType.equalsIgnoreCase(&quot;Rectangle&quot;)){         return new Rectangle();      }       return null;   }   @Override   public Color getColor(String color) {      return null;   }}public class ColorFactory extends AbstractFactory {   @Override   public Shape getShape(String shapeType){      return null;   }   @Override   public Color getColor(String color) {      if(color == null){         return null;      }              if(color.equalsIgnoreCase(&quot;RED&quot;)){         return new Red();      }      return null;   }}public class FactoryProducer {   public static AbstractFactory getFactory(String choice){      if(choice.equalsIgnoreCase(&quot;SHAPE&quot;)){         return new ShapeFactory();      } else if(choice.equalsIgnoreCase(&quot;COLOR&quot;)){         return new ColorFactory();      }      return null;   }}</code></pre><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><pre><code class="lang-java">class Target implements Cloneable{    Target(String name,int age){        this.name = name;        this.age = age;    }    private String name;    private int age;    public String getName() {        return name;    }    public int getAge() {        return age;    }        //默认自动拷贝基本数据类型    @Override    protected Object clone() throws CloneNotSupportedException {        Target target = null;        target = (Target)super.clone();        return target;    }}public static void main(String[] args) throws CloneNotSupportedException {        Target target = new Target(&quot;Tom&quot;,1);        Target clone_target = (Target)target.clone();        System.out.println(clone_target.getName()+&quot;:&quot;+clone_target.getAge());    }Tom:1</code></pre><p><strong>深度拷贝</strong></p><pre><code class="lang-java">class DeepCloneTarget implements Serializable,Cloneable{    private String name;    DeepCloneTarget(String name){        this.name = name;    }    public String getName() {        return name;    }    @Override    protected Object clone() throws CloneNotSupportedException {        return super.clone();    }}class Target implements Serializable,Cloneable{    private String name;    public DeepCloneTarget deepCloneTarget;    Target(String name){        this.name = name;    }    public String getName() {        return name;    }    //普通深度拷贝    @Override    protected Object clone() throws CloneNotSupportedException {        Target target = null;        target = (Target) super.clone();        target.deepCloneTarget = (DeepCloneTarget) deepCloneTarget.clone();        return target;    }        //序列化深度拷贝    public Object deepClone() throws IOException {        ByteArrayOutputStream bos = null;        ObjectOutputStream oos = null;        ByteArrayInputStream bis = null;        ObjectInputStream ois = null;        try{            //序列化            bos = new ByteArrayOutputStream();            oos = new ObjectOutputStream(bos);            oos.writeObject(this);            //反序列化            bis = new ByteArrayInputStream(bos.toByteArray());            ois = new ObjectInputStream(bis);            Target target = (Target) ois.readObject();            return target;        }catch (Exception e){            e.printStackTrace();            return null;        }finally {            bos.close();            oos.close();            bis.close();            ois.close();        }    }}public static void main(String[] args) throws CloneNotSupportedException, IOException {        Target target = new Target(&quot;target&quot;);        target.deepCloneTarget = new DeepCloneTarget(&quot;deepTarget&quot;);        Target clone_target = (Target)target.clone();        Target deep_clone_target = (Target)target.deepClone();        System.out.println(clone_target.getName()+&quot;:&quot;+clone_target.deepCloneTarget.getName());        System.out.println(deep_clone_target.getName()+&quot;:&quot;+deep_clone_target.deepCloneTarget.getName());}</code></pre>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>004.Spark Machine Learning</title>
    <link href="/2020/04/15/spark.004/"/>
    <url>/2020/04/15/spark.004/</url>
    
    <content type="html"><![CDATA[<h1 id="Spark-Machine-Learning"><a href="#Spark-Machine-Learning" class="headerlink" title="Spark Machine Learning"></a>Spark Machine Learning</h1><ul><li>引入依赖</li></ul><pre><code class="lang-text">&lt;dependency&gt;  &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;  &lt;artifactId&gt;spark-mllib_2.11&lt;/artifactId&gt;  &lt;version&gt;2.4.5&lt;/version&gt;&lt;/dependency&gt;</code></pre><h1 id="相关系数矩阵"><a href="#相关系数矩阵" class="headerlink" title="相关系数矩阵"></a>相关系数矩阵</h1><p>相关系数矩阵(i行，j列)的元素是原矩阵i列与j列的相关系数</p><pre><code class="lang-java">#身高与体重的相关系数矩阵SparkSession spark = SparkSession.builder().appName(&quot;ml test&quot;)                 .master(&quot;local[*]&quot;)                 .getOrCreate();List&lt;Row&gt; data = Arrays.asList(          RowFactory.create(Vectors.dense(172, 60)),          RowFactory.create(Vectors.dense(175, 65)),          RowFactory.create(Vectors.dense(180, 70)),          RowFactory.create(Vectors.dense(190, 80)));StructType schema = new StructType(new StructField[]{  new StructField(&quot;features&quot;, new VectorUDT(), false, Metadata.empty()),});Dataset&lt;Row&gt; df = spark.createDataFrame(data, schema);df.show();Row pearson = Correlation.corr(df, &quot;features&quot;).head();System.out.println(&quot;Pearson correlation matrix:\n&quot; + pearson);Row spearman = Correlation.corr(df, &quot;features&quot;, &quot;spearman&quot;).head();System.out.println(&quot;Spearman correlation matrix:\n&quot; + spearman);+------------+|    features|+------------+|[172.0,60.0]||[175.0,65.0]||[180.0,70.0]||[190.0,80.0]|+------------+Pearson correlation matrix:[1.0                 0.9957069831288888  0.9957069831288888  1.0                 ]Spearman correlation matrix:[1.0                 0.9999999999999981  0.9999999999999981  1.0                 ]</code></pre><h1 id="Extracting-transforming-and-selecting-features"><a href="#Extracting-transforming-and-selecting-features" class="headerlink" title="Extracting, transforming and selecting features"></a>Extracting, transforming and selecting features</h1><h2 id="Tokenizer-分词"><a href="#Tokenizer-分词" class="headerlink" title="Tokenizer 分词"></a>Tokenizer 分词</h2><pre><code class="lang-java">SparkSession spark = SparkSession.builder().appName(&quot;ml test&quot;)                 .master(&quot;local[*]&quot;)                 .getOrCreate();List&lt;Row&gt; data = Arrays.asList(                RowFactory.create(0, &quot;Hi I heard about Spark&quot;),                RowFactory.create(1, &quot;I wish Java could use case classes&quot;),                RowFactory.create(2, &quot;Logistic,regression,models,are,neat&quot;)        );StructType schema = new StructType(new StructField[]{        new StructField(&quot;id&quot;, DataTypes.IntegerType, false, Metadata.empty()),        new StructField(&quot;sentence&quot;, DataTypes.StringType, false, Metadata.empty())});Dataset&lt;Row&gt; sentenceDataFrame = spark.createDataFrame(data, schema);Tokenizer tokenizer = new Tokenizer().setInputCol(&quot;sentence&quot;).setOutputCol(&quot;words&quot;);Dataset&lt;Row&gt; tokenized = tokenizer.transform(sentenceDataFrame);tokenized.show(false);//正则RegexTokenizer regexTokenizer = new RegexTokenizer()        .setInputCol(&quot;sentence&quot;)        .setOutputCol(&quot;words&quot;)        .setPattern(&quot;\\W&quot;);  // alternatively .setPattern(&quot;\\w+&quot;).setGaps(false);Dataset&lt;Row&gt; regexTokenized = regexTokenizer.transform(sentenceDataFrame);regexTokenized.show(false);+---+-----------------------------------+------------------------------------------+|id |sentence                           |words                                     |+---+-----------------------------------+------------------------------------------+|0  |Hi I heard about Spark             |[hi, i, heard, about, spark]              ||1  |I wish Java could use case classes |[i, wish, java, could, use, case, classes]||2  |Logistic,regression,models,are,neat|[logistic,regression,models,are,neat]     |+---+-----------------------------------+------------------------------------------++---+-----------------------------------+------------------------------------------+|id |sentence                           |words                                     |+---+-----------------------------------+------------------------------------------+|0  |Hi I heard about Spark             |[hi, i, heard, about, spark]              ||1  |I wish Java could use case classes |[i, wish, java, could, use, case, classes]||2  |Logistic,regression,models,are,neat|[logistic, regression, models, are, neat] |+---+-----------------------------------+------------------------------------------+</code></pre><h2 id="StopWordsRemover-停止词"><a href="#StopWordsRemover-停止词" class="headerlink" title="StopWordsRemover 停止词"></a>StopWordsRemover 停止词</h2><pre><code class="lang-java">SparkSession spark = SparkSession.builder().appName(&quot;ml test&quot;)                 .master(&quot;local[*]&quot;)                 .getOrCreate();StopWordsRemover remover = new StopWordsRemover()                .setInputCol(&quot;raw&quot;)                .setOutputCol(&quot;filtered&quot;);List&lt;Row&gt; data = Arrays.asList(        RowFactory.create(Arrays.asList(&quot;I&quot;, &quot;saw&quot;, &quot;the&quot;, &quot;red&quot;, &quot;balloon&quot;)),        RowFactory.create(Arrays.asList(&quot;Mary&quot;, &quot;had&quot;, &quot;a&quot;, &quot;little&quot;, &quot;lamb&quot;)));StructType schema = new StructType(new StructField[]{        new StructField(&quot;raw&quot;, DataTypes.createArrayType(DataTypes.StringType), false, Metadata.empty())});Dataset&lt;Row&gt; dataset = spark.createDataFrame(data, schema);remover.transform(dataset).show(false);+----------------------------+--------------------+|raw                         |filtered            |+----------------------------+--------------------+|[I, saw, the, red, balloon] |[saw, red, balloon] ||[Mary, had, a, little, lamb]|[Mary, little, lamb]|+----------------------------+--------------------+</code></pre><h2 id="n-gram"><a href="#n-gram" class="headerlink" title="$n$  -gram"></a>$n$  -gram</h2><pre><code class="lang-java">SparkSession spark = SparkSession.builder().appName(&quot;ml test&quot;)                 .master(&quot;local[*]&quot;)                 .getOrCreate();List&lt;Row&gt; data = Arrays.asList(        RowFactory.create(0, Arrays.asList(&quot;Hi&quot;, &quot;I&quot;, &quot;heard&quot;, &quot;about&quot;, &quot;Spark&quot;)),        RowFactory.create(1, Arrays.asList(&quot;I&quot;, &quot;wish&quot;, &quot;Java&quot;, &quot;could&quot;, &quot;use&quot;, &quot;case&quot;, &quot;classes&quot;)),        RowFactory.create(2, Arrays.asList(&quot;Logistic&quot;, &quot;regression&quot;, &quot;models&quot;, &quot;are&quot;, &quot;neat&quot;)));StructType schema = new StructType(new StructField[]{        new StructField(&quot;id&quot;, DataTypes.IntegerType, false, Metadata.empty()),        new StructField(                &quot;words&quot;, DataTypes.createArrayType(DataTypes.StringType), false, Metadata.empty())});Dataset&lt;Row&gt; wordDataFrame = spark.createDataFrame(data, schema);NGram ngramTransformer = new NGram().setN(2).setInputCol(&quot;words&quot;).setOutputCol(&quot;ngrams&quot;);Dataset&lt;Row&gt; ngramDataFrame = ngramTransformer.transform(wordDataFrame);ngramDataFrame.select(&quot;ngrams&quot;).show(false);</code></pre><h2 id="Binarization-二值化"><a href="#Binarization-二值化" class="headerlink" title="Binarization 二值化"></a>Binarization 二值化</h2><pre><code class="lang-java">SparkSession spark = SparkSession.builder().appName(&quot;ml test&quot;)                 .master(&quot;local[*]&quot;)                 .getOrCreate();List&lt;Row&gt; data = Arrays.asList(        RowFactory.create(0, 0.1),        RowFactory.create(1, 0.8),        RowFactory.create(2, 0.2));StructType schema = new StructType(new StructField[]{        new StructField(&quot;id&quot;, DataTypes.IntegerType, false, Metadata.empty()),        new StructField(&quot;feature&quot;, DataTypes.DoubleType, false, Metadata.empty())});Dataset&lt;Row&gt; continuousDataFrame = spark.createDataFrame(data, schema);Binarizer binarizer = new Binarizer()        .setInputCol(&quot;feature&quot;)        .setOutputCol(&quot;binarized_feature&quot;)        .setThreshold(0.5);Dataset&lt;Row&gt; binarizedDataFrame = binarizer.transform(continuousDataFrame);System.out.println(&quot;Binarizer output with Threshold = &quot; + binarizer.getThreshold());binarizedDataFrame.show();+---+-------+-----------------+| id|feature|binarized_feature|+---+-------+-----------------+|  0|    0.1|              0.0||  1|    0.8|              1.0||  2|    0.2|              0.0|+---+-------+-----------------+</code></pre><h2 id="PCA-主成成分分析"><a href="#PCA-主成成分分析" class="headerlink" title="PCA 主成成分分析"></a>PCA 主成成分分析</h2><pre><code>SparkSession spark = SparkSession.builder().appName(&quot;ml test&quot;)                 .master(&quot;local[*]&quot;)                 .getOrCreate();List&lt;Row&gt; data = Arrays.asList(        RowFactory.create(Vectors.sparse(5, new int[]{1, 3}, new double[]{1.0, 7.0})),        RowFactory.create(Vectors.dense(2.0, 0.0, 3.0, 4.0, 5.0)),        RowFactory.create(Vectors.dense(4.0, 0.0, 0.0, 6.0, 7.0)));StructType schema = new StructType(new StructField[]{        new StructField(&quot;features&quot;, new VectorUDT(), false, Metadata.empty()),});Dataset&lt;Row&gt; df = spark.createDataFrame(data, schema);PCAModel pca = new PCA()        .setInputCol(&quot;features&quot;)        .setOutputCol(&quot;pcaFeatures&quot;)        .setK(3)        .fit(df);Dataset&lt;Row&gt; result = pca.transform(df).select(&quot;pcaFeatures&quot;);result.show(false);+-----------------------------------------------------------+|pcaFeatures                                                |+-----------------------------------------------------------+|[1.6485728230883807,-4.013282700516296,-5.524543751369388] ||[-4.645104331781534,-1.1167972663619026,-5.524543751369387]||[-6.428880535676489,-5.337951427775355,-5.524543751369389] |+-----------------------------------------------------------+</code></pre><h2 id="PolynomialExpansion-多项式转化"><a href="#PolynomialExpansion-多项式转化" class="headerlink" title="PolynomialExpansion 多项式转化"></a>PolynomialExpansion 多项式转化</h2><pre><code class="lang-java">PolynomialExpansion polyExpansion = new PolynomialExpansion()                .setInputCol(&quot;features&quot;)                .setOutputCol(&quot;polyFeatures&quot;)                .setDegree(2);List&lt;Row&gt; data = Arrays.asList(        RowFactory.create(Vectors.dense(2.0, 1.0)),        RowFactory.create(Vectors.dense(0.0, 0.0)),        RowFactory.create(Vectors.dense(3.0, -1.0)));StructType schema = new StructType(new StructField[]{        new StructField(&quot;features&quot;, new VectorUDT(), false, Metadata.empty()),});Dataset&lt;Row&gt; df = spark.createDataFrame(data, schema);Dataset&lt;Row&gt; polyDF = polyExpansion.transform(df);polyDF.show(false);+----------+-----------------------+|features  |polyFeatures           |+----------+-----------------------+|[2.0,1.0] |[2.0,4.0,1.0,2.0,1.0]  ||[0.0,0.0] |[0.0,0.0,0.0,0.0,0.0]  ||[3.0,-1.0]|[3.0,9.0,-1.0,-3.0,1.0]|+----------+-----------------------+</code></pre><h2 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h2><ul><li>TF:词频，词条在<strong>给定文档</strong>中所出现的频率,值越大则词条在该文档中重要性越大</li></ul><p>词条 $i$ 的TF： $TF_i$ = $\frac{N_i}{N}$  ( $N$ ：给定文档的总词条数)</p><ul><li>IDF：逆向文本频率，词条在<strong>所有文档</strong>中出现的频率，值越大则词条在该文档中重要性越小</li></ul><p>词条 $i$ 的IDF： $IDF_i$ = $log(\frac{D}{D_i+1})$  ( $D$ :总文档数， $D_i$ :包含词条 $i$ 的文档数)</p><p>TF-IDF $_i$ = $TF_i*IDF_i$  (词条 $i$ 的TF-IDF值)</p><pre><code class="lang-java">SparkSession spark = SparkSession.builder().appName(&quot;ml test&quot;)                 .master(&quot;local[*]&quot;)                 .getOrCreate();List&lt;Row&gt; data = Arrays.asList(                  RowFactory.create(0.0, &quot;I love spark spark spark&quot;),                  RowFactory.create(1.0, &quot;I love java java is my life&quot;),                  RowFactory.create(2.0, &quot;I love C++ C++ is the best&quot;)        );StructType schema = new StructType(new StructField[]{          new StructField(&quot;label&quot;, DataTypes.DoubleType, false, Metadata.empty()),          new StructField(&quot;sentence&quot;, DataTypes.StringType, false, Metadata.empty())});Dataset&lt;Row&gt; sentenceData = spark.createDataFrame(data, schema);sentenceData.show();Tokenizer tokenizer = new Tokenizer().setInputCol(&quot;sentence&quot;).setOutputCol(&quot;words&quot;); //分词Dataset&lt;Row&gt; wordsData = tokenizer.transform(sentenceData);wordsData.show();int numFeatures = 20;HashingTF hashingTF = new HashingTF().setInputCol(&quot;words&quot;).setOutputCol(&quot;rawFeatures&quot;).setNumFeatures(numFeatures);Dataset&lt;Row&gt; featurizedData = hashingTF.transform(wordsData);featurizedData.show();IDF idf = new IDF().setInputCol(&quot;rawFeatures&quot;).setOutputCol(&quot;features&quot;);IDFModel idfModel = idf.fit(featurizedData);Dataset&lt;Row&gt; rescaledData = idfModel.transform(featurizedData);rescaledData.show();+-----+--------------------+|label|            sentence|+-----+--------------------+|  0.0|I love spark spar...||  1.0|I love java java ...||  2.0|I love C++ C++ is...|+-----+--------------------++-----+--------------------+--------------------+|label|            sentence|               words|+-----+--------------------+--------------------+|  0.0|I love spark spar...|[i, love, spark, ...||  1.0|I love java java ...|[i, love, java, j...||  2.0|I love C++ C++ is...|[i, love, c++, c+...|#rawFeatures:hash桶数、词hash索引、词频率+-----+--------------------+--------------------+--------------------+|label|            sentence|               words|         rawFeatures|+-----+--------------------+--------------------+--------------------+|  0.0|I love spark spar...|[i, love, spark, ...|(20,[0,5,9],[1.0,...||  1.0|I love java java ...|[i, love, java, j...|(20,[0,1,7,9,16,1...||  2.0|I love C++ C++ is...|[i, love, c++, c+...|(20,[0,1,3,9,10,1...|+-----+--------------------+--------------------+--------------------++-----+--------------------+--------------------+--------------------+--------------------+|label|            sentence|               words|         rawFeatures|            features|+-----+--------------------+--------------------+--------------------+--------------------+|  0.0|I love spark spar...|[i, love, spark, ...|(20,[0,5,9],[1.0,...|(20,[0,5,9],[0.0,...||  1.0|I love java java ...|[i, love, java, j...|(20,[0,1,7,9,16,1...|(20,[0,1,7,9,16,1...||  2.0|I love C++ C++ is...|[i, love, c++, c+...|(20,[0,1,3,9,10,1...|(20,[0,1,3,9,10,1...|+-----+--------------------+--------------------+--------------------+--------------------+</code></pre><h2 id="CountVectorizer"><a href="#CountVectorizer" class="headerlink" title="CountVectorizer"></a>CountVectorizer</h2><pre><code class="lang-java">SparkSession spark = SparkSession.builder().appName(&quot;ml test&quot;)                 .master(&quot;local[*]&quot;)                 .getOrCreate();List&lt;Row&gt; data = Arrays.asList(                  RowFactory.create(&quot;I love spark spark spark&quot;),                  RowFactory.create(&quot;I love java java is my life&quot;),                  RowFactory.create(&quot;I love C++ C++ is the best&quot;)        );StructType schema = new StructType(new StructField[]{          new StructField(&quot;sentence&quot;, DataTypes.StringType, false, Metadata.empty())});Dataset&lt;Row&gt; sentenceData = spark.createDataFrame(data, schema);sentenceData.show();Tokenizer tokenizer = new Tokenizer().setInputCol(&quot;sentence&quot;).setOutputCol(&quot;words&quot;); //分词Dataset&lt;Row&gt; wordsData = tokenizer.transform(sentenceData);wordsData.show();CountVectorizerModel cvModel = new CountVectorizer()                              .setInputCol(&quot;words&quot;)                              .setOutputCol(&quot;feature&quot;)                              //.setVocabSize(3)                              //.setMinDF(2)                              .fit(wordsData);System.out.println(Arrays.asList(cvModel.vocabulary()));cvModel.transform(wordsData).show(false);+--------------------+|            sentence|+--------------------+|I love spark spar...||I love java java ...||I love C++ C++ is...|+--------------------++--------------------+--------------------+|            sentence|               words|+--------------------+--------------------+|I love spark spar...|[i, love, spark, ...||I love java java ...|[i, love, java, j...||I love C++ C++ is...|[i, love, c++, c+...|+--------------------+--------------------+[love, spark, i, c++, java, is, the, life, best, my]#feature:词总数、词索引、词频率+---------------------------+-----------------------------------+--------------------------------------------+|sentence                   |words                              |feature                                     |+---------------------------+-----------------------------------+--------------------------------------------+|I love spark spark spark   |[i, love, spark, spark, spark]     |(10,[0,1,2],[1.0,3.0,1.0])                  ||I love java java is my life|[i, love, java, java, is, my, life]|(10,[0,2,4,5,7,9],[1.0,1.0,2.0,1.0,1.0,1.0])||I love C++ C++ is the best |[i, love, c++, c++, is, the, best] |(10,[0,2,3,5,6,8],[1.0,1.0,2.0,1.0,1.0,1.0])|+---------------------------+-----------------------------------+--------------------------------------------+</code></pre><h2 id="FeatureHasher"><a href="#FeatureHasher" class="headerlink" title="FeatureHasher"></a>FeatureHasher</h2><pre><code class="lang-java">SparkSession spark = SparkSession.builder().appName(&quot;ml test&quot;)                 .master(&quot;local[*]&quot;)                 .getOrCreate();List&lt;Row&gt; data = Arrays.asList(                RowFactory.create(2.2, true, &quot;1&quot;, &quot;foo&quot;),                RowFactory.create(3.3, false, &quot;2&quot;, &quot;bar&quot;),                RowFactory.create(4.4, false, &quot;3&quot;, &quot;baz&quot;),                RowFactory.create(5.5, false, &quot;4&quot;, &quot;foo&quot;)        );StructType schema = new StructType(new StructField[]{        new StructField(&quot;real&quot;, DataTypes.DoubleType, false, Metadata.empty()),        new StructField(&quot;bool&quot;, DataTypes.BooleanType, false, Metadata.empty()),        new StructField(&quot;stringNum&quot;, DataTypes.StringType, false, Metadata.empty()),        new StructField(&quot;string&quot;, DataTypes.StringType, false, Metadata.empty())});Dataset&lt;Row&gt; dataset = spark.createDataFrame(data, schema);FeatureHasher hasher = new FeatureHasher()        .setInputCols(new String[]{&quot;real&quot;, &quot;bool&quot;, &quot;stringNum&quot;, &quot;string&quot;})        .setOutputCol(&quot;features&quot;);Dataset&lt;Row&gt; featurized = hasher.transform(dataset);featurized.show(false);+----+-----+---------+-------------------+|real|bool |stringNum|features           |+----+-----+---------+-------------------+|2.2 |true |1        |(2,[0,1],[2.0,2.2])||3.3 |false|2        |(2,[0,1],[1.0,4.3])||4.4 |false|3        |(2,[0,1],[2.0,4.4])||5.5 |false|4        |(2,[0,1],[1.0,6.5])|+----+-----+---------+-------------------+</code></pre>]]></content>
    
    
    <categories>
      
      <category>spark</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>003.Spark Streaming/Structured Streaming</title>
    <link href="/2020/04/15/spark.003/"/>
    <url>/2020/04/15/spark.003/</url>
    
    <content type="html"><![CDATA[<h1 id="spark-streaming-hello-world"><a href="#spark-streaming-hello-world" class="headerlink" title="spark streaming-hello world"></a>spark streaming-hello world</h1><p><em>note</em>:<a href="http://spark.apache.org/docs/latest/streaming-programming-guide.html" target="_blank" rel="noopener">http://spark.apache.org/docs/latest/streaming-programming-guide.html</a></p><ul><li>引入依赖</li></ul><pre><code class="lang-text">&lt;dependency&gt;    &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;    &lt;artifactId&gt;spark-streaming_2.11&lt;/artifactId&gt;    &lt;version&gt;2.4.5&lt;/version&gt;&lt;/dependency&gt;</code></pre><ul><li><p>安装 Netcat 下载地址：<a href="http://netcat.sourceforge.net/" target="_blank" rel="noopener">http://netcat.sourceforge.net/</a></p></li><li><p>解压-启动</p></li></ul><pre><code class="lang-bash">$ nc -lk 9999</code></pre><ul><li>example</li></ul><pre><code class="lang-java">SparkConf conf = new SparkConf().setAppName(&quot;spark streaming&quot;).setMaster(&quot;local[*]&quot;);JavaStreamingContext jsc = new JavaStreamingContext(conf,Durations.seconds(5));//5s处理一次JavaReceiverInputDStream&lt;String&gt; lines = jsc.socketTextStream(&quot;localhost&quot;,9999);JavaDStream&lt;String&gt; words = lines.flatMap(x -&gt; Arrays.asList(x.split(&quot; &quot;)).iterator());JavaPairDStream&lt;String, Integer&gt; pairs = words.mapToPair(s -&gt; new Tuple2&lt;&gt;(s, 1));JavaPairDStream&lt;String, Integer&gt; wordCounts = pairs.reduceByKey((i1, i2) -&gt; i1 + i2);wordCounts.print();jsc.start();              // Start the computationjsc.awaitTermination();jsc.close();</code></pre><ul><li>example实时数据解析过程</li></ul><p><img src="/images/bigdata/3.jpg" srcset="/img/loading.gif" alt=""></p><pre><code>-------------------------------------------Time: 1586927760000 ms-------------------------------------------(jp,1)(jiaopan,2)(spark,2)Time: 1586927710000 ms-------------------------------------------(hive,2)</code></pre><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><ul><li>引入依赖</li></ul><pre><code class="lang-text">&lt;dependency&gt;    &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;    &lt;artifactId&gt;spark-streaming-kafka-0-10_2.11&lt;/artifactId&gt;    &lt;version&gt;2.4.5&lt;/version&gt;&lt;/dependency&gt;</code></pre><ul><li>example</li></ul><pre><code class="lang-java">SparkConf conf = new SparkConf().setAppName(&quot;spark streaming&quot;).setMaster(&quot;local[*]&quot;);JavaStreamingContext jsc = new JavaStreamingContext(conf,Durations.seconds(5));//kafka配置List&lt;String&gt; topics = Arrays.asList(&quot;user_data_topic&quot;.split(&quot;,&quot;));Map&lt;String,Object&gt; config = new HashMap&lt;String, Object&gt;();config.put(&quot;bootstrap.servers&quot;,&quot;localhost:6667&quot;);config.put(&quot;key.deserializer&quot;,&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);config.put(&quot;value.deserializer&quot;,&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);config.put(&quot;auto.offset.reset&quot;,&quot;earliest&quot;);config.put(&quot;group.id&quot;,&quot;group.demo.sys.smvp-998&quot;);JavaInputDStream&lt;ConsumerRecord&lt;String, String&gt;&gt; kafkaDStream = KafkaUtils.createDirectStream(jsc,                                                                LocationStrategies.PreferConsistent(),                                                                ConsumerStrategies.Subscribe(topics, config));JavaDStream&lt;String&gt; content = kafkaDStream.map(item-&gt;item.value());content.print();jsc.start();              // Start the computationjsc.awaitTermination();jsc.close();-------------------------------------------Time: 1586933770000 ms-------------------------------------------{&quot;opType&quot;:0,&quot;token&quot;:&quot;interface_6b&quot;,&quot;content&quot;:[{&quot;id&quot;:&quot;5bcfc4f9&quot;,&quot;user_id&quot;:140050,&quot;in_time&quot;:&quot;2020-04-07 09:35:04&quot;,&quot;act_code&quot;:&quot;order&quot;,&quot;act_value&quot;:4}]}{&quot;opType&quot;:0,&quot;token&quot;:&quot;interface_c6&quot;,&quot;content&quot;:[{&quot;id&quot;:&quot;dcb14f5a&quot;,&quot;user_id&quot;:0,&quot;in_time&quot;:&quot;2020-04-07 21:46:48&quot;,&quot;act_code&quot;:&quot;&quot;,&quot;act_value&quot;:0}]}</code></pre><h1 id="Structured-Streaming"><a href="#Structured-Streaming" class="headerlink" title="Structured Streaming"></a>Structured Streaming</h1><p><em>note</em>:<a href="http://spark.apache.org/docs/latest/structured-streaming-programming-guide.html" target="_blank" rel="noopener">http://spark.apache.org/docs/latest/structured-streaming-programming-guide.html</a></p><pre><code class="lang-java">SparkSession spark = SparkSession                .builder()                .master(&quot;local[*]&quot;)                .appName(&quot;JavaStructuredNetworkWordCount&quot;)                .getOrCreate();Dataset&lt;Row&gt; lines = spark.readStream().format(&quot;socket&quot;).option(&quot;host&quot;, &quot;localhost&quot;).option(&quot;port&quot;, 9999).load();StreamingQuery query = lines.writeStream().format(&quot;console&quot;).outputMode(OutputMode.Append()).start();query.awaitTermination();(base) jiaopandeMacBook-Pro:~ jiaopan$ nc -lk 9999spark i love -------------------------------------------Batch: 1-------------------------------------------+------------+|       value|+------------+|spark i love|+------------+</code></pre><pre><code>SparkSession spark = SparkSession                .builder()                .master(&quot;local[*]&quot;)                .appName(&quot;JavaStructuredNetworkWordCount&quot;)                .getOrCreate();Dataset&lt;Row&gt; lines = spark.readStream().format(&quot;socket&quot;).option(&quot;host&quot;, &quot;localhost&quot;).option(&quot;port&quot;, 9999).load();Dataset&lt;String&gt; words = lines.as(Encoders.STRING()).flatMap(line -&gt; Arrays.asList(line.split(&quot; &quot;)).iterator(), Encoders.STRING());Dataset&lt;Row&gt; wordCount = words.groupBy(&quot;value&quot;).count();StreamingQuery query = wordCount.writeStream().outputMode(OutputMode.Complete()).format(&quot;console&quot;).start();query.awaitTermination();(base) jiaopandeMacBook-Pro:~ jiaopan$ nc -lk 9999cat dog+-----+-----+|value|count|+-----+-----+|  dog|    1||  cat|    1|+-----+-----+(base) jiaopandeMacBook-Pro:~ jiaopan$ nc -lk 9999...cat dog owl+-----+-----+|value|count|+-----+-----+|  dog|    2||  cat|    2||  owl|    1|+-----+-----+</code></pre><p><img src="http://spark.apache.org/docs/latest/img/structured-streaming-example-model.png" srcset="/img/loading.gif" alt=""></p><h2 id="Window-Operations-on-Event-Time"><a href="#Window-Operations-on-Event-Time" class="headerlink" title="Window Operations on Event Time"></a>Window Operations on Event Time</h2><pre><code class="lang-java">SparkSession spark = SparkSession                .builder()                .master(&quot;local[*]&quot;)                .appName(&quot;JavaStructuredNetworkWordCount&quot;)                .getOrCreate();spark.sparkContext().setLogLevel(&quot;WARN&quot;);Dataset&lt;Row&gt; lines = spark.readStream().format(&quot;socket&quot;)                .option(&quot;host&quot;, &quot;localhost&quot;).option(&quot;port&quot;, 9999)                .option(&quot;includeTimestamp&quot;,true).load();Dataset&lt;Row&gt; words = lines.as(Encoders.tuple(Encoders.STRING(), Encoders.TIMESTAMP())).flatMap(        (FlatMapFunction&lt;Tuple2&lt;String, Timestamp&gt;, Tuple2&lt;String, Timestamp&gt;&gt;) item -&gt; {            List&lt;Tuple2&lt;String, Timestamp&gt;&gt; result = new ArrayList&lt;&gt;();            for (String word : item._1.split(&quot; &quot;)) {                result.add(new Tuple2&lt;&gt;(word, item._2));            }            return result.iterator();        }, Encoders.tuple(Encoders.STRING(), Encoders.TIMESTAMP())).toDF(&quot;word&quot;, &quot;timestamp&quot;);Dataset&lt;Row&gt; windowedCounts = words.groupBy(        //&lt;window duration&gt; 计算window duration时间范围内的数据        //&lt;slide duration&gt; 数据更新周期,        functions.window(words.col(&quot;timestamp&quot;), &quot;20 seconds&quot;, &quot;10 seconds&quot;),        words.col(&quot;word&quot;)).count().orderBy(&quot;window&quot;);StreamingQuery query = windowedCounts.writeStream()        .outputMode(OutputMode.Complete())        .option(&quot;truncate&quot;, &quot;false&quot;)        .format(&quot;console&quot;).start();query.awaitTermination();-------------------------------------------Batch: 1-------------------------------------------+------------------------------------------+----+-----+|window                                    |word|count|+------------------------------------------+----+-----+|[2020-04-23 11:02:00, 2020-04-23 11:02:20]|cat |1    ||[2020-04-23 11:02:00, 2020-04-23 11:02:20]|dog |1    ||[2020-04-23 11:02:10, 2020-04-23 11:02:30]|dog |1    ||[2020-04-23 11:02:10, 2020-04-23 11:02:30]|cat |1    |+------------------------------------------+----+-----+-------------------------------------------Batch: 2-------------------------------------------+------------------------------------------+----+-----+|window                                    |word|count|+------------------------------------------+----+-----+|[2020-04-23 11:02:00, 2020-04-23 11:02:20]|cat |1    ||[2020-04-23 11:02:00, 2020-04-23 11:02:20]|dog |1    ||[2020-04-23 11:02:10, 2020-04-23 11:02:30]|dog |1    ||[2020-04-23 11:02:10, 2020-04-23 11:02:30]|cat |1    ||[2020-04-23 11:02:20, 2020-04-23 11:02:40]|cat |1    ||[2020-04-23 11:02:20, 2020-04-23 11:02:40]|dog |2    ||[2020-04-23 11:02:30, 2020-04-23 11:02:50]|dog |2    ||[2020-04-23 11:02:30, 2020-04-23 11:02:50]|cat |1    |+------------------------------------------+----+-----+</code></pre><p><img src="http://spark.apache.org/docs/latest/img/structured-streaming-window.png" srcset="/img/loading.gif" alt=""></p><h2 id="Output-Sinks"><a href="#Output-Sinks" class="headerlink" title="Output Sinks"></a>Output Sinks</h2><pre><code class="lang-java">writeStream    .format(&quot;parquet&quot;)        // can be &quot;orc&quot;, &quot;json&quot;, &quot;csv&quot;, etc.    .option(&quot;path&quot;, &quot;path/to/destination/dir&quot;)    .start()writeStream    .format(&quot;kafka&quot;)    .option(&quot;kafka.bootstrap.servers&quot;, &quot;host1:port1,host2:port2&quot;)    .option(&quot;topic&quot;, &quot;updates&quot;)    .start()writeStream    .foreach(...)    .start()writeStream    .format(&quot;console&quot;)    .start()writeStream    .format(&quot;memory&quot;)    .queryName(&quot;tableName&quot;)    .start()</code></pre><h2 id="Kafka-1"><a href="#Kafka-1" class="headerlink" title="Kafka"></a>Kafka</h2><p><em>note</em>:<a href="http://spark.apache.org/docs/latest/structured-streaming-kafka-integration.html" target="_blank" rel="noopener">http://spark.apache.org/docs/latest/structured-streaming-kafka-integration.html</a></p><ul><li>引入依赖</li></ul><pre><code class="lang-text">&lt;dependency&gt;  &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;  &lt;artifactId&gt;spark-sql-kafka-0-10_2.11&lt;/artifactId&gt;  &lt;version&gt;2.4.5&lt;/version&gt;&lt;/dependency&gt;</code></pre><ul><li>example</li></ul><pre><code class="lang-java">SparkSession session = SparkSession        .builder()        .master(&quot;local[*]&quot;)        .appName(&quot;JavaStructuredNetworkWordCount&quot;)        .getOrCreate();session.sparkContext().setLogLevel(&quot;WARN&quot;);Dataset&lt;Row&gt; dataset = session.readStream().format(&quot;kafka&quot;)        .option(&quot;kafka.bootstrap.servers&quot;, &quot;localhost:6667&quot;)        .option(&quot;startingOffsets&quot;, &quot;earliest&quot;)        .option(&quot;subscribe&quot;,&quot;test_topic&quot;)        .option(&quot;group.id&quot;, &quot;group.demo.sys&quot;).load()        .selectExpr(&quot;CAST(value AS STRING)&quot;);StreamingQuery query = dataset.writeStream().format(&quot;console&quot;).start();query.awaitTermination();-------------------------------------------Batch: 0-------------------------------------------+--------------------+|               value|+--------------------+|{&quot;content&quot;:[{&quot;all...||{&quot;content&quot;:[{&quot;all...||{&quot;url&quot;:&quot;wlztk_sh_...||{&quot;url&quot;:&quot;wlztk_sh_...||{&quot;url&quot;:&quot;wlztk_sh_...||{&quot;content&quot;:[{&quot;all...||{&quot;url&quot;:&quot;wlztk_sh_...|+--------------------+only showing top 20 rows</code></pre><pre><code class="lang-java">Dataset&lt;Row&gt; df = spark  .readStream()  .format(&quot;kafka&quot;)  .option(&quot;kafka.bootstrap.servers&quot;, &quot;host1:port1,host2:port2&quot;)  .option(&quot;subscribe&quot;, &quot;topic1&quot;)  .load()df.selectExpr(&quot;CAST(key AS STRING)&quot;, &quot;CAST(value AS STRING)&quot;)// Subscribe to multiple topicsDataset&lt;Row&gt; df = spark  .readStream()  .format(&quot;kafka&quot;)  .option(&quot;kafka.bootstrap.servers&quot;, &quot;host1:port1,host2:port2&quot;)  .option(&quot;subscribe&quot;, &quot;topic1,topic2&quot;)  .load()df.selectExpr(&quot;CAST(key AS STRING)&quot;, &quot;CAST(value AS STRING)&quot;)// Subscribe to a patternDataset&lt;Row&gt; df = spark  .readStream()  .format(&quot;kafka&quot;)  .option(&quot;kafka.bootstrap.servers&quot;, &quot;host1:port1,host2:port2&quot;)  .option(&quot;subscribePattern&quot;, &quot;topic.*&quot;)  .load()df.selectExpr(&quot;CAST(key AS STRING)&quot;, &quot;CAST(value AS STRING)&quot;)</code></pre><pre><code class="lang-java">Dataset&lt;Row&gt; df = spark  .read()  .format(&quot;kafka&quot;)  .option(&quot;kafka.bootstrap.servers&quot;, &quot;host1:port1,host2:port2&quot;)  .option(&quot;subscribe&quot;, &quot;topic1&quot;)  .load();df.selectExpr(&quot;CAST(key AS STRING)&quot;, &quot;CAST(value AS STRING)&quot;);// Subscribe to multiple topics, specifying explicit Kafka offsetsDataset&lt;Row&gt; df = spark  .read()  .format(&quot;kafka&quot;)  .option(&quot;kafka.bootstrap.servers&quot;, &quot;host1:port1,host2:port2&quot;)  .option(&quot;subscribe&quot;, &quot;topic1,topic2&quot;)  .option(&quot;startingOffsets&quot;, &quot;{\&quot;topic1\&quot;:{\&quot;0\&quot;:23,\&quot;1\&quot;:-2},\&quot;topic2\&quot;:{\&quot;0\&quot;:-2}}&quot;)  .option(&quot;endingOffsets&quot;, &quot;{\&quot;topic1\&quot;:{\&quot;0\&quot;:50,\&quot;1\&quot;:-1},\&quot;topic2\&quot;:{\&quot;0\&quot;:-1}}&quot;)  .load();df.selectExpr(&quot;CAST(key AS STRING)&quot;, &quot;CAST(value AS STRING)&quot;);// Subscribe to a pattern, at the earliest and latest offsetsDataset&lt;Row&gt; df = spark  .read()  .format(&quot;kafka&quot;)  .option(&quot;kafka.bootstrap.servers&quot;, &quot;host1:port1,host2:port2&quot;)  .option(&quot;subscribePattern&quot;, &quot;topic.*&quot;)  .option(&quot;startingOffsets&quot;, &quot;earliest&quot;)  .option(&quot;endingOffsets&quot;, &quot;latest&quot;)  .load();df.selectExpr(&quot;CAST(key AS STRING)&quot;, &quot;CAST(value AS STRING)&quot;);</code></pre>]]></content>
    
    
    <categories>
      
      <category>spark</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>002.Spark Sql</title>
    <link href="/2020/04/12/spark.002/"/>
    <url>/2020/04/12/spark.002/</url>
    
    <content type="html"><![CDATA[<h1 id="spark-sql-hello-world"><a href="#spark-sql-hello-world" class="headerlink" title="spark sql-hello world"></a>spark sql-hello world</h1><p>1.引入依赖</p><pre><code class="lang-text">&lt;dependency&gt;    &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;    &lt;artifactId&gt;spark-sql_2.11&lt;/artifactId&gt;    &lt;version&gt;2.4.5&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>2.exmple程序</p><pre><code> public class Man implements Serializable{        private static final long serialVersionUID = 1L;        private String name;        private String age;        Man(String name,String age){            this.name = name;            this.age = age;        }        public String getName() {            return name;        }        public void setName(String name) {            this.name = name;        }        public String getAge() {            return age;        }        public void setAge(String age) {            this.age = age;        }}public static SparkConf conf = new SparkConf().setAppName(&quot;wordCount&quot;).setMaster(&quot;local[*]&quot;);public static JavaSparkContext sc = new JavaSparkContext(conf);SparkSession session = SparkSession.builder().appName(&quot;sql test&quot;).master(&quot;local[*]&quot;).getOrCreate();JavaRDD&lt;String&gt; lines = sc.parallelize(Arrays.asList(&quot;jeery 26&quot;,&quot;tony 23&quot;));JavaRDD&lt;Man&gt; mans = lines.map(line-&gt;{    String[] words = line.split(&quot; &quot;);    Man item = new Man(words[0],words[1]);    return item;});Dataset&lt;Row&gt; men = session.createDataFrame(mans,Man.class);men.createTempView(&quot;men&quot;);Dataset&lt;Row&gt; result = session.sql(&quot;select * from men order by age&quot;);result.show();session.stop();+---+-----+|age| name|+---+-----+| 23| tony|| 26|jeery|+---+-----+</code></pre><h1 id="StructType-定义schema"><a href="#StructType-定义schema" class="headerlink" title="StructType 定义schema"></a>StructType 定义schema</h1><ul><li>example -01</li></ul><pre><code class="lang-java">JavaRDD&lt;String&gt; lines = sc.parallelize(Arrays.asList(&quot;jeery 26&quot;,&quot;tony 23&quot;));JavaRDD&lt;Row&gt; mans = lines.map(line-&gt;{    String[] words = line.split(&quot; &quot;);    return RowFactory.create(words[0],words[1]);});StructType schema = new StructType(new StructField[] {    new StructField(&quot;name&quot;,DataTypes.StringType,true,Metadata.empty()),    new StructField(&quot;age&quot;,DataTypes.StringType,true,Metadata.empty()),});Dataset&lt;Row&gt; men = session.createDataFrame(mans,schema);men.printSchema();men.show();men.createTempView(&quot;men&quot;);Dataset&lt;Row&gt; result = session.sql(&quot;select * from men order by age&quot;);result.show();root |-- name: string (nullable = true) |-- age: string (nullable = true)+-----+---+| name|age|+-----+---+|jeery| 26|| tony| 23|+-----+---++-----+---+| name|age|+-----+---+| tony| 23||jeery| 26|+-----+---+</code></pre><ul><li>example-02</li></ul><pre><code class="lang-java">StructType schema = new StructType(new StructField[] {    new StructField(&quot;name&quot;,DataTypes.StringType,true,Metadata.empty()),    new StructField(&quot;age&quot;,DataTypes.StringType,true,Metadata.empty()),});List&lt;Row&gt; rows = new ArrayList&lt;Row&gt;();rows.add(RowFactory.create(&quot;jiaopan&quot;,&quot;26&quot;));rows.add(RowFactory.create(&quot;jp&quot;,&quot;23&quot;));Dataset&lt;Row&gt; men = session.createDataFrame(rows,schema);men.printSchema();men.show();+-------+---+|   name|age|+-------+---+|jiaopan| 26||     jp| 23|+-------+---+</code></pre><h1 id="json-读取json文件自动创建DataFrame"><a href="#json-读取json文件自动创建DataFrame" class="headerlink" title="json 读取json文件自动创建DataFrame"></a>json 读取json文件自动创建DataFrame</h1><ul><li>user.json</li></ul><pre><code class="lang-text">{&quot;name&quot;:&quot;jiaopan&quot;,&quot;age&quot;:&quot;26&quot;}{&quot;name&quot;:&quot;jp&quot;,&quot;age&quot;:&quot;39&quot;}{&quot;name&quot;:&quot;chengdu&quot;,&quot;age&quot;:&quot;19&quot;}</code></pre><pre><code class="lang-java">Dataset&lt;Row&gt; users = session.read().json(&quot;/Volumes/storage/macbook-pro/programming/java-projects/spark.learning/user.json&quot;);users.printSchema();users.show();root |-- age: string (nullable = true) |-- name: string (nullable = true)+---+-------+|age|   name|+---+-------+| 26|jiaopan|| 39|     jp|| 19|chengdu|+---+-------+</code></pre><ul><li>user.json</li></ul><pre><code class="lang-text">{&quot;name&quot;:&quot;jiaopan&quot;,&quot;age&quot;:26,&quot;address&quot;:&quot;成都市&quot;}{&quot;name&quot;:&quot;jp&quot;,&quot;age&quot;:39,&quot;phone&quot;:&quot;18088886666&quot;}{&quot;name&quot;:&quot;chengdu&quot;,&quot;age&quot;:19}</code></pre><pre><code class="lang-java">Dataset&lt;Row&gt; users = session.read().json(&quot;/Volumes/storage/macbook-pro/programming/java-projects/spark.learning/user.json&quot;);users.printSchema();users.show();root |-- address: string (nullable = true) |-- age: string (nullable = true) |-- name: string (nullable = true) |-- phone: string (nullable = true)+-------+---+-------+-----------+|address|age|   name|      phone|+-------+---+-------+-----------+|  成都市| 26|jiaopan|       null||   null| 39|     jp|18088886666||   null| 19|chengdu|       null|+-------+---+-------+-----------+</code></pre><h1 id="CSV-读取csv文件自动创建DataFrame"><a href="#CSV-读取csv文件自动创建DataFrame" class="headerlink" title="CSV 读取csv文件自动创建DataFrame"></a>CSV 读取csv文件自动创建DataFrame</h1><ul><li>user.csv</li></ul><pre><code class="lang-text">jiaopan,26,成都市jp,39,18088886666chengdu,19</code></pre><pre><code class="lang-java">Dataset&lt;Row&gt; users = session.read().csv(&quot;/Volumes/storage/macbook-pro/programming/java-projects/spark.learning/user.csv&quot;);users.printSchema();users.show();root |-- _c0: string (nullable = true) |-- _c1: string (nullable = true) |-- _c2: string (nullable = true)+-------+---+-----------+|    _c0|_c1|        _c2|+-------+---+-----------+|jiaopan| 26|      成都市||     jp| 39|18088886666||chengdu| 19|       null|+-------+---+-----------+</code></pre><ul><li>user.csv</li></ul><pre><code class="lang-text">name,age,phone,addressjiaopan,26,&quot;&quot;,成都市jp,39,18088886666,&quot;&quot;chengdu,19,&quot;&quot;,&quot;&quot;</code></pre><pre><code class="lang-java">Dataset&lt;Row&gt; users = session.read()                            .option(&quot;header&quot;,true) //设置第一行为表头                            .option(&quot;inferSchema&quot;, true) //推断数据类型                            .csv(&quot;/Volumes/storage/macbook-pro/programming/java-projects/spark.learning/user.csv&quot;);users.printSchema();users.show();root |-- name: string (nullable = true) |-- age: integer (nullable = true) |-- phone: long (nullable = true) |-- address: string (nullable = true)+-------+---+-----------+-------+|   name|age|      phone|address|+-------+---+-----------+-------+|jiaopan| 26|       null|  成都市||     jp| 39|18088886666|   null||chengdu| 19|       null|   null|+-------+---+-----------+-------+</code></pre><h1 id="DSL-API"><a href="#DSL-API" class="headerlink" title="DSL API"></a>DSL API</h1><pre><code class="lang-java">Dataset&lt;Row&gt; users = session.read()                            .option(&quot;header&quot;,true) //设置第一行为表头                            .option(&quot;inferSchema&quot;, true) //推断数据类型                            .csv(&quot;/Volumes/storage/macbook-pro/programming/java-projects/spark.learning/user.csv&quot;);Dataset&lt;Row&gt; result = users.select(&quot;name&quot;,&quot;age&quot;).where(&quot;age &gt;=20&quot;);result.show();+-------+---+|   name|age|+-------+---+|jiaopan| 26||     jp| 39|+-------+---+</code></pre><h1 id="word-count"><a href="#word-count" class="headerlink" title="word count"></a>word count</h1><pre><code class="lang-java">Dataset&lt;String&gt; lines = session.read().textFile(&quot;/Volumes/storage/learn/bigdata/data/words.txt&quot;);lines.show();Dataset&lt;String&gt; words = lines.flatMap(line-&gt;Arrays.asList(line.split(&quot; &quot;)).iterator(),Encoders.STRING());words.show();words.createTempView(&quot;words&quot;);Dataset&lt;Row&gt; result = session.sql(&quot;select value word,count(*) count from words group by word&quot;);result.show();+--------------------+|               value|+--------------------+|         spark spark||hive hive hive hello||mysql jiaopan jia...|+--------------------++-------+|  value|+-------+|  spark||  spark||   hive||   hive||   hive||  hello||  mysql||jiaopan||jiaopan|+-------++-------+-----+|   word|count|+-------+-----+|  hello|    1||jiaopan|    2||  mysql|    1||  spark|    2||   hive|    3|+-------+-----+Dataset&lt;Row&gt; DSlresult = words.withColumnRenamed(&quot;value&quot;,&quot;word&quot;).select(&quot;*&quot;).groupBy(&quot;word&quot;).count();DSlresult.show();+-------+-----+|   word|count|+-------+-----+|  hello|    1||jiaopan|    2||  mysql|    1||  spark|    2||   hive|    3|+-------+-----+Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();map.put(&quot;*&quot;,&quot;count&quot;);Dataset&lt;Row&gt; DSlresult = words.withColumnRenamed(&quot;value&quot;,&quot;word&quot;).select(&quot;*&quot;).groupBy(&quot;word&quot;).agg(map);DSlresult.show();+-------+--------+|   word|count(1)|+-------+--------+|  hello|       1||jiaopan|       2||  mysql|       1||  spark|       2||   hive|       3|+-------+--------+</code></pre><h1 id="JDBC-读取数据库"><a href="#JDBC-读取数据库" class="headerlink" title="JDBC 读取数据库"></a>JDBC 读取数据库</h1><pre><code class="lang-java">Properties properties = new  Properties();properties.setProperty(&quot;driver&quot;,&quot;com.mysql.jdbc.Driver&quot;);properties.setProperty(&quot;user&quot;,&quot;root&quot;);properties.setProperty(&quot;password&quot;,&quot;123456&quot;);String jdbc = &quot;jdbc:mysql://localhost:3306/intelligent_agriculture?characterEncoding=UTF-8&quot;;Dataset&lt;Row&gt; result = session.read().jdbc(jdbc,&quot;sys_user&quot;, properties);result.show();+-------------------+--------+--------------------+------+--------+-----+------+-----------+|                 id|username|            password|   tel|org_code|level|status|create_date|+-------------------+--------+--------------------+------+--------+-----+------+-----------+|1057796353167527937|   admin|eac4108912af90ae9...|    23| 1001011|    0|     1| 2018-11-01||1102890947181555714|    demo|36a7c9e95a47010a2...|      |  100101|    1|     1| 2019-03-05||1120927990138572801|    test|2df51a84abc64a287...|123456|  100101|    1|     1| 2019-04-24|+-------------------+--------+--------------------+------+--------+-----+------+-----------+</code></pre><h1 id="Parquet"><a href="#Parquet" class="headerlink" title="Parquet"></a>Parquet</h1><pre><code class="lang-java">Properties properties = new  Properties();properties.setProperty(&quot;driver&quot;,&quot;com.mysql.jdbc.Driver&quot;);properties.setProperty(&quot;user&quot;,&quot;root&quot;);properties.setProperty(&quot;password&quot;,&quot;123456&quot;);String jdbc = &quot;jdbc:mysql://localhost:3306/intelligent_agriculture?characterEncoding=UTF-8&quot;;Dataset&lt;Row&gt; result = session.read().jdbc(jdbc,&quot;sys_user&quot;, properties);result.show();result.write().parquet(&quot;/Volumes/storage/learn/bigdata/data/out&quot;);Dataset&lt;Row&gt; parquet = session.read().parquet(&quot;/Volumes/storage/learn/bigdata/data/out&quot;);</code></pre><pre><code class="lang-bash">20/04/13 14:12:14 INFO ParquetWriteSupport: Initialized Parquet WriteSupport with Catalyst schema:{  &quot;type&quot; : &quot;struct&quot;,  &quot;fields&quot; : [ {    &quot;name&quot; : &quot;id&quot;,    &quot;type&quot; : &quot;string&quot;,    &quot;nullable&quot; : true,    &quot;metadata&quot; : { }  },...]}and corresponding Parquet message type:message spark_schema {  optional binary id (UTF8);  optional binary username (UTF8);  optional binary password (UTF8);  optional binary tel (UTF8);  optional binary org_code (UTF8);  optional int32 level;  optional int32 status;  optional int32 create_date (DATE);}+-------------------+--------+--------------------+------+--------+-----+------+-----------+|                 id|username|            password|   tel|org_code|level|status|create_date|+-------------------+--------+--------------------+------+--------+-----+------+-----------+|1057796353167527937|   admin|eac4108912af90ae9...|    23| 1001011|    0|     1| 2018-11-01||1102890947181555714|    demo|36a7c9e95a47010a2...|      |  100101|    1|     1| 2019-03-05||1120927990138572801|    test|2df51a84abc64a287...|123456|  100101|    1|     1| 2019-04-24|+-------------------+--------+--------------------+------+--------+-----+------+-----------+</code></pre><h1 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h1><ul><li>引入依赖</li></ul><pre><code class="lang-text">&lt;dependency&gt;  &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;  &lt;artifactId&gt;spark-hive_2.11&lt;/artifactId&gt;  &lt;version&gt;2.4.5&lt;/version&gt;&lt;/dependency&gt;</code></pre><ul><li>配置</li></ul><p>将hive/conf/hive-site.xml复制至spark/conf目录</p><p><strong>note</strong>：若hive版本3.0+，则需配置hive-site.xml中ACID配置项为false,spark才可访问hive,否则只能访问hive外部表</p><ul><li>开启hive支持</li></ul><pre><code class="lang-java">SparkSession session = SparkSession.builder().appName(&quot;sql test&quot;)                                             .master(&quot;local[*]&quot;)                                             //利用thrift连接hive                                             .config(&quot;hive.metastore.uris&quot;, &quot;thrift://xodb-dev03:9083&quot;)                                             .enableHiveSupport()                                             .getOrCreate();session.sql(&quot;show databases&quot;).show();session.sql(&quot;use wl_test&quot;);session.sql(&quot;show tables&quot;).show();Dataset&lt;Row&gt; result = session.sql(&quot;select * from user_act limit 10&quot;);result.show();+------------+|databaseName|+------------+|     default||         sys||        tpch||   warehouse||     wl_test|+------------++--------+---------+-----------+|database|tableName|isTemporary|+--------+---------+-----------+| wl_test| user_act|      false|+--------+---------+-----------++-------+-------+------+-----------+|user_id|item_id|rating|create_time|+-------+-------+------+-----------+|    196|    242|     3|  881250949||    186|    302|     3|  891717742||     22|    377|     1|  878887116||    244|     51|     2|  880606923||    166|    346|     1|  886397596||    298|    474|     4|  884182806||    115|    265|     2|  881171488||    253|    465|     5|  891628467||    305|    451|     3|  886324817||      6|     86|     3|  883603013|+-------+-------+------+-----------+</code></pre><p><em>note</em>：</p><p><a href="http://spark.apache.org/docs/latest/sql-programming-guide.html" target="_blank" rel="noopener">http://spark.apache.org/docs/latest/sql-programming-guide.html</a></p><p><a href="http://spark.apache.org/docs/latest/api/sql/index.html" target="_blank" rel="noopener">http://spark.apache.org/docs/latest/api/sql/index.html</a></p>]]></content>
    
    
    <categories>
      
      <category>spark</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>001.Spark RDD</title>
    <link href="/2020/04/09/spark.001/"/>
    <url>/2020/04/09/spark.001/</url>
    
    <content type="html"><![CDATA[<h1 id="spark-hello-world"><a href="#spark-hello-world" class="headerlink" title="spark-hello world"></a>spark-hello world</h1><p>1.创建maven项目spark-note,添加Spark依赖,新建TestSpark.java类<br><br>2.引入依赖和打包插件</p><pre><code class="lang-text">&lt;dependency&gt;  &lt;groupId&gt;org.scala-lang&lt;/groupId&gt;  &lt;artifactId&gt;scala-library&lt;/artifactId&gt;  &lt;version&gt;2.11.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;  &lt;artifactId&gt;spark-core_2.11&lt;/artifactId&gt;  &lt;version&gt;2.4.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;  &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt;  &lt;version&gt;2.7.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;junit&lt;/groupId&gt;  &lt;artifactId&gt;junit&lt;/artifactId&gt;  &lt;version&gt;3.8.1&lt;/version&gt;  &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;</code></pre><pre><code class="lang-text">&lt;build&gt;      &lt;plugins&gt;       &lt;plugin&gt;         &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;         &lt;version&gt;2.3.2&lt;/version&gt;         &lt;configuration&gt;             &lt;source&gt;1.8&lt;/source&gt;             &lt;target&gt;1.8&lt;/target&gt;         &lt;/configuration&gt;     &lt;/plugin&gt;     &lt;plugin&gt;        &lt;artifactId&gt; maven-assembly-plugin &lt;/artifactId&gt;            &lt;configuration&gt;             &lt;descriptorRefs&gt;                 &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;             &lt;/descriptorRefs&gt;             &lt;archive&gt;                  &lt;manifest&gt;                       &lt;mainClass&gt;jiaopaner.spark.learning.App&lt;/mainClass&gt;                  &lt;/manifest&gt;             &lt;/archive&gt;                &lt;/configuration&gt;        &lt;executions&gt;             &lt;execution&gt;                  &lt;id&gt;make-assembly&lt;/id&gt;                  &lt;phase&gt;package&lt;/phase&gt;                  &lt;goals&gt;                       &lt;goal&gt;single&lt;/goal&gt;                  &lt;/goals&gt;             &lt;/execution&gt;        &lt;/executions&gt;       &lt;/plugin&gt;    &lt;/plugins&gt;  &lt;/build&gt;</code></pre><p>3.创建word.txt</p><pre><code class="lang-text">spark sparkhive hive hive hellomysql jiaopan jiaopan</code></pre><p>4.编写处理程序</p><pre><code class="lang-java">public class App {    public static void main( String[] args ){        SparkConf conf = new SparkConf().setAppName(&quot;wordCount&quot;).setMaster(&quot;local[*]&quot;);//local[*]本地模式        JavaSparkContext sc = new JavaSparkContext(conf);        JavaRDD&lt;String&gt; lines = sc.textFile(&quot;/Volumes/storage/learn/bigdata/data/words.txt&quot;);        JavaRDD&lt;String&gt; words = lines.flatMap(line-&gt;Arrays.asList(line.split(&quot; &quot;)).iterator());        JavaPairRDD&lt;String, Integer&gt; wordAndOne = words.mapToPair(word-&gt;Tuple2.apply(word,1));        JavaPairRDD&lt;String, Integer&gt; reduced = wordAndOne.reduceByKey((a,b)-&gt;a+b);        JavaPairRDD&lt;Integer,String&gt; swapped = reduced.mapToPair(reduce-&gt;reduce.swap());        JavaPairRDD&lt;Integer,String&gt; sorted = swapped.sortByKey(false);        JavaPairRDD&lt;String, Integer&gt; result = sorted.mapToPair(sort-&gt;sort.swap());        result.saveAsTextFile(&quot;/Volumes/storage/learn/bigdata/data/out.txt&quot;);        sc.close();    }}</code></pre><p>5.执行结果</p><p><img src="\images\bigdata\2.png" srcset="/img/loading.gif" alt=""></p><p>其中part-00000和part-00001分别保存了结果，内容如下</p><pre><code class="lang-text">(hive,3)(jiaopan,2)(spark,2)(mysql,1)(hello,1)</code></pre><p>6.提交到集群执行</p><p>将words.txt上传HDFS系统，修改部分代码</p><pre><code class="lang-java">SparkConf conf = new SparkConf()         .setAppName(&quot;WordCount&quot;);          //.setMaster(&quot;local&quot;);//注释掉JavaSparkContext sc = new JavaSparkContext(conf);JavaRDD&lt;String&gt; lines = sc.textFile(&quot;hdfs://node:8020/words.txt&quot;);//读取HDFS文件result.saveAsTextFile(&quot;/home/data/out.txt&quot;);// hdfs://node:8020  -&gt;登陆ambari查看HDFS core-site配置可知</code></pre><p>7.打包程序并上传到集群</p><p>上传spark-note-0.0.1-SNAPSHOT-jar-with-dependencies.jar到spark集群主机节点上</p><p>8.提交任务执行</p><pre><code class="lang-bash">[root@node spark]# spark-submit --class jiaopaner.spark.learning.App --master spark://master:7077 --num-executors 1  --executor-cores 1 /home/spark/spark-note-0.0.1-SNAPSHOT-jar-with-dependencies.jar</code></pre><p>9.可通过master:4040可查看任务执行进度</p><h1 id="transform算子"><a href="#transform算子" class="headerlink" title="transform算子"></a>transform算子</h1><ul><li>map(func)：返回一个新的RDD，每个数据项通过map中的函数func转换</li></ul><pre><code class="lang-java">JavaRDD&lt;Integer&gt; nums = sc.parallelize(Arrays.asList(1,2,3,4));JavaRDD&lt;Integer&gt; newNums =  nums.map(num-&gt;num*2);System.out.println(newNums.collect());[2, 4, 6, 8]</code></pre><ul><li>flatMap(func):返回一个新的RDD,将旧RDD中的每个元素通过函数func转换为新的元素，并将生成的RDD的每个集合中的元素合并为一个集合</li></ul><pre><code class="lang-java">JavaRDD&lt;String&gt; lines = sc.parallelize(Arrays.asList(&quot;hello java&quot;,&quot;hello hive&quot;));JavaRDD&lt;String&gt; words= lines.flatMap(line-&gt;Arrays.asList(line.split(&quot; &quot;)).iterator());System.out.println(words.collect());[hello, java, hello, hive]JavaRDD&lt;List&lt;String&gt;&gt; lists = sc.parallelize(Arrays.asList(Arrays.asList(&quot;a b&quot;,&quot;c d&quot;),Arrays.asList(&quot;e f&quot;,&quot;g h&quot;)));JavaRDD&lt;String&gt; items = lists.flatMap(list-&gt;list.stream().flatMap(item-&gt;Arrays.asList(item.split(&quot; &quot;)).stream()).iterator());System.out.println(items.collect());[a, b, c, d, e, f, g, h]</code></pre><ul><li>filter(func)：返回一个新的RDD，经过func函数后返回值为true的元素保留</li></ul><pre><code class="lang-java">JavaRDD&lt;Integer&gt; numbers = sc.parallelize(Arrays.asList(1,2,3,4));JavaRDD&lt;Integer&gt; newNumbers = numbers.filter(num-&gt;num &gt; 2);System.out.println(newNumbers.collect());[3,4]</code></pre><ul><li>mapPartitions(func):返回一个新的RDD,分区处理数据，func的函数类型为Iterator[T] =&gt; Iterator[U]</li></ul><pre><code class="lang-java">JavaRDD&lt;Integer&gt; numbers = sc.parallelize(Arrays.asList(1,2,3,4,5,6,7,8,9),3);JavaRDD&lt;Integer&gt; newNumbers = numbers.mapPartitions(it-&gt;{    List&lt;Integer&gt; nums = new ArrayList&lt;Integer&gt;();    while(it.hasNext()) {        nums.add(it.next() * 2);    }    return nums.iterator();});System.out.println(newNumbers.collect());[2, 4, 6, 8, 10, 12, 14, 16, 18]</code></pre><ul><li>mapPartitionsWithIndex(func):返回一个新的RDD,分区处理数据,func带有一个整数参数表示分区的索引值,func的函数类型是(Int, Interator[T]) =&gt; Iterator[U]</li></ul><pre><code class="lang-java">JavaRDD&lt;Integer&gt; numbers = sc.parallelize(Arrays.asList(1,2,3,4,5,6,7,8,9),3);numbers.mapPartitionsWithIndex((index,it)-&gt;{    while(it.hasNext()) {        System.out.println(index+&quot;:&quot;+it.next());    }    return it;},true).count();1:41:51:60:12:70:22:80:32:9</code></pre><ul><li>union(otherDataset):合并两个RDD</li></ul><pre><code class="lang-java">JavaRDD&lt;Integer&gt; numbers = sc.parallelize(Arrays.asList(1,2,3,4,5,6,7,8,9));JavaRDD&lt;Integer&gt; union = numbers.union(sc.parallelize(Arrays.asList(10,11)));System.out.println(union.collect());[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]</code></pre><ul><li>intersection(otherDataset):返回两个RDD的交集</li></ul><pre><code class="lang-java">JavaRDD&lt;Integer&gt; numbers = sc.parallelize(Arrays.asList(1,2,3,4,5,6,7,8,9));JavaRDD&lt;Integer&gt; intersection = numbers.intersection(sc.parallelize(Arrays.asList(1,7,8,10)));System.out.println(intersection.collect());[1,7,8]</code></pre><ul><li>subtract(otherDataset):返回两个RDD的差集</li></ul><pre><code class="lang-java">JavaRDD&lt;Integer&gt; numbers = sc.parallelize(Arrays.asList(1,2,3,4,5,6,7,8,9));JavaRDD&lt;Integer&gt; subtract = numbers.subtract(sc.parallelize(Arrays.asList(7,8)));System.out.println(subtract.collect());[1, 2, 3, 4, 5, 6, 9]</code></pre><ul><li>sortByKey([ascending], [numTasks]):(K,V)类型的RDD上调用，返回按照key进行排序的(K,V)RDD</li></ul><pre><code class="lang-java">List&lt;Tuple2&lt;Integer, String&gt;&gt; list = new ArrayList&lt;Tuple2&lt;Integer,String&gt;&gt;();list.add(new Tuple2&lt;Integer,String&gt;(1,&quot;java&quot;));list.add(new Tuple2&lt;Integer,String&gt;(9,&quot;spark&quot;));list.add(new Tuple2&lt;Integer,String&gt;(6,&quot;hive&quot;));JavaPairRDD&lt;Integer,String&gt; tuples = sc.parallelize(list).mapToPair(t-&gt;t);JavaPairRDD&lt;Integer,String&gt; sorted = tuples.sortByKey(false);//倒序System.out.println(sorted.collect());[(9,spark), (6,hive), (1,java)]</code></pre><ul><li>sortBy(func,[ascending], [numTasks]):灵活,可指定排序字段</li></ul><pre><code class="lang-java">List&lt;Tuple2&lt;String,Integer&gt;&gt; list = new ArrayList&lt;Tuple2&lt;String,Integer&gt;&gt;();list.add(new Tuple2&lt;String,Integer&gt;(&quot;java&quot;,1));list.add(new Tuple2&lt;String,Integer&gt;(&quot;spark&quot;,9));list.add(new Tuple2&lt;String,Integer&gt;(&quot;hive&quot;,6));JavaRDD&lt;Tuple2&lt;String,Integer&gt;&gt; tuples = sc.parallelize(list);JavaRDD&lt;Tuple2&lt;String,Integer&gt;&gt; sorted = tuples.sortBy(tuple-&gt;tuple._2,true,3);System.out.println(sorted.collect());[(java,1), (hive,6), (spark,9)]</code></pre><ul><li>groupByKey([numTasks]):(K,V)类型的RDD上调用，返回按照key进行分组的(K, Iterator[V])的RDD</li></ul><pre><code class="lang-java">List&lt;Tuple2&lt;String,Integer&gt;&gt; list = new ArrayList&lt;Tuple2&lt;String,Integer&gt;&gt;();list.add(new Tuple2&lt;String,Integer&gt;(&quot;java&quot;,1));list.add(new Tuple2&lt;String,Integer&gt;(&quot;spark&quot;,9));list.add(new Tuple2&lt;String,Integer&gt;(&quot;hive&quot;,6));list.add(new Tuple2&lt;String,Integer&gt;(&quot;spark&quot;,19));list.add(new Tuple2&lt;String,Integer&gt;(&quot;hive&quot;,10));JavaPairRDD&lt;String,Integer&gt; tuples = sc.parallelize(list).mapToPair(item-&gt;item);JavaPairRDD&lt;String,Iterable&lt;Integer&gt;&gt; grouped = tuples.groupByKey();System.out.println(grouped.collect());[(spark,[9, 19]), (hive,[6, 10]), (java,[1])]</code></pre><ul><li>groupBy(func,[numTasks]):灵活,可指定按分组字段</li></ul><pre><code class="lang-java">List&lt;Tuple2&lt;String,Integer&gt;&gt; list = new ArrayList&lt;Tuple2&lt;String,Integer&gt;&gt;();list.add(new Tuple2&lt;String,Integer&gt;(&quot;java&quot;,1));list.add(new Tuple2&lt;String,Integer&gt;(&quot;spark&quot;,9));list.add(new Tuple2&lt;String,Integer&gt;(&quot;hive&quot;,6));list.add(new Tuple2&lt;String,Integer&gt;(&quot;spark&quot;,19));list.add(new Tuple2&lt;String,Integer&gt;(&quot;hive&quot;,10));JavaRDD&lt;Tuple2&lt;String,Integer&gt;&gt; tuples = sc.parallelize(list);JavaPairRDD&lt;Object,Iterable&lt;Tuple2&lt;String,Integer&gt;&gt;&gt; grouped = tuples.groupBy(item-&gt;item._1);System.out.println(grouped.collect());[(spark,[(spark,9), (spark,19)]), (hive,[(hive,6), (hive,10)]), (java,[(java,1)])]</code></pre><ul><li>reduceByKey(func, [numTasks])：(K,V)类型的RDD上调用，使用指定的func函数，将相同key的值聚合</li></ul><pre><code class="lang-java">List&lt;Tuple2&lt;String,Integer&gt;&gt; list = new ArrayList&lt;Tuple2&lt;String,Integer&gt;&gt;();list.add(new Tuple2&lt;String,Integer&gt;(&quot;java&quot;,1));list.add(new Tuple2&lt;String,Integer&gt;(&quot;spark&quot;,9));list.add(new Tuple2&lt;String,Integer&gt;(&quot;hive&quot;,6));list.add(new Tuple2&lt;String,Integer&gt;(&quot;spark&quot;,19));list.add(new Tuple2&lt;String,Integer&gt;(&quot;hive&quot;,10));JavaPairRDD&lt;String,Integer&gt; tuples = sc.parallelize(list).mapToPair(item-&gt;item);JavaPairRDD&lt;String,Integer&gt; reduced = tuples.reduceByKey((a,b)-&gt;a+b);System.out.println(reduced.collect());[(spark,28), (hive,16), (java,1)]</code></pre><ul><li>join(otherDataset, [numTasks]):类型为(K,V)和(K,W)的RDD上调用，返回相同key对应的所有元素对(K,(V,W))的RDD</li></ul><pre><code class="lang-java">List&lt;Tuple2&lt;String,String&gt;&gt; one = new ArrayList&lt;Tuple2&lt;String,String&gt;&gt;();one.add(new Tuple2&lt;String,String&gt;(&quot;java&quot;,&quot;java-001&quot;));one.add(new Tuple2&lt;String,String&gt;(&quot;spark&quot;,&quot;spark-001&quot;));one.add(new Tuple2&lt;String,String&gt;(&quot;hive&quot;,&quot;hive-001&quot;));JavaPairRDD&lt;String,String&gt; oneRdd = sc.parallelize(one).mapToPair(item-&gt;item);List&lt;Tuple2&lt;String,Integer&gt;&gt; two = new ArrayList&lt;Tuple2&lt;String,Integer&gt;&gt;();two.add(new Tuple2&lt;String,Integer&gt;(&quot;spark&quot;,1));two.add(new Tuple2&lt;String,Integer&gt;(&quot;hive&quot;,2));JavaPairRDD&lt;String,Integer&gt; twoRdd = sc.parallelize(two).mapToPair(item-&gt;item);JavaPairRDD&lt;String,Tuple2&lt;String,Integer&gt;&gt; joined = oneRdd.join(twoRdd);System.out.println(joined.collect());[(spark,(spark-001,1)), (hive,(hive-001,2))]</code></pre><ul><li>cogroup(otherDataset, [numTasks])：类型(K,V)和(K,W)的RDD上调用，返回(K,(Iterable,Iterable))类型的RDD</li></ul><pre><code class="lang-java">List&lt;Tuple2&lt;String,Object&gt;&gt; one = new ArrayList&lt;Tuple2&lt;String,Object&gt;&gt;();one.add(new Tuple2&lt;String,Object&gt;(&quot;java&quot;,&quot;java-001&quot;));one.add(new Tuple2&lt;String,Object&gt;(&quot;spark&quot;,&quot;spark-001&quot;));one.add(new Tuple2&lt;String,Object&gt;(&quot;hive&quot;,&quot;hive-001&quot;));JavaPairRDD&lt;String,Object&gt; oneRdd = sc.parallelize(one).mapToPair(item-&gt;item);List&lt;Tuple2&lt;String,Object&gt;&gt; two = new ArrayList&lt;Tuple2&lt;String,Object&gt;&gt;();two.add(new Tuple2&lt;String,Object&gt;(&quot;spark&quot;,&quot;spark-002&quot;));two.add(new Tuple2&lt;String,Object&gt;(&quot;hive&quot;,&quot;hive-002&quot;));JavaPairRDD&lt;String,Object&gt; twoRdd = sc.parallelize(two).mapToPair(item-&gt;item);JavaPairRDD&lt;String, Tuple2&lt;Iterable&lt;Object&gt;, Iterable&lt;Object&gt;&gt;&gt; cogrouped = oneRdd.cogroup(twoRdd);System.out.println(cogrouped.collect());[(spark,([spark-001],[spark-002])), (hive,([hive-001],[hive-002])), (java,([java-001],[]))]</code></pre><h1 id="action算子"><a href="#action算子" class="headerlink" title="action算子"></a>action算子</h1><ul><li>collect()：以数组的形式返回数据集所有元素</li><li>count()：返回RDD的元素个数</li><li>first():返回RDD的第一个元素</li><li>take(n):返回一个由数据集前n个元素组成的数组</li><li>saveAsTextFile(path):将数据集的元素以textfile的形式保存到HDFS文件系统或者其他支持的文件系统中</li><li>foreachPartition(func)：在数据集的每一个分区上，运行函数func</li><li>reduce(func, [numTasks])：全量聚合</li></ul><pre><code class="lang-java">List&lt;Tuple2&lt;String,Integer&gt;&gt; list = new ArrayList&lt;Tuple2&lt;String,Integer&gt;&gt;();list.add(new Tuple2&lt;String,Integer&gt;(&quot;java&quot;,1));list.add(new Tuple2&lt;String,Integer&gt;(&quot;spark&quot;,9));list.add(new Tuple2&lt;String,Integer&gt;(&quot;hive&quot;,6));list.add(new Tuple2&lt;String,Integer&gt;(&quot;spark&quot;,19));list.add(new Tuple2&lt;String,Integer&gt;(&quot;hive&quot;,10));JavaRDD&lt;Tuple2&lt;String,Integer&gt;&gt; tuples = sc.parallelize(list);Tuple2&lt;String,Integer&gt; reduced = tuples.reduce((a,b)-&gt;new Tuple2&lt;String,Integer&gt;(&quot;count&quot;, a._2+b._2));System.out.println(reduced);(count,45)</code></pre><h1 id="控制算子"><a href="#控制算子" class="headerlink" title="控制算子"></a>控制算子</h1><ul><li>cache：将数据缓存在内存</li><li>persist(newLevel:StorageLevel):缓存操作,StorageLevel枚举类型，代表存储模式</li></ul><p><em>note</em>:<a href="http://spark.apache.org/docs/latest/rdd-programming-guide.html" target="_blank" rel="noopener">http://spark.apache.org/docs/latest/rdd-programming-guide.html</a></p>]]></content>
    
    
    <categories>
      
      <category>spark</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>000.Spark Basement</title>
    <link href="/2020/04/08/spark.000/"/>
    <url>/2020/04/08/spark.000/</url>
    
    <content type="html"><![CDATA[<h1 id="Launching-Applications-with-spark-submit"><a href="#Launching-Applications-with-spark-submit" class="headerlink" title="Launching Applications with spark-submit"></a>Launching Applications with spark-submit</h1><pre><code class="lang-bash">./bin/spark-submit \  --class &lt;main-class&gt; \  --master &lt;master-url&gt; \  --deploy-mode &lt;deploy-mode&gt; \  --conf &lt;key&gt;=&lt;value&gt; \  ... # other options  &lt;application-jar&gt; \  [application-arguments]./bin/spark-submit \   --name &quot;My app&quot; \   --master local[4] \    --conf spark.eventLog.enabled=false \   --conf &quot;spark.executor.extraJavaOptions=-XX:+PrintGCDetails -XX:+PrintGCTimeStamps&quot; \   --conf spark.hadoop.abc.def=xyz \   myApp.jar</code></pre><ul><li>—class: Main方法 (e.g. org.apache.spark.examples.SparkPi)</li><li>—master: 集群master地址 (e.g. spark://23.195.26.187:7077)</li><li>—deploy-mode: driver on the worker nodes (cluster) or locally as an external client (client) (default: client) </li><li>—conf: Spark配置：key=value. <strong>more</strong>:<a href="http://spark.apache.org/docs/latest/configuration.html" target="_blank" rel="noopener">http://spark.apache.org/docs/latest/configuration.html</a></li><li>application-jar: jar包路径.(hdfs:// , file://,local)</li><li>application-arguments: Main方法的参数</li><li><strong>more options: ./bin/spark-submit —help</strong></li></ul><p><strong>master urls</strong></p><ul><li>local：本地单线程运行.</li><li>local[K]    ：本地K个线程运行，k=1,2,3,4,$…$ .</li><li>local[*]：    本地多线程运行，线程数基于当前CPU.</li><li>spark://HOST:PORT：    Spark standalone模式，port默认7077.<br>(<a href="http://spark.apache.org/docs/latest/spark-standalone.html" target="_blank" rel="noopener">http://spark.apache.org/docs/latest/spark-standalone.html</a>)</li><li>spark://HOST1:PORT1,HOST2:PORT2：Spark standalone模式    .</li><li>mesos://HOST:PORT：Mesos 模式，port默认5050.(<a href="http://spark.apache.org/docs/latest/running-on-mesos.html" target="_blank" rel="noopener">http://spark.apache.org/docs/latest/running-on-mesos.html</a>)</li><li>yarn：    YARN模式.(<a href="http://spark.apache.org/docs/latest/running-on-yarn.html" target="_blank" rel="noopener">http://spark.apache.org/docs/latest/running-on-yarn.html</a>)</li><li>k8s://HOST:PORT：Kubernetes模式.(<a href="http://spark.apache.org/docs/latest/running-on-kubernetes.html" target="_blank" rel="noopener">http://spark.apache.org/docs/latest/running-on-kubernetes.html</a>)</li></ul>]]></content>
    
    
    <categories>
      
      <category>spark</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pytorch 自定义数据集/训练/模型保存和加载</title>
    <link href="/2020/04/08/pytorch_prepare-data_create-model_train_valid_test_save-model_load-model/"/>
    <url>/2020/04/08/pytorch_prepare-data_create-model_train_valid_test_save-model_load-model/</url>
    
    <content type="html"><![CDATA[<h1 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h1><p><strong>1.第一种方式</strong><br><br>torchvision.datasets.ImageFolder<br><br><br>数据集文件需如下结构：<br><br>root<em>dir/cat/xxx.png<br><br>root_dir/cat/xxy.jpeg<br><br>…<br><br>root_dir/dog/nsdf3.png<br><br>root_dir/dog/asd932</em>.png<br></p><pre><code class="lang-python">import torchimport torchvisionfrom torchvision import transforms,datasetsimport osos.environ[&quot;KMP_DUPLICATE_LIB_OK&quot;]=&quot;TRUE&quot;</code></pre><pre><code class="lang-python">transform = transforms.Compose([    transforms.Resize([224,224]),    transforms.ToTensor(),    transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))])dataset = datasets.ImageFolder(root=&quot;/Volumes/storage/learn/machine-learning/notes/pytorch/data/dog_cat&quot;,                               transform=transform)dataloader = torch.utils.data.DataLoader(dataset,batch_size=4,shuffle=True,num_workers=2)</code></pre><pre><code class="lang-python">import matplotlib.pyplot as pltimport numpy as nplabel_dict = (&quot;cat&quot;,&quot;dog&quot;)# 输出图像的函数def imshow(img):    img = img / 2 + 0.5     # unnormalize    npimg = img.numpy()    plt.imshow(np.transpose(npimg, (1, 2, 0)))    plt.show()# 随机获取训练图片dataiter = iter(dataloader)images, labels = dataiter.next()# 显示图片imshow(torchvision.utils.make_grid(images))plt.show()print(&#39; &#39;.join(&#39;%5s&#39; % label_dict[labels[j].item()] for j in range(4)))</code></pre><p><img src="\images\dp-net\output_4_0.png" srcset="/img/loading.gif" alt="png"></p><p>dog   cat   dog   cat</p><hr><p><strong>第二种方式(继承torch.utils.data.Dataset)</strong><br><br>实现：<br><br><strong>__len__(self):</strong> 返回数据集的大小<br><br><strong>__getitem__(self,index):</strong> 支持索引，获取第index个样本的数据和标签<br><br><br>假设数据集文件如下结构：<br><br>root_dir/cat.0.png<br><br>root_dir/cat.1.jpeg<br><br>…<br><br>root_dir/dog.0.jpg<br><br>root_dir/dog.1.png<br><br><br><br><strong>note:transform的输入图片格式:PIL.Image</strong></p><pre><code class="lang-python">import torchimport osfrom PIL import Imagefrom skimage import ioos.environ[&quot;KMP_DUPLICATE_LIB_OK&quot;]=&quot;TRUE&quot;</code></pre><pre><code class="lang-python">labels = (&quot;cat&quot;,&quot;dog&quot;)class dogCatData(torch.utils.data.Dataset):    def __init__(self,root_dir,transform=None):        self.root_dir = root_dir        self.transform = transform        self.files = []        for file in os.listdir(root_dir):            sample = {}            sample[&quot;file&quot;] = os.path.join(root_dir,file)            sample[&quot;label&quot;] = labels.index(file.split(&quot;.&quot;)[0])            self.files.append(sample)    def __len__(self):        return len(self.files )    def __getitem__(self,index):        sample = self.files[index]        #image = Image.open(sample[&quot;file&quot;])        image = io.imread(sample[&quot;file&quot;])        image = Image.fromarray(image)        label = sample[&quot;label&quot;]        if self.transform is not None:            image = self.transform(image)        return image,label</code></pre><pre><code class="lang-python">data = dogCatData(&quot;/Volumes/storage/learn/bigdata/data/dog_cat/train&quot;)print(data[0])</code></pre><pre><code>(&lt;PIL.Image.Image image mode=RGB size=208x257 at 0x1492917F0&gt;, 0)</code></pre><pre><code class="lang-python">import torchvisionfrom torchvision import transforms as transformstransform = transforms.Compose([    transforms.Resize([224,224]),    transforms.ToTensor(),    transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))])dataset = dogCatData(&quot;/Volumes/storage/learn/bigdata/data/dog_cat/train&quot;,transform)dataloader = torch.utils.data.DataLoader(dataset,batch_size=8,shuffle=True,num_workers=4)</code></pre><pre><code class="lang-python">import matplotlib.pyplot as pltimport numpy as nplabel_dict = (&quot;cat&quot;,&quot;dog&quot;)# 输出图像的函数def imshow(img):    img = img / 2 + 0.5     # unnormalize    npimg = img.numpy()    plt.imshow(np.transpose(npimg, (1, 2, 0)))    plt.show()# 随机获取训练图片dataiter = iter(dataloader)images, labels = dataiter.next()# 显示图片imshow(torchvision.utils.make_grid(images))plt.show()print(&#39; &#39;.join(&#39;%5s&#39; % label_dict[labels[j].item()] for j in range(8)))</code></pre><p><img src="\images\dp-net\output_10_0.png" srcset="/img/loading.gif" alt="png"></p><p>cat   cat   dog   dog   dog   dog   dog   cat</p><hr><h1 id="构建模型"><a href="#构建模型" class="headerlink" title="构建模型"></a>构建模型</h1><pre><code class="lang-python">import torchimport torch.nn as nn</code></pre><pre><code class="lang-python">class AlexNet(nn.Module):    def __init__(self,num_classes=2):        super(AlexNet, self).__init__()        self.features = nn.Sequential(            nn.Conv2d(3, 64, kernel_size=11, stride=4, padding=2),            nn.ReLU(inplace=True),            nn.MaxPool2d(kernel_size=3, stride=2),            nn.Conv2d(64, 192, kernel_size=5, padding=2),            nn.ReLU(inplace=True),            nn.MaxPool2d(kernel_size=3, stride=2),            nn.Conv2d(192, 384, kernel_size=3, padding=1),            nn.ReLU(inplace=True),            nn.Conv2d(384, 256, kernel_size=3, padding=1),            nn.ReLU(inplace=True),            nn.Conv2d(256, 256, kernel_size=3, padding=1),            nn.ReLU(inplace=True),            nn.MaxPool2d(kernel_size=3, stride=2),        )        self.avgpool = nn.AdaptiveAvgPool2d((6, 6))        self.classifier = nn.Sequential(            nn.Dropout(),            nn.Linear(256 * 6 * 6, 4096),            nn.ReLU(inplace=True),            nn.Dropout(),            nn.Linear(4096, 4096),            nn.ReLU(inplace=True),            nn.Linear(4096, num_classes),        )    def forward(self, x):        x = self.features(x)        x = self.avgpool(x)        x = torch.flatten(x, 1)        x = self.classifier(x)        return x</code></pre><pre><code class="lang-python">model = AlexNet(2)</code></pre><hr><h1 id="定义损失和优化器"><a href="#定义损失和优化器" class="headerlink" title="定义损失和优化器"></a>定义损失和优化器</h1><pre><code class="lang-python">import torch.optim as optimcriterion = nn.CrossEntropyLoss()optimizer = optim.SGD(net.parameters(), lr=0.001, momentum=0.9)</code></pre><hr><h1 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h1><pre><code class="lang-python">device = torch.device(&#39;cuda&#39;) if torch.cuda.is_available() else torch.device(&#39;cpu&#39;)print(device)</code></pre><pre><code class="lang-python">model.to(device)</code></pre><pre><code class="lang-python">model.to(device)for epoch in range(4):  # loop over the dataset multiple times    model.train()    running_loss = 0.0    for i, data in enumerate(dataloader):        # get the inputs        inputs, labels = data        inputs, labels = inputs.to(device), labels.to(device)        # zero the parameter gradients        optimizer.zero_grad()        # forward + backward + optimize        outputs = model(inputs)        loss = criterion(outputs, labels)        loss.backward()        optimizer.step()        # print statistics        running_loss += loss.item()        if i % 1999 == 0:    # print every 2000 mini-batches            print(&#39;[%d, %5d] loss: %.3f&#39; % (epoch + 1, i + 1, running_loss / 2000))            running_loss = 0.0print(&#39;Finished Training&#39;)torch.save(model, &#39;dog_cat.pth&#39;)</code></pre><pre><code>[1,     1] loss: 0.636[1,     2] loss: 1.332[1,     3] loss: 2.026[1,     4] loss: 2.692[1,     5] loss: 3.386[1,     6] loss: 4.139[1,     7] loss: 4.776[1,     8] loss: 5.472[1,     9] loss: 6.108[1,    10] loss: 6.860[1,    11] loss: 7.555[1,    12] loss: 8.281[1,    13] loss: 8.915[1,    14] loss: 9.641[1,    15] loss: 10.338[1,    16] loss: 11.062[1,    17] loss: 11.697Finished Training</code></pre><hr><h1 id="模型保存和加载"><a href="#模型保存和加载" class="headerlink" title="模型保存和加载"></a>模型保存和加载</h1><p><strong>1.仅保存模型参数</strong></p><pre><code class="lang-python">import torch</code></pre><pre><code class="lang-python">torch.save(model.state_dict(), path) # savemodel.load_state_dict(torch.load(path)) # load# savestate = {&#39;model&#39;: model.state_dict(), &#39;optimizer&#39;: optimizer.state_dict(), &#39;epoch&#39;: epoch}torch.save(state, path)# loadcheckpoint = torch.load(path)model.load_state_dict(checkpoint[&#39;model&#39;])optimizer.load_state_dict(checkpoint[&#39;optimizer&#39;])epoch = checkpoint([&#39;epoch&#39;])</code></pre><p><strong>2.保存/加载整个模型</strong></p><pre><code class="lang-python">torch.save(model, path)model = torch.load(path)</code></pre><hr>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小贴士</title>
    <link href="/2020/04/03/%E5%B0%8F%E8%B4%B4%E5%A3%AB/"/>
    <url>/2020/04/03/%E5%B0%8F%E8%B4%B4%E5%A3%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p><strong>Q： Visual Studio 编译工程报错:error C4996: ‘strtok’: This function or variable may be unsafe. Consider using strtok_s instead</strong></p><p>工程属性 —&gt;C/C++ —&gt; 预处理器 —&gt; 预处理器定义,添加宏定义</p><pre><code class="lang-cpp">_CRT_SECURE_NO_WARNINGS</code></pre><hr><p><strong>Q： pthread.h中报错：C2011“timespec”:“struct”类型重定义</strong></p><p>tim.h已定义，pthread.h添加如下代码：</p><pre><code class="lang-cpp">#if !defined( PTHREAD_H )#define PTHREAD_H#define HAVE_STRUCT_TIMESPEC</code></pre><p><strong>Q：Visual Studio 工程编译dll,接口的定义</strong></p><p>A：接口的头文件应如下声明：</p><pre><code class="lang-cpp">#define LIB_API __declspec(dllexport) //导出函数extern &quot;C&quot; {    LIB_API char*   say();}</code></pre><p><strong>Q：C++调用DLL</strong></p><ul><li><p>dll的创建</p><pre><code class="lang-c++">//test.h#ifdef __cplusplusextern &quot;C&quot; {#endif__declspec(dllexport) int add(int a,int b);#ifdef __cplusplus}#endif  // __cplusplus</code></pre><pre><code class="lang-c++">//test.cpp#include &quot;test.h&quot;int add(int a,int b) {    return a + b;}</code></pre><p>编译上述工程为dll，即生成test.dll，并复制到调用该dll工程的编译目录</p></li><li><p>dll的使用</p><pre><code class="lang-c++">#include&lt;Windows.h&gt;#includ&lt;iostream&gt;typedef int (*padd)(int,int);int main(int argc, char *argv[]){    HMODULE test = LoadLibrary(&quot;test.dll&quot;);    if (test != NULL){        padd add = (padd)GetProcAddress(test,&quot;add&quot;);        if (add != NULL){                std::cout &lt;&lt; add(1,0) &lt;&lt; std::endl;        }    }}</code></pre></li></ul><p><strong>Q:cmake 简单编译命令</strong></p><pre><code class="lang-bash">sudo tar -zxvf testcd testsudo mkdir buildcd build/sudo cmake -DCMAKE_INSTALL_PREFIX=/home/test .. #安装目录sudo make -j4 #编译sudo make install #安装sudo ldconfig #更新软连接</code></pre><p><strong>Q: mac安装LLVM</strong></p><pre><code class="lang-bash">$ cd where-you-want-llvm-to-live$ svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm$ cd llvm/tools$ svn co http://llvm.org/svn/llvm-project/cfe/trunk clang$ cd llvm/tools/clang/tools$ svn co http://llvm.org/svn/llvm-project/clang-tools-extra/trunk extra$ cd llvm/projects$ svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt$ cd llvm$ mkdir build$ cd build$ cmake -G &quot;Unix Makefiles&quot; ..$ make$ make install</code></pre><p><strong>Q:cJSON的使用</strong></p><pre><code class="lang-c++">#include &quot;cJSON.h&quot;cJSON  *root = cJSON_CreateObject();cJSON  *bboxs = cJSON_CreateArray();char *resultJson;cJSON_AddNumberToObject(root, &quot;status&quot;, 1);cJSON_AddStringToObject(root, &quot;msg&quot;, &quot;detect ok&quot;);cJSON_AddItemToObject(root, &quot;bboxs&quot;, bboxs);for (int i = 0; i &lt; 2; i++){  cJSON  *bbox;  cJSON_AddItemToArray(bboxs, bbox = cJSON_CreateObject());  cJSON_AddNumberToObject(bbox, &quot;score&quot;, 99);  cJSON_AddNumberToObject(bbox, &quot;x&quot;, 1);  cJSON_AddNumberToObject(bbox, &quot;y&quot;, 2);  cJSON_AddNumberToObject(bbox, &quot;width&quot;, 3);  cJSON_AddNumberToObject(bbox, &quot;height&quot;, 4);}resultJson = cJSON_PrintUnformatted(result);</code></pre><p><strong>Q:c#调用dll</strong></p><p>note:若dll为X64,则c#应编译x64,否则报错</p><pre><code class="lang-c#">using System;using System.Collections.Generic;using System.Linq;using System.Runtime.InteropServices;using System.Text;using System.Threading.Tasks;namespace test{    class Program    {        [DllImport(@&quot;facedetection.dll&quot;, EntryPoint = &quot;facedetect&quot;)]        extern static string facedetect(string src);        static void Main(string[] args)        {            string result = facedetect(&quot;test.jpg&quot;);            Console.WriteLine(result);            Console.ReadKey();        }    } }</code></pre><p><strong>Q：opencv Mat和byte互转</strong></p><pre><code class="lang-c++">unsigned char* matToBytes(Mat image){   int size = image.total() * image.elemSize();     unsigned char* bytes = new unsigned char[size];  // you will have to delete[] that later     std::memcpy(bytes, image.data, size * sizeof(unsigned char));     return bytes;}Mat bytesToMat(unsigned char* bytes,int width,int height){    Mat image = Mat(height,width,CV_8UC3,bytes).clone(); // make a copy    return image;}</code></pre><p><strong>Q:opencv Mat 转std::vector std::vector转std::string</strong></p><pre><code class="lang-c++">cv::Mat output = output.reshape(1, 1);std::vector&lt;double&gt; vetor = (std::vector&lt;double&gt;)output;std::stringstream ss;ss &lt;&lt; std::setprecision(16);//精度设置std::copy(vector.begin(), vector.end(), std::ostream_iterator&lt;double&gt;(ss, &quot;,&quot;));std::string values = ss.str();values.pop_back();//去掉末尾多余的分隔符std::cout &lt;&lt; values;Mat convertToMat(std::string str) {    std::vector&lt;double&gt; v;    std::stringstream ss(str);    ss &lt;&lt; std::setprecision(16);    std::string token;    while (std::getline(ss, token, &#39;,&#39;)) {        v.push_back(std::stod(token));    }    Mat output = cv::Mat(v, true).reshape(1, 1);    return output;}cv::FileStorage fs(&quot;../features.xml&quot;, cv::FileStorage::WRITE);fs &lt;&lt; &quot;features&quot; &lt;&lt; output;fs.release();</code></pre><p><strong>Q: opencv 截取图片的矩形区域</strong></p><pre><code class="lang-c++">rectangle(image, Rect(x, y, w, h), Scalar(0, 255, 0), 2);Mat dst = image(cv::Range(y,y+h),cv::Range(x,x+w));</code></pre><p><strong>Q: c++时间差计算</strong></p><pre><code class="lang-c++">#include &lt;chrono&gt;auto start = std::chrono::steady_clock::now();//do somethingauto end = std::chrono::steady_clock::now();std::chrono::duration&lt;double&gt; elapsed = end - start;std::cout &lt;&lt; &quot;elapsed:&quot; &lt;&lt; elapsed.count() &lt;&lt;&quot;s&quot;&lt;&lt; std::endl;</code></pre><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p><strong>Q：python打包发布</strong></p><p>1.项目根目录新建setup.py</p><pre><code class="lang-python">from distutils.core import setupsetup( name=&#39;test&#39;,  #打包的输出文件名 version=&#39;1.0.0&#39;, py_modules=[&#39;test&#39;] #打包的.py文件)</code></pre><p>依赖文件 requirements.txt生成</p><p>pip freeze &gt; requirements.txt</p><pre><code class="lang-text">opencv==3.4.2numpy==1.16.4scikit-image==0.15.0</code></pre><p>或者 conda list -e &gt; requirements.txt</p><pre><code class="lang-text">numpy=1.16.4opencv=3.4.2scikit-image=0.15.0</code></pre><p>2.项目根目录下执行命令</p><pre><code class="lang-bash">sudo python setup.py sdist</code></pre><p>生成dist目录且包含test-1.0.0.tar.gz分发包</p><p>3.安装：解压分发包并定位到解压目录后执行安装命令</p><pre><code class="lang-bash">pip install -r requirements.txt #安装依赖 或者 conda install --yes --file requirements.txtsudo python setup.py install</code></pre><p>4.使用</p><pre><code class="lang-python">import testtest.sayHello();//#调用模块的sayHello方法</code></pre><p><strong>Q:jupyter notebook 运行于指定的conda环境上</strong></p><pre><code class="lang-bash">conda install nb_conda #重启jupyter notebook 选择kernel即可</code></pre><p><strong>Q:设置jupyter notebook可远程访问</strong></p><pre><code class="lang-bash">$ jupyter notebook --generate-configWriting default config to: /home/adminpc/.jupyter/jupyter_notebook_config.py$ jupyter notebook passwordEnter password: Verify password: [NotebookPasswordApp] Wrote hashed password to /home/adminpc/.jupyter/jupyter_notebook_config.json$ vim /home/adminpc/.jupyter/jupyter_notebook_config.pyc.NotebookApp.ip=&#39;*&#39;# 密钥位于adminpc/.jupyter/jupyter_notebook_config.jsonc.NotebookApp.password = &#39;sha1:0f0fe326cb63:0e48570b0b0952dfe72fefb7bd012934968ea428&#39;c.NotebookApp.open_browser = Falsec.NotebookApp.port =8888 $ jupyter notebook [I 14:14:05.933 NotebookApp] Serving notebooks from local directory: /home/adminpc/jiaopan/projects[I 14:14:05.933 NotebookApp] The Jupyter Notebook is running at:[I 14:14:05.933 NotebookApp] http://admin-pc:8888/[I 14:14:05.933 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).</code></pre><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><p><strong>Q：iframe父/子页面互相调用方法</strong></p><pre><code class="lang-html">document.getElementById(&quot;iframeId&quot;).contentWindow.childMethod()/childVariable;parent.parentMethod()/parentVariable</code></pre><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p><strong>Q：springboot切面编程实例</strong></p><pre><code class="lang-java">@Aspect@Component@Slf4jpublic class WebLogAspect {    //定义一个切入点，对该包下的所有函数方法执行前，执行@Before()    @Pointcut(&quot;execution(public * com.jp.controller..*.*(..))&quot;)    public void webLog(){}    @Before(&quot;webLog()&quot;)    public void doBefore(JoinPoint joinPoint) throws Throwable {        // 接收到请求，记录请求内容        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();        HttpServletRequest request = attributes.getRequest();        // 记录下请求内容        log.info(&quot;URL : &quot; + request.getRequestURL().toString());        log.info(&quot;HTTP_METHOD : &quot; + request.getMethod());        log.info(&quot;IP : &quot; + request.getRemoteAddr());        log.info(&quot;CLASS_METHOD : &quot; + joinPoint.getSignature().getDeclaringTypeName() + &quot;.&quot; + joinPoint.getSignature().getName());        log.info(&quot;ARGS : &quot; + Arrays.toString(joinPoint.getArgs()));    }    @AfterReturning(returning = &quot;ret&quot;, pointcut = &quot;webLog()&quot;)    public void doAfterReturning(Object ret) throws Throwable {        // 处理完请求，返回内容        log.info(&quot;RESPONSE : &quot; + ret);    }}</code></pre><p><strong>Q：Mac，MavenReportException: Error while creating archive: Unable to find javadoc command: The environment variable JAVA_HOME is not correctly set</strong></p><p>在pom.xml文件中添加javadoc命令的位置</p><pre><code>&lt;properties&gt;     &lt;javadocExecutable&gt;/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/bin/javadoc&lt;/javadocExecutable&gt;&lt;/properties&gt;</code></pre><p><strong>Q：maven引入本地依赖</strong></p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.oracle&lt;/groupId&gt;    &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt;    &lt;scope&gt;system&lt;/scope&gt;    &lt;version&gt;1.0&lt;/version&gt;    &lt;systemPath&gt;${basedir}/lib/ojdbc6-11.2.0.1.0.jar&lt;/systemPath&gt;&lt;/dependency&gt;&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;configuration&gt;                &lt;includeSystemScope&gt;true&lt;/includeSystemScope&gt;                &lt;mainClass&gt;mainclass&lt;/mainClass&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre><p><strong>Q：普通maven项目打包配置</strong></p><pre><code class="lang-java">&lt;build&gt;   &lt;plugins&gt;    &lt;plugin&gt;     &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;     &lt;version&gt;2.3.2&lt;/version&gt;     &lt;configuration&gt;         &lt;source&gt;1.8&lt;/source&gt;         &lt;target&gt;1.8&lt;/target&gt;     &lt;/configuration&gt;  &lt;/plugin&gt;  &lt;plugin&gt;        &lt;artifactId&gt; maven-assembly-plugin&lt;/artifactId&gt;        &lt;configuration&gt;             &lt;descriptorRefs&gt;             &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;             &lt;/descriptorRefs&gt;             &lt;archive&gt;                  &lt;manifest&gt;                       &lt;mainClass&gt;jiaopaner.spark.learning.App&lt;/mainClass&gt;                  &lt;/manifest&gt;             &lt;/archive&gt;        &lt;/configuration&gt;        &lt;executions&gt;             &lt;execution&gt;                  &lt;id&gt;make-assembly&lt;/id&gt;                  &lt;phase&gt;package&lt;/phase&gt;                  &lt;goals&gt;                       &lt;goal&gt;single&lt;/goal&gt;                  &lt;/goals&gt;             &lt;/execution&gt;        &lt;/executions&gt;   &lt;/plugin&gt; &lt;/plugins&gt;  &lt;/build&gt;</code></pre><p><strong>Q:springboot-kafka集群</strong></p><pre><code class="lang-bash"># 显示启动./bin/kafka-server-start.sh ./config/server.properties# 在后台启动./bin/kafka-server-start.sh -daemon ./config/server.properties#创建topic# --create：表示创建# --zookeeper 后面的参数是zk的集群节点# --replication-factor 3 ：表示复本数# --partitions 3：表示分区数# --topic test：表示topic的主题名称./bin/kafka-topics.sh --create --zookeeper server01:2181,server02:2181,server03:2181 --replication-factor 3 --partitions 3 --topic test#查看topic./bin/kafka-topics.sh --list --zookeeper server01:2181#删除topic./bin/kafka-topics.sh --delete --zookeeper server01:2181 --topic test#生产者命令/bin/kafka-console-producer.sh --broker-list server01:9092 --topic test#消费者命令/bin/kafka-console-consumer.sh --zookeeper server01:2181 --from-beginning --topic test</code></pre><p><strong>Q:maven dependency scope设置</strong></p><ul><li>provided:编译和测试阶段依赖</li></ul><pre><code class="lang-bash">&lt;dependency&gt;    &lt;groupId&gt;org.jiaoper/groupId&gt;    &lt;artifactId&gt;utils-common&lt;/artifactId&gt;    &lt;version&gt;3.0-alpha-1&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;</code></pre><ul><li>test:测试阶段依赖</li></ul><pre><code class="lang-bash">&lt;dependency&gt;    &lt;groupId&gt;org.jiaoper/groupId&gt;    &lt;artifactId&gt;utils-common&lt;/artifactId&gt;    &lt;version&gt;3.0-alpha-1&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;</code></pre><ul><li>compile:编译、测试和运行阶段依赖(默认)</li></ul><pre><code class="lang-bash">&lt;dependency&gt;    &lt;groupId&gt;org.jiaoper/groupId&gt;    &lt;artifactId&gt;utils-common&lt;/artifactId&gt;    &lt;version&gt;3.0-alpha-1&lt;/version&gt;    &lt;scope&gt;complie&lt;/scope&gt;&lt;/dependency&gt;</code></pre><hr><h1 id="运维-linux"><a href="#运维-linux" class="headerlink" title="运维/linux"></a>运维/linux</h1><p><strong>Q：利用nginx共享文件夹</strong></p><p>nginx.conf添加如下配置</p><pre><code>server {    listen       8000;    server_name  localhost;    charset utf-8;    location / {    root /home;#共享根目录下的home文件夹    # 索引    autoindex on;    # 显示文件大小    autoindex_exact_size on;    # 显示文件时间    autoindex_localtime on;    #index  index.html index.htm;  }}</code></pre><p><strong>Q:更改ubuntu源为阿里云源</strong></p><pre><code class="lang-bash">sudo cp /etc/apt/sources.list /etc/apt/sources.list.baksudo vim /etc/apt/source.listdeb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-propertiesdeb http://archive.canonical.com/ubuntu xenial partnerdeb-src http://archive.canonical.com/ubuntu xenial partnerdeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverseapt-get update #ormv /etc/apt/sources.list /etc/apt/sources.list.bakecho &quot;deb http://mirrors.163.com/debian/ jessie main non-free contrib&quot; &gt;&gt; /etc/apt/sources.listecho &quot;deb http://mirrors.163.com/debian/ jessie-proposed-updates main non-free contrib&quot; &gt;&gt;/etc/apt/sources.listecho &quot;deb-src http://mirrors.163.com/debian/ jessie main non-free contrib&quot; &gt;&gt;/etc/apt/sources.listecho &quot;deb-src http://mirrors.163.com/debian/ jessie-proposed-updates main non-free contrib&quot; &gt;&gt;/etc/apt/sources.listapt-get update</code></pre><p><strong>Q:oracle导入dmp备份文件</strong></p><pre><code>[root@centos ～]# su - oracle[oracle@centos ～]# sqlplus 请输入用户名:  sys as sysdba输入口令:SQL&gt; CREATE USER 用户 IDENTIFIED BY 密码;User created.SQL&gt; GRANT CONNECT, RESOURCE, DBA TO 用户;Grant succeeded.SQL&gt; CONNECT 用户@orcl #新用户测试登陆</code></pre><p>复制*.dmp文件到linux并加权</p><pre><code>[root@centos ～]# chmod 777 *.dmp</code></pre><p>导入dmp数据库备份文件</p><pre><code>[root@centos ～] su - oracle[oracle@centos ～]imp 用户名/密码@orcl file=/home/*.dmp ignore=y full=y; Import terminated successfully with warnings.(成功)</code></pre><p><strong>Q：scp文件/目录上传/下载</strong></p><pre><code class="lang-java">#本地上传到远程#文件scp /root/test.json root@远程服务器ip:/usr/local/src#目录scp -r /home/testdir root@:远程服务器ip:/home/testdir#远程下载到本地#文件scp root@远程服务器ip:/usr/local/src/test.json /root/#目录scp -r root@:远程服务器ip:/home/testdir /home/</code></pre><p><strong>Q：Ubuntu增加swap交换空间</strong></p><pre><code class="lang-bash">$ free -m #查看分区大小$ dd if=/dev/zero of=/swapfile bs=1M count=3k #创建count*bs大小的swap文件$ mkswap /swapfile #创建swap空间$ swapon /swapfile #设置分区有效 ,swapoff 设置分区无效$ vim /etc/fstab #开启启动：添加/swapfile swap swap defaults 0 0</code></pre>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小贴士</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>卷积操作汇总</title>
    <link href="/2020/03/31/convolution/"/>
    <url>/2020/03/31/convolution/</url>
    
    <content type="html"><![CDATA[<p><strong>概念</strong><br>1.卷积核(Kernel)：滤波矩阵，普遍的卷积核大小为3×3、5×5;<br>2.步长(Stride)：卷积核遍历特征图时每步移动的像素个数;<br>3.填充(Padding)：对特征图边界外进行填充（一般填充为0）;<br>4.通道(Channel)：卷积层的通道数（层数）;<br><img src="/images/dp-net/convolution1.gif" srcset="/img/loading.gif" alt=""><br><img src="/images/dp-net/convolution2.jpg" srcset="/img/loading.gif" alt=""></p><h1 id="标准卷积"><a href="#标准卷积" class="headerlink" title="标准卷积"></a>标准卷积</h1><p><strong>单通道</strong><br><img src="/images/dp-net/convolution3.gif" srcset="/img/loading.gif" alt=""><br><strong>多通道</strong><br><img src="/images/dp-net/convolution4.gif" srcset="/img/loading.gif" alt=""><br><img src="/images/dp-net/convolution5.gif" srcset="/img/loading.gif" alt=""></p><h1 id="3维卷积"><a href="#3维卷积" class="headerlink" title="3维卷积"></a>3维卷积</h1><p><img src="/images/dp-net/convolution6.gif" srcset="/img/loading.gif" alt=""></p><h1 id="1x1卷积"><a href="#1x1卷积" class="headerlink" title="1x1卷积"></a>1x1卷积</h1><p><img src="/images/dp-net/convolution7.jpg" srcset="/img/loading.gif" alt=""></p><h1 id="反卷积（转置卷积）"><a href="#反卷积（转置卷积）" class="headerlink" title="反卷积（转置卷积）"></a>反卷积（转置卷积）</h1><p>将卷积核转换为稀疏矩阵后进行转置计算<br><br>如下图，在2x2的输入图像上应用步长为1、边界全0填充的3x3卷积核，进行转置卷积（反卷积）计算<br><br><img src="/images/dp-net/convolution8.gif" srcset="/img/loading.gif" alt=""></p><h1 id="空洞卷积（膨胀卷积）"><a href="#空洞卷积（膨胀卷积）" class="headerlink" title="空洞卷积（膨胀卷积）"></a>空洞卷积（膨胀卷积）</h1><p><img src="/images/dp-net/convolution9.gif" srcset="/img/loading.gif" alt=""></p><h1 id="可分离卷积（Separable-Convolutions）"><a href="#可分离卷积（Separable-Convolutions）" class="headerlink" title="可分离卷积（Separable Convolutions）"></a>可分离卷积（Separable Convolutions）</h1><p>将卷积核分解为两项独立的核分别进行操作<br><img src="/images/dp-net/convolution10.jpg" srcset="/img/loading.gif" alt=""><br><br>分解后的卷积计算过程如下图，先用3x1的卷积核作横向扫描计算，再用1x3的卷积核作纵向扫描计算<br><img src="/images/dp-net/convolution11.jpg" srcset="/img/loading.gif" alt=""><br></p><h1 id="深度可分离卷积（Depthwise-Separable-Convolutions）"><a href="#深度可分离卷积（Depthwise-Separable-Convolutions）" class="headerlink" title="深度可分离卷积（Depthwise Separable Convolutions）"></a>深度可分离卷积（Depthwise Separable Convolutions）</h1><p>3个卷积核分别对输入层的3个通道作卷积计算并堆叠在一起<br><br><img src="/images/dp-net/convolution12.jpg" srcset="/img/loading.gif" alt=""><br><br>再使用1x1的卷积（3个通道）进行计算，得到只有1个通道的结果<br><br><img src="/images/dp-net/convolution13.jpg" srcset="/img/loading.gif" alt=""><br><br>重复多次1x1的卷积操作（如下图为128次）<br><br><img src="/images/dp-net/convolution14.jpg" srcset="/img/loading.gif" alt=""><br><br><img src="/images/dp-net/convolution15.jpg" srcset="/img/loading.gif" alt=""><br></p><h1 id="分组卷积（Grouped-Convolution）"><a href="#分组卷积（Grouped-Convolution）" class="headerlink" title="分组卷积（Grouped Convolution）"></a>分组卷积（Grouped Convolution）</h1><p>在分组卷积中，卷积核被分成不同的组，每组负责对相应的输入层进行卷积计算，最后再进行合并<br><br><img src="/images/dp-net/convolution16.jpg" srcset="/img/loading.gif" alt=""><br></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>elasticsearch 教程</title>
    <link href="/2019/12/30/elasticsearch%20%E6%95%99%E7%A8%8B/"/>
    <url>/2019/12/30/elasticsearch%20%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="elasticsearch-教程"><a href="#elasticsearch-教程" class="headerlink" title="elasticsearch 教程"></a>elasticsearch 教程</h1><p><img src="/images/elasticsearch/1.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="安装、启动、测试"><a href="#安装、启动、测试" class="headerlink" title="安装、启动、测试"></a>安装、启动、测试</h2><p>elasticsearch下载地址:<a href="https://www.elastic.co/cn/downloads/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/elasticsearch</a></p><p>kibana下载地址:<a href="https://www.elastic.co/cn/downloads/kibana" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/kibana</a></p><p><strong>启动</strong></p><pre><code class="lang-bash">./elasticsearch-7.5.1/bin/elasticsearch #浏览器访问：localhost:9200</code></pre><pre><code class="lang-bash">{  &quot;name&quot; : &quot;jiaopandeMacBook-Pro.local&quot;,  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,  &quot;cluster_uuid&quot; : &quot;5vku_94_SjevMGVYIo3RYg&quot;,  &quot;version&quot; : {    &quot;number&quot; : &quot;7.5.1&quot;,    &quot;build_flavor&quot; : &quot;default&quot;,    &quot;build_type&quot; : &quot;tar&quot;,    &quot;build_hash&quot; : &quot;3ae9ac9a93c95bd0cdc054951cf95d88e1e18d96&quot;,    &quot;build_date&quot; : &quot;2019-12-16T22:57:37.835892Z&quot;,    &quot;build_snapshot&quot; : false,    &quot;lucene_version&quot; : &quot;8.3.0&quot;,    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;  },  &quot;tagline&quot; : &quot;You Know, for Search&quot;}</code></pre><p>配置kibana-7.5.1-darwin-x86_64/config/kibana.yml</p><pre><code class="lang-bash">server.host: &quot;localhost&quot;elasticsearch.hosts: [&quot;http://localhost:9200&quot;]</code></pre><pre><code class="lang-bash">./kibana-7.5.1-darwin-x86_64/bin/kibana #浏览器访问：localhost:5601</code></pre><p><img src="/images/elasticsearch/2.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>测试</strong><br>kibana Dev Tools</p><p><img src="/images/elasticsearch/3.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><p><strong>创建索引</strong></p><pre><code class="lang-bash">PUT http://127.0.0.1:9200/test_index</code></pre><p><strong>删除索引</strong></p><pre><code class="lang-bash">DELETE http://127.0.0.1:9200/test_index</code></pre><p><strong>索引别名</strong></p><pre><code class="lang-bash">POST _aliases{    &quot;actions&quot;: [        { &quot;add&quot; : { &quot;index&quot; : &quot;test_index&quot;, &quot;alias&quot; : &quot;test&quot; } }    ]}</code></pre><p><strong>索引迁移</strong></p><pre><code class="lang-bash">POST _reindex{    &quot;source&quot;: {        &quot;index&quot;: &quot;test_index&quot;    },    &quot;dest&quot;: {        &quot;index&quot;: &quot;test_index_v2&quot;    }}POST _aliases{    &quot;actions&quot;: [        { &quot;remove&quot; : { &quot;index&quot; : &quot;test_index&quot;, &quot;alias&quot; : &quot;test&quot; } },        { &quot;add&quot; : { &quot;index&quot; : &quot;test_index_v2&quot;, &quot;alias&quot; : &quot;test_v2&quot; } }    ]}</code></pre><p><strong>索引mapping设置</strong></p><pre><code class="lang-bash">PUT /dyw_index_v2{  &quot;settings&quot;: {    &quot;analysis&quot;: {      &quot;analyzer&quot;: {        &quot;default&quot;: {          &quot;type&quot;: &quot;ik_max_word&quot;        }      }    }  },  &quot;mappings&quot;: {    &quot;properties&quot;: {      &quot;type&quot;:{        &quot;type&quot;: &quot;keyword&quot;      },      &quot;tags&quot;:{        &quot;type&quot;: &quot;text&quot;       },      &quot;content&quot;:{        &quot;type&quot;: &quot;text&quot;,        &quot;boost&quot;: 2      },      &quot;suggest&quot; : {        &quot;type&quot; : &quot;completion&quot;,        &quot;analyzer&quot;: &quot;ik_max_word&quot;      },      &quot;update_time&quot;:{            &quot;type&quot;: &quot;date&quot;,            &quot;format&quot;: [&quot;yyyy-MM-dd HH:mm:ss&quot;]      },      &quot;location&quot;:{            &quot;type&quot;: &quot;geo_point&quot;      },      &quot;join&quot;:{        &quot;type&quot;: &quot;object&quot;,        &quot;properties&quot;: {          &quot;id&quot;:{            &quot;type&quot;:&quot;keyword&quot;          },          &quot;content&quot;:{            &quot;type&quot;:&quot;text&quot;          }        }      },      &quot;extra&quot;:{        &quot;type&quot;: &quot;object&quot;,        &quot;properties&quot;: {          &quot;scene&quot;:{            &quot;type&quot;: &quot;nested&quot;,            &quot;properties&quot;: {                &quot;id&quot;:{                  &quot;type&quot;: &quot;keyword&quot;                },                &quot;position&quot;:{                  &quot;type&quot;: &quot;integer&quot;                }             }          }        }      }    }  }}</code></pre><h2 id="document"><a href="#document" class="headerlink" title="document"></a>document</h2><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html</a></p><h2 id="安装中文分词"><a href="#安装中文分词" class="headerlink" title="安装中文分词"></a>安装中文分词</h2><pre><code class="lang-bash">./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.5.1/elasticsearch-analysis-ik-7.5.1.zip</code></pre><h2 id="Java-API"><a href="#Java-API" class="headerlink" title="Java API"></a>Java API</h2><p><strong>pom依赖</strong></p><pre><code class="lang-xml">&lt;dependency&gt;    &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;    &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;    &lt;version&gt;7.5.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;    &lt;artifactId&gt;elasticsearch-rest-client&lt;/artifactId&gt;    &lt;version&gt;7.5.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt;    &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt;    &lt;version&gt;7.5.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><strong>客户端</strong></p><pre><code class="lang-java">/** * @author 作者 jiaopan: * @version 创建时间：Feb 10, 2020 11:09:05 AM * 类说明 */public class ESClient {    private volatile static RestHighLevelClient client;    public static RestHighLevelClient instance(EsConfigValue config) {          if (client == null) {              synchronized (RestHighLevelClient.class) {                  if (client == null) {                      final CredentialsProvider credentialsProvider = new BasicCredentialsProvider();                    credentialsProvider.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(config.getUsername(),config.getPassword()));                    client = new RestHighLevelClient(RestClient.builder(new HttpHost(config.getIp(),config.getPort(), &quot;http&quot;))                             .setHttpClientConfigCallback(new RestClientBuilder.HttpClientConfigCallback() {                                    @Override                                    public HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpClientBuilder) {                                        httpClientBuilder.disableAuthCaching();                                        return httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider);                                    }                    }));                }              }          }          return client;      }          /*    public static RestHighLevelClient instance(EsConfigValue config) {          if (client == null) {              synchronized (RestHighLevelClient.class) {                  if (client == null) {                      client = new RestHighLevelClient(RestClient.builder(new HttpHost(config.getIp(),config.getPort(), &quot;http&quot;)));                }              }          }          return client;      }     */}</code></pre><p><strong> base apis</strong></p><pre><code class="lang-java">public Boolean isExist(String index, String id,String routing) {    RestHighLevelClient client = ESClient.instance(esConfig);    GetRequest request = new GetRequest(index).id(id);    request.fetchSourceContext(new FetchSourceContext(false));    request.storedFields(&quot;_none_&quot;);    request.routing(routing);    try {        return client.exists(request, RequestOptions.DEFAULT);    } catch (IOException e) {        return false;    }}public Map&lt;String, Object&gt; get(String index, String id,String routing) throws IOException {    RestHighLevelClient client = ESClient.instance(esConfig);    GetRequest request = new GetRequest(esConfig.getIndex(), id);    request.routing(routing);    GetResponse getResponse = client.get(request, RequestOptions.DEFAULT);    Map&lt;String, Object&gt; doc = new HashMap&lt;String, Object&gt;();    if(getResponse.isExists()) {        doc = getResponse.getSourceAsMap();        doc.put(&quot;id&quot;,getResponse.getId());    }    return doc;}public SearchResponse getByIds(List&lt;String&gt; ids) throws IOException {    RestHighLevelClient client = ESClient.instance(esConfig);    SearchRequest searchRequest = new SearchRequest(esConfig.getIndex());     SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();     BoolQueryBuilder booleanQueryBuilder = QueryBuilders.boolQuery();    IdsQueryBuilder idsQueryBuilder = QueryBuilders.idsQuery();    idsQueryBuilder.ids().addAll(ids);    booleanQueryBuilder.must(idsQueryBuilder);    /*构建查询*/    searchSourceBuilder.from(0);    searchSourceBuilder.size(ids.size());    searchSourceBuilder.query(booleanQueryBuilder);     searchRequest.source(searchSourceBuilder);    SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);    return searchResponse;}public void createOrUpdate(String index, String id,String routing,JSONObject item,Boolean bulk) throws IOException {    RestHighLevelClient client = ESClient.instance(esConfig);    GetRequest request = new GetRequest(esConfig.getIndex(), id);    request.routing(routing);    JSONObject doc = new JSONObject();    GetResponse getResponse = client.get(request, RequestOptions.DEFAULT);    if(getResponse.isExists()) {        Map&lt;String, Object&gt; source = getResponse.getSourceAsMap();        JSONObject content = JSONObject.parseObject(source.get(&quot;content&quot;).toString());        item.keySet().forEach(key-&gt;{            content.put(key,item.get(key));        });        doc = this.createDocSource(content,routing,true);    }    else        doc = this.createDocSource(item,routing,false);    if(bulk)        this.bulkUpdate(index, id, doc, true, routing);    else        this.update(index, id, doc, true,routing);}public void delete(String index, String id,String routing) {    RestHighLevelClient client = ESClient.instance(esConfig);    DeleteRequest request = new DeleteRequest(index, id);    request.routing(routing);    client.deleteAsync(request, RequestOptions.DEFAULT, new ActionListener&lt;DeleteResponse&gt;() {        @Override        public void onResponse(DeleteResponse response) {            if (response.getResult() == DocWriteResponse.Result.DELETED) {                logger.info(&quot;delete&gt;&gt;&gt;&quot;+&quot;{\&quot;id\&quot;:\&quot;&quot;+id+&quot;\&quot;,\&quot;type\&quot;:\&quot;&quot;+routing+&quot;\&quot;}&quot;);            }        }        @Override        public void onFailure(Exception e) {            logger.info(&quot;delete fail&gt;&gt;&gt;&quot;+&quot;{\&quot;id\&quot;:\&quot;&quot;+id+&quot;\&quot;,\&quot;type\&quot;:\&quot;&quot;+routing+&quot;\&quot;}&quot;);        }    });}public void update(String index, String id, JSONObject item,Boolean upsert,String routing) {    if(item == null) {        return;    }    RestHighLevelClient client = ESClient.instance(esConfig);    UpdateRequest request = new UpdateRequest(index,id).doc(item);     request.docAsUpsert(upsert);    request.retryOnConflict(3);    request.routing(routing);    client.updateAsync(request, RequestOptions.DEFAULT, new ActionListener&lt;UpdateResponse&gt;() {        @Override        public void onResponse(UpdateResponse response) {            if (response.getResult() == DocWriteResponse.Result.CREATED) {                logger.info(&quot;created&gt;&gt;&gt;&quot;+&quot;{\&quot;id\&quot;:\&quot;&quot;+id+&quot;\&quot;,\&quot;type\&quot;:\&quot;&quot;+routing+&quot;\&quot;}&quot;);            }            else if (response.getResult() == DocWriteResponse.Result.UPDATED) {                logger.info(&quot;updated&gt;&gt;&gt;&quot;+&quot;{\&quot;id\&quot;:\&quot;&quot;+id+&quot;\&quot;,\&quot;type\&quot;:\&quot;&quot;+routing+&quot;\&quot;}&quot;);            }        }        @Override        public void onFailure(Exception e) {            logger.warn(&quot;not_store_record(&quot;+e.getMessage()+&quot;)&gt;&gt;&gt;&quot;+item.toJSONString());        }    });}public void bulkUpdate(String index, String id, JSONObject item,Boolean upsert,String routing) {    if(item == null) {        return;    }    UpdateRequest request = new UpdateRequest(index,id).doc(item);     request.docAsUpsert(upsert);    request.retryOnConflict(3);    request.routing(routing);    queue.offer(request);}public void bulk(ConcurrentLinkedQueue&lt;UpdateRequest&gt; queue, RestHighLevelClient client) {    BulkRequest bulk = new BulkRequest();    for (int i = 0; i &lt; esConfig.getBulk(); i++) {        if(queue.isEmpty()) break;        bulk.add(queue.poll());    }    if(bulk.numberOfActions() == 0) return;    logger.info(DateUtils.getNowDate()+&quot;:starting handle doc queue,actions:&quot;+bulk.numberOfActions());    client.bulkAsync(bulk, RequestOptions.DEFAULT, new ActionListener&lt;BulkResponse&gt;() {        @Override        public void onResponse(BulkResponse response) {            if(response.hasFailures())                logger.info(response.buildFailureMessage());        }        @Override        public void onFailure(Exception e) {            logger.warn(&quot;bulk handle docs error:&quot;+e.getMessage());        }    });}</code></pre><p><strong>Common apis</strong></p><pre><code class="lang-java">public void locationSearch(SearchSourceBuilder searchSourceBuilder, BoolQueryBuilder booleanQueryBuilder,        String location,String lockey,Double distance,Boolean sort) throws FontFormatException {    String[] latlon = location.split(&quot;,&quot;);    if(latlon.length != 2) {        throw new NumberFormatException(&quot;经纬度参数不正确.location参数以英文逗号(,)连接的字符串.正确示例:“纬度(latitude),经度(longitude)\&quot;&quot;);    }    Double lat = Double.parseDouble(latlon[0]);    Double lon = Double.parseDouble(latlon[1]);    GeoDistanceQueryBuilder geoQueryBuilder = QueryBuilders.geoDistanceQuery(lockey).point(lat, lon)                                   .distance(distance == null?esConfig.getDistance():distance, DistanceUnit.KILOMETERS)                                   .geoDistance(GeoDistance.PLANE);    if(sort) {        GeoDistanceSortBuilder distanceSortBuilder = SortBuilders.geoDistanceSort(lockey,lat,lon);        distanceSortBuilder.order(SortOrder.ASC);        distanceSortBuilder.point(lat, lon);        searchSourceBuilder.sort(distanceSortBuilder);    }    booleanQueryBuilder.must(geoQueryBuilder);}public void fullTextSearch(BoolQueryBuilder booleanQueryBuilder, String keyword,List&lt;String&gt; fields,Boolean must) {    DisMaxQueryBuilder disMaxQueryBuilder = QueryBuilders.disMaxQuery();    fields.forEach(item-&gt;{        disMaxQueryBuilder.add(QueryBuilders.matchQuery(item,keyword));    });    if(must) booleanQueryBuilder.must(disMaxQueryBuilder);    else booleanQueryBuilder.should(disMaxQueryBuilder);}public void phraseTextSearch(BoolQueryBuilder booleanQueryBuilder, String keyword,List&lt;String&gt; fields,Boolean must) {    DisMaxQueryBuilder disMaxQueryBuilder = QueryBuilders.disMaxQuery();    List&lt;String&gt; words = Arrays.asList(keyword.split(&quot; &quot;));    fields.forEach(item-&gt;{        words.forEach(word-&gt;{            disMaxQueryBuilder.add(QueryBuilders.matchPhraseQuery(item,word));        });    });    if(must) booleanQueryBuilder.must(disMaxQueryBuilder);    else booleanQueryBuilder.should(disMaxQueryBuilder);}public void textSearch(BoolQueryBuilder booleanQueryBuilder, String keyword, List&lt;String&gt; fields, Boolean phrase,Boolean must) {    if(phrase) phraseTextSearch(booleanQueryBuilder, keyword, fields,must);    else fullTextSearch(booleanQueryBuilder, keyword, fields,must);}public void typeSearch(BoolQueryBuilder booleanQueryBuilder,String key,List&lt;String&gt; typeArray, List&lt;String&gt; mustNot) {    DisMaxQueryBuilder disMaxQueryBuilder = QueryBuilders.disMaxQuery();    for (int i = 0; i &lt; typeArray.size(); i++) {        disMaxQueryBuilder.add(QueryBuilders.termQuery(key,typeArray.get(i)));    }    booleanQueryBuilder.must(disMaxQueryBuilder);    List&lt;QueryBuilder&gt; mustNotQuerys = new ArrayList&lt;QueryBuilder&gt;();    for (int i = 0; i &lt; mustNot.size(); i++) {        QueryBuilder query = QueryBuilders.termQuery(key,mustNot.get(i));        mustNotQuerys.add(query);    }    booleanQueryBuilder.mustNot().addAll(mustNotQuerys);}public void typeSearch(BoolQueryBuilder booleanQueryBuilder,String key, List&lt;String&gt; typeArray) {    DisMaxQueryBuilder disMaxQueryBuilder = QueryBuilders.disMaxQuery();    for (int i = 0; i &lt; typeArray.size(); i++) {        disMaxQueryBuilder.add(QueryBuilders.termQuery(key,typeArray.get(i)));    }    booleanQueryBuilder.must(disMaxQueryBuilder);}public void createQuery(SearchRequest searchRequest, SearchSourceBuilder searchSourceBuilder,Integer from, Integer size, QueryBuilder queryBuilder) {    searchSourceBuilder.from(from == null?esConfig.getFrom():from);    searchSourceBuilder.size(size == null?esConfig.getSize():size);    searchSourceBuilder.query(queryBuilder);     searchRequest.source(searchSourceBuilder);}public void createQuery(SearchRequest searchRequest, SearchSourceBuilder searchSourceBuilder,Integer from, Integer size, QueryBuilder queryBuilder, QueryBuilder postFilter) {    searchSourceBuilder.from(from == null?esConfig.getFrom():from);    searchSourceBuilder.size(size == null?esConfig.getSize():size);    searchSourceBuilder.query(queryBuilder);     searchSourceBuilder.postFilter(postFilter);    searchRequest.source(searchSourceBuilder);}public void sort(SearchSourceBuilder searchSourceBuilder, int sortField) {    String field = dict.getSortField().get(sortField);    String order = dict.getSortType().get(field);    searchSourceBuilder.sort(new FieldSortBuilder(field).order(SortOrder.fromString(order)));}public void searchMustNot(BoolQueryBuilder booleanQueryBuilder,String field,String values) {    List&lt;String&gt; mustNot = Arrays.asList(values.split(&quot;,&quot;));    mustNot.forEach(item-&gt;{booleanQueryBuilder.mustNot(QueryBuilders.termQuery(field,item));    });}</code></pre><p><strong>search</strong></p><pre><code class="lang-java">public List&lt;Map&lt;String, Object&gt;&gt; search(String keyword,String scopes, Integer from, Integer size,String location, Double distance,Boolean matchPhrase,Boolean scoreSort) throws IOException, FontFormatException {    RestHighLevelClient client = ESClient.instance(esConfig);    SearchRequest searchRequest = new SearchRequest(esConfig.getIndex());     SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();     BoolQueryBuilder booleanQueryBuilder = QueryBuilders.boolQuery();    /*type检索*/    if(!StringUtils.equals(scopes,&quot;all&quot;)) {        List&lt;String&gt; scopeArray = new ArrayList&lt;String&gt;();         scopeArray = Arrays.asList(scopes.split(&quot;,&quot;));         engineBaseMethod.typeSearch(booleanQueryBuilder,&quot;type&quot;,scopeArray);    }    String notTypes = StringUtils.join(dict.getMustNot(), &quot;,&quot;);    engineBaseMethod.searchMustNot(booleanQueryBuilder, &quot;type&quot;,notTypes);    booleanQueryBuilder.must(QueryBuilders.termQuery(&quot;extra.up&quot;,&quot;1&quot;));    /*多字段检索*/    if(StringUtils.isNotBlank(keyword)) {        //List&lt;String&gt; fieldList = Arrays.asList(&quot;title,cn_name,suggest&quot;.split(&quot;,&quot;));         List&lt;String&gt; fieldList = dict.getSearchMatch();        engineBaseMethod.textSearch(booleanQueryBuilder, keyword, fieldList, matchPhrase,true);    }    /*排序*/    engineBaseMethod.sort(searchSourceBuilder,0);    engineBaseMethod.sort(searchSourceBuilder,1);    /*地理位置范围内搜索并就近排序*/    if(StringUtils.isNotBlank(location)) {        engineBaseMethod.locationSearch(searchSourceBuilder, booleanQueryBuilder, location,&quot;location&quot;,distance,true);    }    int index = 2 + (int)(Math.random() * ((3 - 2) + 1));    if(scoreSort) searchSourceBuilder.sort(new ScoreSortBuilder().order(SortOrder.DESC));    else engineBaseMethod.sort(searchSourceBuilder,index);    /*构建查询*/    engineBaseMethod.createQuery(searchRequest, searchSourceBuilder, from, size, booleanQueryBuilder);    SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);    /*解析结果并返回*/    List&lt;Map&lt;String, Object&gt;&gt; result = new ArrayList&lt;Map&lt;String,Object&gt;&gt;();    engineBaseMethod.searchResultAnalyse(result, searchResponse);    return result;}public List&lt;String&gt; searchTips(String keyword, String type) throws IOException, FontFormatException {    RestHighLevelClient client = ESClient.instance(esConfig);    //前缀搜索建议    SearchRequest searchRequest = new SearchRequest(esConfig.getIndex());     SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();     CompletionSuggestionBuilder suggestionBuilder = new CompletionSuggestionBuilder(&quot;suggest&quot;);    suggestionBuilder.prefix(keyword);    suggestionBuilder.size(esConfig.getSize());    suggestionBuilder.skipDuplicates(true);    SuggestBuilder suggestBuilder = new SuggestBuilder();    suggestBuilder.addSuggestion(&quot;search_tips&quot;, suggestionBuilder);    searchSourceBuilder.suggest(suggestBuilder);    searchRequest.source(searchSourceBuilder);    SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);    //匹配搜索建议    SearchSourceBuilder querySourceBuilder = new SearchSourceBuilder();     SearchRequest queryRequest = new SearchRequest(esConfig.getIndex());     BoolQueryBuilder booleanQueryBuilder = QueryBuilders.boolQuery();    if(StringUtils.isNotBlank(keyword)) booleanQueryBuilder.should(QueryBuilders.matchQuery(&quot;title&quot;,keyword));    String notTypes = StringUtils.join(dict.getMustNot(), &quot;,&quot;);    engineBaseMethod.searchMustNot(booleanQueryBuilder, &quot;type&quot;,notTypes);    querySourceBuilder.query(booleanQueryBuilder);    queryRequest.source(querySourceBuilder);    SearchResponse queryResponse = client.search(queryRequest, RequestOptions.DEFAULT);    /*解析结果并返回*/    List&lt;String&gt; result = new ArrayList&lt;String&gt;();    Suggest suggest = searchResponse.getSuggest();    CompletionSuggestion completionSuggestion = suggest.getSuggestion(&quot;search_tips&quot;);    for(CompletionSuggestion.Entry entry : completionSuggestion.getEntries()) {         for (CompletionSuggestion.Entry.Option option : entry) {             String optionType = option.getHit().getSourceAsMap().get(&quot;type&quot;).toString();            if(StringUtils.equals(type, &quot;all&quot;) || StringUtils.equals(type,optionType)) result.add(option.getText().string());        }    }    for(SearchHit hit:queryResponse.getHits()) {        String text = (String) hit.getSourceAsMap().get(&quot;title&quot;);        if(!result.contains(text)) result.add(text);    }    return result;}</code></pre><h2 id="集群安装"><a href="#集群安装" class="headerlink" title="集群安装"></a>集群安装</h2><p><strong>master 配置</strong></p><pre><code class="lang-bash"># ---------------------------------- Cluster -----------------------------------cluster.name: es-cluster# ------------------------------------ Node ------------------------------------node.name: node1-recnode.master: truenode.data: false # ----------------------------------- Paths ------------------------------------path.data: /data/es/datapath.logs: /data/es/logs# ----------------------------------- Memory -----------------------------------bootstrap.memory_lock: false# ---------------------------------- Network -----------------------------------network.host: 0.0.0.0network.publish_host: 10.2.64.110http.port: 9200# --------------------------------- Discovery ----------------------------------discovery.seed_hosts: [&quot;10.2.64.110&quot;, &quot;10.2.64.111&quot;, &quot;10.2.64.112&quot;]cluster.initial_master_nodes: [&quot;10.2.64.110&quot;]discovery.zen.fd.ping_timeout: 1mdiscovery.zen.fd.ping_retries: 5http.cors.allow-origin: &quot;*&quot; http.cors.enabled: truebootstrap.system_call_filter: falsexpack.license.self_generated.type: basic</code></pre><p><strong>node 配置</strong></p><pre><code class="lang-bash">cluster.name: es-cluster# ------------------------------------ Node ------------------------------------node.name: node2-recnode.master: falsenode.data: true # ----------------------------------- Paths ------------------------------------path.data: /data/es/datapath.logs: /data/es/logs# ----------------------------------- Memory -----------------------------------bootstrap.memory_lock: false# ---------------------------------- Network -----------------------------------network.host: 0.0.0.0network.publish_host: 10.2.64.111http.port: 9200# --------------------------------- Discovery ----------------------------------discovery.seed_hosts: [&quot;10.2.64.110&quot;, &quot;10.2.64.111&quot;, &quot;10.2.64.112&quot;]cluster.initial_master_nodes: [&quot;10.2.64.110&quot;]discovery.zen.fd.ping_timeout: 1mdiscovery.zen.fd.ping_retries: 5http.cors.allow-origin: &quot;*&quot; http.cors.enabled: truebootstrap.system_call_filter: false#xpack.license.self_generated.type: basic</code></pre><p><strong>master kibana 配置</strong></p><pre><code class="lang-bash">server.port: 5601server.host: &quot;0.0.0.0&quot;server.name: &quot;node1-rec&quot;elasticsearch.hosts: [&quot;http://10.2.64.110:9200&quot;,&quot;http://10.2.64.111:9200&quot;,&quot;http://10.2.64.112:9200&quot;]</code></pre><p><strong>Kibana查看集群状态</strong></p><pre><code>GET _cluster/health?pretty{  &quot;cluster_name&quot; : &quot;es-cluster&quot;,  &quot;status&quot; : &quot;green&quot;,  &quot;timed_out&quot; : false,  &quot;number_of_nodes&quot; : 3,  &quot;number_of_data_nodes&quot; : 2,  &quot;active_primary_shards&quot; : 7,  &quot;active_shards&quot; : 14,  &quot;relocating_shards&quot; : 0,  &quot;initializing_shards&quot; : 0,  &quot;unassigned_shards&quot; : 0,  &quot;delayed_unassigned_shards&quot; : 0,  &quot;number_of_pending_tasks&quot; : 0,  &quot;number_of_in_flight_fetch&quot; : 0,  &quot;task_max_waiting_in_queue_millis&quot; : 0,  &quot;active_shards_percent_as_number&quot; : 100.0}</code></pre>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>android使用opencv native方式环境搭建</title>
    <link href="/2019/11/01/android%E4%BD%BF%E7%94%A8opencv%20native%E6%96%B9%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2019/11/01/android%E4%BD%BF%E7%94%A8opencv%20native%E6%96%B9%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>1.opencv下载：<a href="https://opencv.org/releases/" target="_blank" rel="noopener">https://opencv.org/releases/</a> 解压后为OpenCV-android-sdk</p><p><img src="/images/opencv3/41.png" srcset="/img/loading.gif" alt=""></p><p>2.创建初始Android项目</p><p><img src="/images/opencv3/42.png" srcset="/img/loading.gif" alt=""></p><p>3.在app/src/main目录下新建jniLibs目录，在app/src/main/cpp目录下新建include目录和src目录</p><p>将OpenCV-android-sdk/sdk/native/libs下所有目录复制到jniLibs目录中</p><p>将OpenCV-android-sdk/sdk/native/jni/include下的所有目录复制到app/src/main/cpp/include目录中</p><p>移动app/src/main/cpp/CMakeLists.txt至app目录下 </p><p>移动app/src/main/cpp/native-lib.cpp至app/src/main/cpp/src/native-lib.cpp</p><p><img src="/images/opencv3/43.png" srcset="/img/loading.gif" alt=""></p><p>4.配置文件修改</p><p><strong>CMakeLists.txt</strong></p><pre><code># For more information about using CMake with Android Studio, read the# documentation: https://d.android.com/studio/projects/add-native-code.html# Sets the minimum version of CMake required to build the native library.cmake_minimum_required(VERSION 3.4.1)include_directories(${CMAKE_SOURCE_DIR}/src/main/cpp/include)#opencv 4.0.1add_library(libopencv_java4 SHARED IMPORTED)set_target_properties(libopencv_java4 PROPERTIES IMPORTED_LOCATION        ${CMAKE_SOURCE_DIR}/src/main/jniLibs/${ANDROID_ABI}/libopencv_java4.so)#localadd_library(native-lib SHARED src/main/cpp/src/native-lib.cpp)find_library(log-lib log )target_link_libraries(native-lib libopencv_java4 ${log-lib} )</code></pre><p><strong>app/build.gradle</strong></p><pre><code class="lang-bash">apply plugin: &#39;com.android.application&#39;android {    compileSdkVersion 29    buildToolsVersion &quot;29.0.2&quot;    defaultConfig {        applicationId &quot;com.wisesoft.wiseface&quot;        minSdkVersion 21        targetSdkVersion 29        versionCode 1        versionName &quot;1.0&quot;        testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot;        externalNativeBuild {            cmake {                cppFlags &quot;-std=c++11 -frtti -fexceptions&quot;                abiFilters &#39;armeabi-v7a&#39;                arguments &quot;-DANDROID_STL=c++_shared&quot;            }        }        ndk{            abiFilters &#39;armeabi-v7a&#39;        }    }    sourceSets{        main{            jniLibs.srcDirs = [&#39;src/main/jniLibs&#39;]            jni.srcDirs = []        }    }    buildTypes {        release {            minifyEnabled false            proguardFiles getDefaultProguardFile(&#39;proguard-android-optimize.txt&#39;), &#39;proguard-rules.pro&#39;            ndk{                abiFilters &#39;armeabi-v7a&#39;            }        }    }    externalNativeBuild {        cmake {            path &quot;CMakeLists.txt&quot;        }    }}dependencies {    implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])    implementation &#39;androidx.appcompat:appcompat:1.1.0&#39;    implementation &#39;androidx.constraintlayout:constraintlayout:1.1.3&#39;    testImplementation &#39;junit:junit:4.12&#39;    androidTestImplementation &#39;androidx.test:runner:1.2.0&#39;    androidTestImplementation &#39;androidx.test.espresso:espresso-core:3.2.0&#39;}</code></pre><p>5.刷新配置点击Sync Now并refresh c++</p><p><img src="/images/opencv3/44.png" srcset="/img/loading.gif" alt=""></p><p>6.使用原生opencv c++ 代码进行开发</p><pre><code class="lang-c++">#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;opencv2/opencv.hpp&gt;extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_wisesoft_wiseface_MainActivity_stringFromJNI(        JNIEnv* env,        jobject /* this */) {    std::string hello = &quot;Hello from C++&quot;;    cv::Mat mat;    return env-&gt;NewStringUTF(hello.c_str());}</code></pre>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>opencv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习模型转换</title>
    <link href="/2019/10/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>/2019/10/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="mxnet模型转tensorflow模型"><a href="#mxnet模型转tensorflow模型" class="headerlink" title="mxnet模型转tensorflow模型"></a>mxnet模型转tensorflow模型</h3><p>requirements：pip install mxnet tensorflow</p><h5 id="1-安装mmdnn"><a href="#1-安装mmdnn" class="headerlink" title="1.安装mmdnn"></a>1.安装mmdnn</h5><p>pip install -U git+<a href="https://github.com/Microsoft/MMdnn.git@master" target="_blank" rel="noopener">https://github.com/Microsoft/MMdnn.git@master</a></p><h5 id="2-模型下载"><a href="#2-模型下载" class="headerlink" title="2.模型下载"></a>2.模型下载</h5><p><a href="https://pan.baidu.com/s/1If28BkHde4fiuweJrbicVA" target="_blank" rel="noopener">https://pan.baidu.com/s/1If28BkHde4fiuweJrbicVA</a></p><h5 id="3-mxnet模型转IR"><a href="#3-mxnet模型转IR" class="headerlink" title="3.mxnet模型转IR"></a>3.mxnet模型转IR</h5><pre><code class="lang-bash">python -m mmdnn.conversion._script.convertToIR -f mxnet -n model-symbol.json -w model-0000.params -d tf_model --inputShape 3,112,112 #info:IR network structure is saved as [tf_model.json].#可视化文件IR network structure is saved as [tf_model.pb].#网络结构IR weights are saved as [tf_model.npy].#权重参数</code></pre><p>若报错：AttributeError: ‘NoneType’ object has no attribute ‘asnumpy’ line 410</p><p>解决：找到python3.6/site-packages/mmdnn/conversion/mxnet/mxnet_parser.py 410 行 修改如下：</p><pre><code>weight = self.weight_data.get(&quot;fc1_weight&quot;).asnumpy().transpose((1, 0))</code></pre><p>参考：<a href="https://github.com/microsoft/MMdnn/issues/231" target="_blank" rel="noopener">https://github.com/microsoft/MMdnn/issues/231</a></p><h5 id="4-生成tf-model-py-用于还原神经网络结构"><a href="#4-生成tf-model-py-用于还原神经网络结构" class="headerlink" title="4.生成tf_model.py 用于还原神经网络结构"></a>4.生成tf_model.py 用于还原神经网络结构</h5><p>调用tf_model.py中的KitModel函数加载npy权重参数可重新生成原网络框架</p><pre><code class="lang-bash">python -m mmdnn.conversion._script.IRToCode -f tensorflow --IRModelPath tf_model.pb --IRWeightPath tf_model.npy --dstModelPath tf_model.py#info:Parse file [tf_model.pb] with binary format successfully.Target network code snippet is saved as [tf_model.py].</code></pre><h5 id="5-验证模型输出结果是否一致"><a href="#5-验证模型输出结果是否一致" class="headerlink" title="5.验证模型输出结果是否一致"></a>5.验证模型输出结果是否一致</h5><p>5.1 test_mxnet.py</p><pre><code class="lang-python">import mxnet as mxfrom tensorflow.contrib.keras.api.keras.preprocessing import imageimport numpy as npfrom collections import namedtupleBatch = namedtuple(&#39;Batch&#39;, [&#39;data&#39;])ctx = mx.cpu(0)#加载模型sym, arg_params, aux_params = mx.model.load_checkpoint(&#39;mobile/model&#39;, 0) #mobile文件夹下为 model-symbol.json -w model-0000.paramsmod = mx.mod.Module(symbol = sym, context= ctx, label_names= None)mod.bind(for_training=False, data_shapes=[(&#39;data&#39;, (1, 3, 112, 112))], label_shapes= mod._label_shapes)mod.set_params(arg_params, aux_params, allow_missing= True)path = &#39;face.jpeg&#39;img = image.load_img(path, target_size = (112, 112))img = image.img_to_array(img)img = img[..., ::-1]img = np.expand_dims(img, 0).transpose((0,3,1,2))mod.forward(Batch([mx.nd.array(img)]))prob = mod.get_outputs()[0].asnumpy()prob = np.squeeze(prob)print(prob)</code></pre><p><strong><em>执行命令</em></strong></p><pre><code class="lang-python">python test_mxnet.py #info:[17:39:57] src/nnvm/legacy_json_util.cc:209: Loading symbol saved by previous version v1.0.0. Attempting to upgrade...[17:39:57] src/nnvm/legacy_json_util.cc:217: Symbol successfully upgraded![ 0.344491    0.10190611 -0.24501216  0.6819046   0.88096315  0.347766 -0.94702303 -0.67586213 -0.43900824  0.81431276 -0.4899036  -0.43025514 -0.50644076 -0.27366892  0.63601595 -0.5352368   0.13765731  0.40842316  0.76525426 -0.8959755   0.42129532 -0.38290668  0.02023177 -0.14840017  0.9108279  -0.27738237 -0.6017331  -0.214954    0.37644073  0.48894417 -0.8824417   0.31846505  0.19936565  0.27296835  1.5621403   0.4327985 -0.6486908  -0.23494942 -0.8708738  -0.77051663  0.09255238 -1.1803752 -0.17184262  0.2543226  -0.19088541 -0.26873437  0.9160875  -0.18985008 -0.4793183  -0.32987356 -1.3085973   1.2959319  -0.00581244  0.12396478  1.2034996   0.0991946  -1.9225345   0.92873436 -0.285992    0.11249313 -1.4562801   1.8767762  -1.2222489  -0.03905598  0.5152731   0.04876914  0.04671988 -0.32384786 -0.88341314  0.58193505 -0.7378911  -0.3082042  0.22141728  0.7255646   0.24394599  0.6563271  -0.46760473 -0.38698462 -0.11467619 -0.9940818  -1.1298056   1.015201    0.03592067  0.6738027 -0.5814839   0.1565634  -0.06737513 -1.040216   -0.9286871  -0.11091176 -0.66596293  0.03736701 -0.35337982 -0.4175317  -0.47258058 -0.62383175 -0.86612004 -0.5230916  -1.7838901   0.08661752 -0.02590845  0.23406455  0.77719927  1.4410776   0.41925532  0.4560187  -0.02141571  0.7005563 -0.58727044 -0.39757103  1.2808248  -1.1874324  -0.27268586 -0.82443166  0.39704558 -1.2778002  -0.52762616 -0.26455742  1.2137026   0.04997367  0.05591454  1.0264031   1.5093948  -0.5634581  -1.1715719  -0.646347  0.6021179   0.6725963 ]</code></pre><p>5.1 test_tensorflow.py</p><pre><code class="lang-python">from __future__ import absolute_importimport argparseimport numpy as npfrom six import text_type as _text_typefrom tensorflow.contrib.keras.api.keras.preprocessing import imageimport tensorflow as tfparser = argparse.ArgumentParser()parser.add_argument(&#39;-n&#39;, type=_text_type, default=&#39;kitModel&#39;,                    help=&#39;Network structure file name.&#39;)parser.add_argument(&#39;-w&#39;, type=_text_type, required=True,                    help=&#39;Network weights file name&#39;)parser.add_argument(&#39;--image&#39;, &#39;-i&#39;,                    type=_text_type, help=&#39;Test image path.&#39;,                    default=&quot;face.jpeg&quot;)args = parser.parse_args()if args.n.endswith(&#39;.py&#39;):    args.n = args.n[:-3]model_converted = __import__(args.n).KitModel(args.w)input_tf, model_tf = model_convertedimg = image.load_img(args.image, target_size = (112, 112))img = image.img_to_array(img)img = img[..., ::-1]input_data = np.expand_dims(img, 0)with tf.Session() as sess:    init = tf.global_variables_initializer()    sess.run(init)    predict = sess.run(model_tf, feed_dict = {input_tf : input_data})print(predict)</code></pre><p><strong>执行命令</strong></p><pre><code class="lang-bash">python test_tensorflow.py -n tf_model.py -w tf_model.npy -i face.jpeg#info:2019-10-25 17:51:37.745502: I tensorflow/core/common_runtime/process_util.cc:71] Creating new thread pool with default inter op setting: 12. Tune using inter_op_parallelism_threads for best performance.[[ 0.3444912   0.10190725 -0.24501228  0.6819044   0.88096356  0.3477651  -0.9470245  -0.67586106 -0.43900767  0.8143126  -0.48990446 -0.43025535  -0.50643945 -0.27366814  0.63601726 -0.5352377   0.13765681  0.40842274   0.7652553  -0.8959763   0.42129317 -0.38290572  0.02023016 -0.14840023   0.91082776 -0.27738187 -0.60173315 -0.2149537   0.37644142  0.48894492  -0.8824413   0.3184655   0.19936629  0.2729676   1.5621389   0.4327973  -0.6486915  -0.23494866 -0.87087345 -0.77051604  0.09255352 -1.180374  -0.17184272  0.25432315 -0.19088425 -0.26873374  0.91608876 -0.18985137  -0.4793172  -0.3298719  -1.308598    1.2959337  -0.00581198  0.12396422   1.2034999   0.09919477 -1.9225347   0.92873377 -0.28599226  0.11249284  -1.4562793   1.876776   -1.2222495  -0.03905648  0.5152732   0.04876836   0.04672025 -0.32384863 -0.8834132   0.581934   -0.7378913  -0.30820462   0.22141635  0.72556514  0.2439455   0.6563256  -0.46760577 -0.38698506  -0.1146768  -0.9940842  -1.1298054   1.015199    0.03592021  0.67380327  -0.58148336  0.15656358 -0.06737413 -1.0402167  -0.9286856  -0.11091161  -0.66596127  0.03736706 -0.35337985 -0.41753066 -0.47258082 -0.62383235  -0.8661205  -0.52309173 -1.7838898   0.08661895 -0.02590791  0.23406385   0.7771991   1.4410769   0.41925538  0.45601875 -0.02141583  0.70055544  -0.587271   -0.3975702   1.2808259  -1.1874334  -0.27268624 -0.8244319   0.39704552 -1.2778007  -0.5276267  -0.2645575   1.2137012   0.04997464   0.05591418  1.0264043   1.5093954  -0.5634565  -1.1715722  -0.6463482   0.60211945  0.67259526]]</code></pre><h5 id="6-基于tf-model-npy和tf-model-py文件，固化参数，生成PB文件"><a href="#6-基于tf-model-npy和tf-model-py文件，固化参数，生成PB文件" class="headerlink" title="6.基于tf_model.npy和tf_model.py文件，固化参数，生成PB文件"></a>6.基于tf_model.npy和tf_model.py文件，固化参数，生成PB文件</h5><p>freeze_graph.py </p><pre><code class="lang-python">import tensorflow as tfimport tf_model as tf_fundef netWork():    model=tf_fun.KitModel(&quot;./tf_model.npy&quot;) #调用tf_model.py中的KitModel函数加载npy权重参数    return modeldef freeze_graph(output_graph):    output_node_names = &quot;output&quot;    data,fc1=netWork()    fc1=tf.identity(fc1,name=&quot;output&quot;)    graph = tf.get_default_graph()  # 获得默认的图    input_graph_def = graph.as_graph_def()  # 返回一个序列化的图代表当前的图    init = tf.global_variables_initializer()    with tf.Session() as sess:        sess.run(init)        output_graph_def = tf.graph_util.convert_variables_to_constants(  # 模型持久化，将变量值固定            sess=sess,            input_graph_def=input_graph_def,  # 等于:sess.graph_def            output_node_names=output_node_names.split(&quot;,&quot;))  # 如果有多个输出节点，以逗号隔开        with tf.gfile.GFile(output_graph, &quot;wb&quot;) as f:  # 保存模型            f.write(output_graph_def.SerializeToString())  # 序列化输出if __name__ == &#39;__main__&#39;:    freeze_graph(&quot;frozen_model.pb&quot;)    print(&quot;finish!&quot;)</code></pre><p>python freeze_graph.py </p><pre><code class="lang-bash">#info:Instructions for updating:Use tf.compat.v1.graph_util.extract_sub_graphfinish!</code></pre><p><strong>测试pb模型</strong></p><p>test_pb.py</p><pre><code class="lang-python">from tensorflow.contrib.keras.api.keras.preprocessing import imageimport tensorflow as tfimport numpy as npwith tf.gfile.FastGFile(&#39;frozen_model.pb&#39;,&#39;rb&#39;) as f:    graph_def = tf.GraphDef()    graph_def.ParseFromString(f.read())    tf.import_graph_def(graph_def, name=&#39;&#39;)with tf.Session() as sess:    img = image.load_img(&#39;face.jpeg&#39;, target_size = (112, 112))    img = image.img_to_array(img)    img = img[..., ::-1]    input_data = np.expand_dims(img, 0)    init = tf.global_variables_initializer()    sess.run(init)    #print(tf.get_default_graph().get_operations()) 根据输出值，可知输入tensor名为data 全连接层输出的tensor名为ouput    #op = sess.graph.get_tensor_by_name(&#39;fc1/add_1:0&#39;)    #predict = sess.run(op, feed_dict = {&#39;data:0&#39; : input_data})    op = sess.graph.get_tensor_by_name(&#39;output:0&#39;)    predict = sess.run(op, feed_dict = {&#39;data:0&#39; : input_data})print(predict)</code></pre><p>python test_pb.py</p><pre><code class="lang-bash">#info:[[ 0.3444914   0.10190733 -0.2450121   0.68190414  0.8809633   0.3477656  -0.94702375 -0.6758606  -0.43900838  0.8143138  -0.48990518 -0.43025577  -0.5064386  -0.2736677   0.6360168  -0.5352382   0.13765849  0.40842175   0.7652537  -0.8959745   0.42129484 -0.3829043   0.02023116 -0.14839967   0.9108265  -0.27738202 -0.6017342  -0.21495399  0.37644026  0.48894358  -0.88244045  0.31846407  0.19936593  0.2729677   1.5621401   0.4327974  -0.6486902  -0.23494998 -0.8708729  -0.7705149   0.09255301 -1.1803752  -0.17184293  0.25432175 -0.19088468 -0.2687335   0.91608775 -0.18984997  -0.4793176  -0.32987317 -1.3085989   1.295933   -0.00581315  0.12396483   1.2034997   0.09919491 -1.9225343   0.9287349  -0.28599253  0.11249258  -1.4562799   1.876776   -1.222248   -0.03905599  0.5152738   0.04876841   0.04672143 -0.32384768 -0.88341135  0.58193433 -0.73789096 -0.30820417   0.22141536  0.7255656   0.24394391  0.65632653 -0.4676048  -0.38698527  -0.11467646 -0.9940818  -1.1298064   1.0152006   0.03592108  0.6738041  -0.5814836   0.1565624  -0.06737386 -1.0402162  -0.92868716 -0.1109117  -0.66596234  0.03736827 -0.35337996 -0.41753033 -0.4725821  -0.623832  -0.86612093 -0.5230911  -1.7838906   0.0866183  -0.02590806  0.23406453   0.77719873  1.4410781   0.41925526  0.45601833 -0.02141543  0.7005538  -0.5872698  -0.39757127  1.2808269  -1.1874311  -0.2726869  -0.8244321   0.39704597 -1.2778006  -0.5276277  -0.26455772  1.2137022   0.04997511   0.05591565  1.0264047   1.5093955  -0.56345737 -1.1715721  -0.64634734   0.60211873  0.67259526]]</code></pre><h5 id="7-pb模型转换为-tflite模型供tensorflow-lite调用-移动端部署"><a href="#7-pb模型转换为-tflite模型供tensorflow-lite调用-移动端部署" class="headerlink" title="7. .pb模型转换为.tflite模型供tensorflow lite调用(移动端部署)"></a>7. .pb模型转换为.tflite模型供tensorflow lite调用(移动端部署)</h5><p>pb2tflite.py</p><pre><code class="lang-python">import tensorflow as tfconvert=tf.lite.TFLiteConverter.from_frozen_graph(&quot;frozen_model.pb&quot;,input_arrays=[&quot;data&quot;],                                                  output_arrays=[&quot;output&quot;],                                                  input_shapes={&quot;data&quot;:[1,112,112,3]})convert.post_training_quantize=True #是否量化tflite_model=convert.convert()open(&quot;mobilenet.tflite&quot;,&quot;wb&quot;).write(tflite_model)print(&quot;finish!&quot;)</code></pre><p>python pb2tflite.py</p><p>info: 文件夹中生成mobilenet.tflite</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模型转换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mxnet Windows编译安装CPU版 c++ api</title>
    <link href="/2019/09/19/mxnet%20Windows%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85CPU%E7%89%88/"/>
    <url>/2019/09/19/mxnet%20Windows%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85CPU%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h1 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h1><p>win10 x64 、Visual Studio 2015、cmake 3.0+、python2.7 (环境变量需配置)</p><h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><p>1.OpenBLAS-v0.2.14-Win64-int64 下载地址：<a href="https://sourceforge.net/projects/openblas/files/v0.2.14/" target="_blank" rel="noopener">https://sourceforge.net/projects/openblas/files/v0.2.14/</a></p><p>解压安装后，添加环境变量<strong>OpenBLAS_HOME</strong> 值为openblas的目录，即：your_dir/openblas</p><p>2.OpenCV 3.0+ 下载地址：<a href="https://sourceforge.net/projects/opencvlibrary/files/opencv-win/3.3.1/opencv-3.3.1-vc14.exe/download" target="_blank" rel="noopener">https://sourceforge.net/projects/opencvlibrary/files/opencv-win/3.3.1/opencv-3.3.1-vc14.exe/download</a></p><p>安装后，添加环境变量<strong>OpenCV_DIR</strong> 值为<strong>your_dir\opencv3.3.1\build</strong>,并在<strong>path</strong>环境变量中添加<strong>your_dir\opencv3.3.1\build\x64\vc14\bin</strong></p><h1 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h1><p>1.git clone项目到本地 <strong>（版本1.5.1）</strong></p><pre><code class="lang-bash">git clone --recursive https://github.com/apache/incubator-mxnet mxnet</code></pre><p>2.在mxnet目录下创建build目录</p><p>3.启动cmake-gui.exe进行mxnet.sln工程的生成</p><p>设置mxnet源码路径和mxnet编译路径,点击configure,选择visual studio 2015 win64</p><p>生成的配置中，仅仅勾选<strong>use_opencv,use_openmp,use_cpp_package</strong>即可，如图所示</p><p><img src="/images/note/11.jpg" srcset="/img/loading.gif" alt="11"></p><p>若提示找不到opencv路径，则手动设置opencv路径即可，如图所示</p><p><img src="/images/note/12.jpg" srcset="/img/loading.gif" alt="11"></p><p>重新点击configure,配置选项未显示红框且最终信息显示Configuring done，则配置成功</p><p>若显示红框，则将显示红框的勾去掉，再重新configure（只保留<strong>use_opencv,use_openmp,use_cpp_package</strong>的勾选）</p><p>点击generate,生成mxnet.sln，生成成功会在build目录下出现mxnet.sln工程，如图所示</p><p><img src="/images/note/13.jpg" srcset="/img/loading.gif" alt="11"></p><p>拷贝如下dll文件至mxnet\cpp-package\scripts目录下<br>libopenblas.dll<br>opencv_world331.dll opencv_ffmpeg331_64.dll<br>(来自opencv3.3.1安装目录)<br>libgcc_s_seh-1.dll libgfortran-3.dll libquadmath-0.dll<br>(来自mingw64_dll 下载地址：<a href="https://sourceforge.net/projects/openblas/files/v0.2.14/" target="_blank" rel="noopener">https://sourceforge.net/projects/openblas/files/v0.2.14/</a>)</p><p><img src="/images/note/17.jpg" srcset="/img/loading.gif" alt="11"></p><p>4.利用visual studio 2015 打开mxnet.sln 并执行编译</p><p><img src="/images/note/14.jpg" srcset="/img/loading.gif" alt="11"></p><p>右键ALL_BUILD,点击生成执行编译，编译成功后会在build/release生成mxnet.lib和mxnet.dll,同时会在mxnet\cpp-package\include\mxnet-cpp生成op.h头文件</p><p>如图所示</p><p><img src="/images/note/15.jpg" srcset="/img/loading.gif" alt="11"></p><p><img src="/images/note/16.jpg" srcset="/img/loading.gif" alt="11"></p><p><img src="/images/note/18.jpg" srcset="/img/loading.gif" alt="11"></p><p>5.若自动生成op.h头文件失败，则手动生成c++ op.h头文件</p><p>重新configure（只保留<strong>use_opencv,use_openmp</strong>的勾选）再点击generate,生成mxnet.sln 重新利用Visual Studio 2015编译</p><p>拷贝如下dll文件至mxnet\cpp-package\scripts目录下</p><p>mxnet.dll<br>libopenblas.dll<br>opencv_world331.dll opencv_ffmpeg331_64.dll<br>(来自opencv3.3.1安装目录)<br>libgcc_s_seh-1.dll libgfortran-3.dll libquadmath-0.dll<br>(来自mingw64_dll 下载地址：<a href="https://sourceforge.net/projects/openblas/files/v0.2.14/" target="_blank" rel="noopener">https://sourceforge.net/projects/openblas/files/v0.2.14/</a>)</p><p><img src="/images/note/17.jpg" srcset="/img/loading.gif" alt="11"></p><p>执行如下命令，生成op.h</p><pre><code class="lang-bash">python OpWrapperGenerator.py mxnet.dll</code></pre><p><strong>错误处理</strong><br>1.<a href="https://github.com/apache/incubator-mxnet/issues/14116" target="_blank" rel="noopener">https://github.com/apache/incubator-mxnet/issues/14116</a><br>···bash<br>Build config:<br>1&gt;——— Build started: Project: cpp_package_op_h, Configuration: Release x64 ———<br>1&gt;”Running: OpWrapperGenerator.py”<br>1&gt;D:/Projects/MXNet-versions/MxNet1-3-1/build/Release/libmxnet.dll<br>1&gt;argument “lrs” of operator “multi_sgd_update” has unknown type “, required”<br>1&gt;argument “wds” of operator “multi_sgd_update” has unknown type “, required”<br>1&gt;argument “lrs” of operator “multi_sgd_mom_update” has unknown type “, required”<br>1&gt;argument “wds” of operator “multi_sgd_mom_update” has unknown type “, required”<br>1&gt;argument “lrs” of operator “multi_mp_sgd_update” has unknown type “, required”<br>1&gt;argument “wds” of operator “multi_mp_sgd_update” has unknown type “, required”<br>1&gt;argument “lrs” of operator “multi_mp_sgd_mom_update” has unknown type “, required”<br>1&gt;argument “wds” of operator “multi_mp_sgd_mom_update” has unknown type “, required”<br>========== Build: 1 succeeded, 0 failed, 3 up-to-date, 0 skipped ==========</p><pre><code>解决方案：https://github.com/apache/incubator-mxnet/pull/15144/files</code></pre>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mxnet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cmake教程</title>
    <link href="/2019/08/07/cmake%E6%95%99%E7%A8%8B/"/>
    <url>/2019/08/07/cmake%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>1.hello world</strong> </p><p>main.cpp</p><pre><code class="lang-c++">int main(){  std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;  return 0;}</code></pre><p>CMakeLists.txt</p><pre><code class="lang-bash">cmake_minimum_required(VERSION 3.14) #最低cmake版本project(test) #定义项目名称set(CMAKE_CXX_STANDARD 11) #设置c++编译标准版本add_executable(test main.cpp)</code></pre><p>构建</p><pre><code class="lang-bash">cmake . #.代表本目录make</code></pre><p>Note:</p><p>1.project(name)会同时隐式定义NAME_BINARY_DIR 以及NAME_SOURCE_DIR变量</p><p>2.SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]]) 定义变量:set( SRC_LIST main.cpp test.cpp)</p><p>3.ADD_EXECUTABLE(test ${SRC_LIST}) 生成名为test的可执行文件 源文件为SRC_LIST</p><p>4.变量使用${}取值，在IF控制语句中直接使用变量名</p><p>指令(参数1 参数2 …) 指令不区分大小写 参数区分大小写</p><p>》〉》以上hello world 的编译为内部编译，无法删除中间文件</p><p>5.外部构建(通常的方式)</p><pre><code class="lang-bash">sudo mkdir build #在工程目录任意位置 cd buildcmake .. #..代表父目录(包含CMakeLists.txt构建文件)make</code></pre><p>6.ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) 当前工程添加源文件存放的子目录并指定目标二进制文件存放目录：</p><p>ADD_SUBDIRECTORY(src bin)</p><p>7.cmake -DCMAKE_INSTALL_PREFIX=/usr/local . #-DCMAKE_INSTALL_PREFIX指定安装目录</p><p>8.INSTALL指令 DCMAKE_INSTALL_PREFIX默认为/usr/local目录</p><p><strong>目标文件的安装</strong></p><p>INSTALL(<strong>TARGETS</strong> targets… </p><p>​                [</p><p>​                [ARCHIVE|LIBRARY|RUNTIME] </p><p>​                [DESTINATION (dir)]</p><p>​                [PERMISSIONS permissions…] </p><p>​                [CONFIGURATIONS [Debug|Release|…]</p><p>​                ]</p><p>​                [COMPONENT \<component\>] [OPTIONAL] ] […])</p><p>INSTALL(TARGETS myrun mylib mystaticlib </p><p>​               RUNTIME DESTINATION bin </p><p>​               LIBRARY DESTINATION lib </p><p>​               ARCHIVE DESTINATION libstatic ) </p><p>可执行文件 myrun 安装到${CMAKE_INSTALL_PREFIX}/bin 目录 </p><p>动态库 libmylib 安装到${CMAKE_INSTALL_PREFIX}/lib 目录 </p><p>静态库 libmystaticlib 安装到${CMAKE_INSTALL_PREFIX}/libstatic 目录</p><p><strong>普通文件的安装</strong></p><p>INSTALL(<strong>FILES</strong> files… </p><p>​              DESTINATION (dir)</p><p>​              [PERMISSIONS permissions…] [CONFIGURATIONS [Debug|Release|…]] [COMPONENT (component)] [RENAME (name)] [OPTIONAL])</p><p><strong>2.静态库与动态库构建</strong></p><p>ADD_LIBRARY(libname [SHARED|STATIC|MODULE] [EXCLUDE_FROM_ALL] source1 source2 … sourceN)</p><p>工程目录 CMakeLists.txt</p><pre><code>PROJECT(HELLOLIB) ADD_SUBDIRECTORY(lib)</code></pre><p>līb目录下 CMakeLists.txt</p><pre><code class="lang-bash">SET(LIBHELLO_SRC hello.c) ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC}) #动态库ADD_LIBRARY(hello_static STATIC ${LIBHELLO_SRC}) #静态库SET_TARGET_PROPERTIES(hello_static PROPERTIES OUTPUT_NAME &quot;hello&quot;) #使得动态库和静态库同名SET_TARGET_PROPERTIES(hello PROPERTIES CLEAN_DIRECT_OUTPUT 1) #防止同名时被清理SET_TARGET_PROPERTIES(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT 1) #防止同名时被清理INSTALL(TARGETS hello hello_static                 LIBRARY DESTINATION lib                 ARCHIVE DESTINATION lib)</code></pre><p>构建并安装</p><pre><code class="lang-bash">sudo mkdir build cd buildcmake -DCMAKE_INSTALL_PREFIX=/usr .. makemake install</code></pre><p>lib目录生成libhello.so libhello.a文件,并安装到/usr/bin目录</p><p><strong>3.外部共享库和头文件的使用</strong></p><pre><code class="lang-bash">INCLUDE_DIRECTORIES([AFTER|BEFORE] [SYSTEM] dir1 dir2 ...) #添加包含目录指令INCLUDE_DIRECTORIES(/usr/include/hello)LINK_DIRECTORIES(directory1 directory2 ...) 添加共享库目录TARGET_LINK_LIBRARIES(target library1 library2 ...) #为目标文件添加需要的共享库TARGET_LINK_LIBRARIES(main libhello.so) #动态库TARGET_LINK_LIBRARIES(main libhello.a) #静态库</code></pre><p><strong>4.cmake 常用指令</strong></p><p>ADD_DEFINITIONS(-D…)：向 C/C++编译器添加-D 定义</p><p>AUX_SOURCE_DIRECTORY(dir VARIABLE)：发现一个目录下所有的源代码文件并将列表存储在一个变量中</p><p>AUX_SOURCE_DIRECTORY(. SRC_LIST)</p><p>ADD_EXECUTABLE(main ${SRC_LIST})</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>make</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构(7) 排序</title>
    <link href="/2019/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(7)%20%E6%8E%92%E5%BA%8F/"/>
    <url>/2019/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(7)%20%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p><strong>直接插入排序</strong></p><p>把$n$个待排序的元素假设为一个有序表和一个无序表，开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次即可完成排序过程</p><pre><code class="lang-c++">void insertSort(int array[],int n) {    int i, j, key;    for (i = 1; i &lt; n; i++) {        if (array[i] &lt; array[i - 1]) {            key = array[i];//设置为哨兵            //找到合适的插入位置并将比key大的元素后移            for (j = i - 1; key &lt; array[j] &amp;&amp; j &gt;= 0; --j)                array[j + 1] = array[j];            array[j + 1] = key;//插入        }    }}</code></pre><p><strong>折半插入排序</strong></p><pre><code class="lang-c++">void insertSortbyHalf(int array[],int n){    int i,j,key,mid,low,high;    for (i = 1; i &lt; n; i++) {        if(array[i] &lt; array[i-1]){            key = array[i];            low = 0,high = i-1;              //找到插入的位置            while(low &lt;= high){                mid = (low + high) / 2;                if(key &lt; array[mid])                    high = mid - 1;                else                    low = mid + 1;            }              //统一移动元素            for(j = i-1;j &gt;= high+1;j--){                array[j+1] = array[j];            }            array[j+1] = key;//插入        }    }}</code></pre><p><strong>希尔排序</strong></p><p>增量序列 $d<em>1，d_2，\cdots，d_k$，其中 $d_1=n/2,d</em>{i+1}=[d_i/2],d_k = 1$；</p><p>按增量序列个数 $k$，对序列进行 $k$ 趟排序；</p><p>每趟排序，先根据对应的增量 $d_i$，将待排序序列分割为$d_i$个组，距离为$d_i$的元素为同一组，再对每个组进行直接插入排序，直到$d_i =1$,即所有元素已在同一组中，再进行一次直接插入排序</p><p><img src="\images\dataStructure\81.png" srcset="/img/loading.gif" alt=""></p><pre><code class="lang-c++">void shellSort(int array[],int n) {    int di, i,j, key;    for (di = n/2; di &gt;= 1; di = di/2) {//设置增量        //分组并进行插入排序        for (i = di; i &lt; n; i++) {            if (array[i] &lt; array[i - di]) {                key = array[i];                for (j = i - di; j &gt;= 0 &amp;&amp; key &lt; array[j]; j = j - di) {                    array[j + di] = array[j];                }                array[j + di] = key;            }        }    }}</code></pre><h1 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h1><p><strong>冒泡排序</strong></p><p>每次比较两个相邻的元素，如果其顺序错误就交换</p><pre><code class="lang-c++">void bubbleSort(int array[],int n) {    int key;    for (int i = 0; i &lt; n-1;i++) {        //LEN-i:每一次都已归位一个数,不再需要与已归位的数比较        for (int j = 0; j &lt; n - i - 1; j++) {            if (array[j] &gt; array[j + 1]) {                key = array[j];                array[j] = array[j + 1];                array[j + 1] = key;            }        }    }}</code></pre><p><strong>快速排序</strong></p><p>1.设置两个变量$i,j$，初始化：$i=0，j=n-1$；<br>2.基准数 $key=array[0]$ ；<br>3.从 $j$ 开始向前搜索，即由后开始向前搜索 $(j—)$ ，找到第一个小于 $key$ 的值 $array[j]$ ，将 $array[j]$ 和 $array[i]$ 的值交换；<br>4.从 $i$ 开始向后搜索，即由前开始向后搜索 $(i++)$ ，找到第一个大于key的 $array[i]$ ，将 $array[i]$ 和 $array[j]$ 的值交换；<br>5.重复第3、4步，直到 $i=j$ ；</p><p>经过一趟上述步骤后，基准数左边全小于基准数，基准数右边全大于基准数，通过分治法继续处理左、右</p><pre><code class="lang-c++">void quickSort(int array[], int left, int right){    if (left &gt;= right){        return;    }    int i = left;    int j = right;    int key = array[left];//基准数    while (i &lt; j){        //向前寻找小于key的数        while (i &lt; j &amp;&amp; key &lt;= array[j]){            j--;        }        array[i] = array[j];        //向后寻找大于key的数        while (i &lt; j &amp;&amp; key &gt;= array[i]){            i++;        }        array[j] = array[i];    }    array[i] = key;//基准数归位    quickSort(array, left, i - 1);//分治处理左边    quickSort(array, i + 1, right);//分治处理右边}</code></pre><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p><strong>简单选择排序</strong></p><p>(1)在未排序序列中找到最小/大元素，存放到排序序列的起始位置;(2)再从剩余未排序元素中继续寻找最小/大元素，放到已排序序列的末尾;重复第二步，直到所有元素均排序完毕</p><p><img src="\images\dataStructure\selectionSort.gif" srcset="/img/loading.gif" alt=""></p><pre><code class="lang-c++">void selectSort(int array[], int n) {    for (int i = 0; i &lt; n - 1; i++) {        int min = i;        for (int j = i + 1; j &lt; n; j++) {            if (array[j] &lt; array[min])                min = j;        }        if (i != min) {            int temp = array[i];            array[i] = array[min];            array[min] = temp;        }    }}</code></pre><p><strong>堆排序</strong></p><p>堆是具有以下性质的完全二叉树：</p><p>1.每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；</p><p>2.每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆；</p><p><img src="\images\dataStructure\45.jpg" srcset="/img/loading.gif" alt=""></p><p>堆排序算法步骤：</p><p>1.构造初始堆，将无序序列构造为大顶堆，从倒数第一个非叶子结点开始调整,从左至右，从下至上进行调整；</p><p>倒数第$i$个非叶子结点索引$index=array.length/2^i-1(i=1,2,3\dots|2^i\leqslant  array.length)$</p><p><img src="\images\dataStructure\46.jpg" srcset="/img/loading.gif" alt=""></p><p>2.将堆顶元素与末尾元素进行交换，使末尾元素最大，然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素，如此反复进行交换、重建、交换…</p><p><img src="\images\dataStructure\47.jpg" srcset="/img/loading.gif" alt=""></p><pre><code class="lang-c++">void swap(int* a, int* b){    int temp = *b;    *b = *a;    *a = temp;}void max_heapify(int array[], int start, int end){    //建立父节点指标和子结点指标    int dad = start;    int son = dad * 2 + 1;    while (son &lt;= end){//若子结点索引在范围内才做比较        //先比较两个子结点大小，选择最大的        if (son + 1 &lt;= end &amp;&amp; array[son] &lt; array[son + 1])            son++;        if (array[dad] &gt; array[son]) //如果父节点大於子结点代表调整完毕，直接跳出函数            return;        else{            swap(&amp;array[dad], &amp;array[son]);            dad = son;            son = dad * 2 + 1;        }    }}void heap_sort(int array[], int len){    int i;    //初始化，生成最大堆    for (i = len / 2 - 1; i &gt;= 0; i--)        max_heapify(array, i, len - 1);    //堆顶元素与末尾元素进行交换，再重新调整，直到排序完毕    for (i = len - 1; i &gt; 0; i--){        swap(&amp;array[0], &amp;array[i]);        max_heapify(array, 0, i - 1);    }}</code></pre><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>假定含有$n$个元素的待排序表，则可视为$n$个有序的子表，每个子表长度为1，然后两两归并，得到[$n/2$]个长度为2或1的有序表；再两两归并$\cdots$,直到合并长度为$n$的有序表为止</p><p><img src="\images\dataStructure\82.png" srcset="/img/loading.gif" alt=""></p><pre><code class="lang-c++">void merge(int array[], int low, int mid, int high, int temp[]){    int i = low, j = mid + 1;    int m = mid, n = high;    int k = 0;    while (i &lt;= m &amp;&amp; j &lt;= n){        if (array[i] &lt;= array[j])            temp[k++] = array[i++];        else            temp[k++] = array[j++];    }    while (i &lt;= m)        temp[k++] = array[i++];    while (j &lt;= n)        temp[k++] = array[j++];    for (i = 0; i &lt; k; i++)        array[low + i] = temp[i];}void mergesort(int array[], int low, int high, int temp[]){    if (low &lt; high){        int mid = (low + high) / 2;        mergesort(array, low, mid, temp);            mergesort(array, mid + 1, high, temp);         merge(array, low, mid, high, temp);    }}</code></pre><hr><p><img src="\images\dataStructure\83.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构(6) 查找</title>
    <link href="/2019/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(6)%20%E6%9F%A5%E6%89%BE/"/>
    <url>/2019/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(6)%20%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h1><p>1.一般线性表</p><pre><code class="lang-c++">typedef struct{    ElemType *elem;//0号单元留空    int length;}STable;int search(STable table,ElemType key){    table.elem[0] = key;//哨兵    for(int i = table.length;table.elem[i] != key; --i);    return i;}</code></pre><h1 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h1><pre><code class="lang-c++">int binary_search(SeqList list,ElemType key){    int low = 0;high = list.length-1;mid;    while(low &lt;= high){        mid = (low+high)/2;        if(list.elem[mid] == key)            return mid;        else if(list.elem[mid] &lt; key)            low = mid+1;        else            high = mid-1;    }    return -1;//查找失败}</code></pre><h1 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h1><p>$B$树中所有结点的子结点数的最大值称为$B$树的阶，一个 $m$ 阶的$B$树是一个有以下属性的树：</p><p><strong>1</strong>.每一个结点最多有 $m $个子结点，即每个结点至多含有$m-1$个关键字<br>2.每一个非叶子结点（除根结点）最少有 $⌈m/2⌉$ 个子结点,即至少含有$[m/2]-1$个关键字<br>3.如果根结点不是叶子结点，那么它至少有两个子结点<br>4.有 $k$ 个子结点的非叶子结点拥有 $k − 1$ 个键<br>5.所有的叶子结点都在同一层</p><p>非根内部结点的关键字个数$n$范围：$[m/2]-1 \leq n \leq m-1$,根结点关键字个数$n$范围：$1 \leq n\leq m-1$</p><p>每一个内部结点的键将结点的子树分开。</p><p>例如，如果一个内部结点有3个子结点（子树），那么它就必须有两个键： $a_1 $和 $a_2$ </p><p>左边子树的所有值都必须小于 $a_1$ ，中间子树的所有值都必须在 $a_1$ 和$a_2$ 之间，右边子树的所有值都必须大于$ a_2$ </p><p><img src="\images\dataStructure\44.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>B树的查找</strong></p><p>1.在$B$中找结点 (读入内存) 2.在结点内找关键字(通过顺序查找或折半查找查找等于key的关键字)</p><p><strong>B树的插入</strong></p><p>所有的插入都从根结点开始，要插入一个新的元素，首先搜索这棵树，找到新元素应该被添加到的叶子结点</p><p>将新元素插入到这一结点中的步骤如下：</p><p>如果结点拥有的元素数量小于最大值，那么有空间容纳新的元素，将新元素插入到这一结点，且保持结点中元素有序，否则这一结点已经满了，将它平均地分裂成两个结点：从叶子结点的元素和新的元素中选择出中位数；小于这一中位数的元素放入左边结点，大于这一中位数的元素放入右边结点，中位数作为分隔值.<br><strong>分隔值被插入到父结点中</strong>，这可能会造成父结点分裂，分裂父结点时可能又会使它的父结点分裂，以此类推.如果没有父结点（这一结点是根结点），就创建一个新的根结点（增加了树的高度）,即如果分裂一直上升到根节点，那么一个新的根节点会被创建，它有一个分隔值和两个子节点</p><blockquote><p>以5阶B树为例</p></blockquote><p>[]: <a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">https://www.cnblogs.com/nullzx/p/8729425.html</a></p><p>1.空树中插入39</p><p><img src="\images\dataStructure\45.png" srcset="/img/loading.gif" alt=""></p><p>2.继续插入22，97和41</p><p><img src="\images\dataStructure\46.png" srcset="/img/loading.gif" alt=""></p><p>3.继续插入53</p><p><img src="\images\dataStructure\47.png" srcset="/img/loading.gif" alt=""></p><p>插入后超过了最大允许的关键字个数4，需以中位数(41)为中心进行分裂</p><p><img src="\images\dataStructure\48.png" srcset="/img/loading.gif" alt=""></p><p>4.依次插入13，21，40，同样会造成分裂，结果如下图</p><p><img src="\images\dataStructure\49.png" srcset="/img/loading.gif" alt=""></p><p>5.依次插入30，27, 33 ；36，35，34 ；24，29</p><p><img src="\images\dataStructure\50.png" srcset="/img/loading.gif" alt=""></p><p>6.插入key值为26的记录</p><p><img src="\images\dataStructure\51.png" srcset="/img/loading.gif" alt=""></p><p>当前结点需要以27为中心分裂,并向父结点插入27</p><p><img src="\images\dataStructure\52.png" srcset="/img/loading.gif" alt=""></p><p>插入后导致当前结点（即根结点）也需要分裂</p><p><img src="\images\dataStructure\53.png" srcset="/img/loading.gif" alt=""></p><p><strong>B树的删除</strong></p><p>删除时，需要判断结点中关键字的个数$\geqslant [m/2]-1$</p><blockquote><p>5阶B树为例，结点最多有4个key,最少有2个key</p></blockquote><p>[]: <a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">https://www.cnblogs.com/nullzx/p/8729425.html</a></p><p><img src="\images\dataStructure\54.png" srcset="/img/loading.gif" alt=""></p><p>1.B树中删除21，删除后结点中的关键字个数仍然大于等2，删除结束</p><p><img src="\images\dataStructure\55.png" srcset="/img/loading.gif" alt=""></p><p>2.删除27，27位于非叶子结点中，利用27的后继28替代</p><p><img src="\images\dataStructure\56.png" srcset="/img/loading.gif" alt=""></p><p>删除后，当前叶子结点的关键字的个数小于2，而它的兄弟结点中有3个关键字，从兄弟结点中借取一个关键字</p><p><img src="\images\dataStructure\57.png" srcset="/img/loading.gif" alt=""></p><p>3.删除32</p><p><img src="\images\dataStructure\58.png" srcset="/img/loading.gif" alt=""></p><p>删除后，当前结点中只有一个关键字，而兄弟结点中也仅有2个关键字，只能让父结点中的30下移并和兄弟结点中的关键字合并，成为一个新的结点，当前结点的指针指向父结点</p><p><img src="\images\dataStructure\59.png" srcset="/img/loading.gif" alt=""></p><p>4.删除40</p><p><img src="\images\dataStructure\60.png" srcset="/img/loading.gif" alt=""></p><p>同理，当前结点的关键字数小于2，兄弟结点中没有多余关键字，所以父结点中的关键字下移，和兄弟结点(左右兄弟结点都可)的关键字合</p><p><img src="\images\dataStructure\61.png" srcset="/img/loading.gif" alt=""></p><p>当前结点关键字个数小于2，继续合并</p><p><img src="\images\dataStructure\62.png" srcset="/img/loading.gif" alt=""></p><p><strong>B+树</strong></p><p>1.每个分支结点最多有$m$个子结点</p><p>2.结点的子结点个数与关键字个数相等(或结点的子结点个数 = 关键字个数+1)</p><p>3.所有叶结点包含全部关键字及指向记录的指针，且叶结点中关键字按大小顺序排列，所有相邻结点按大小顺序互相链接</p><p>4.非根内部结点的关键字个数$n$范围：$[m/2] \leq n \leq m$,根结点关键字个数$n$范围：$1 \leq n\leq m$</p><p><img src="\images\dataStructure\63.png" srcset="/img/loading.gif" alt=""></p><p><strong>B+树的插入</strong></p><blockquote><p>以5阶B树为例</p></blockquote><p>1.空树中插入5</p><p><img src="\images\dataStructure\64.png" srcset="/img/loading.gif" alt=""></p><p>2.依次插入8，10，15</p><p><img src="\images\dataStructure\65.png" srcset="/img/loading.gif" alt=""></p><p>3.插入16</p><p>插入16后超过了关键字的个数限制，需进行分裂</p><p><img src="\images\dataStructure\66.png" srcset="/img/loading.gif" alt=""></p><p>4.插入17</p><p><img src="\images\dataStructure\67.png" srcset="/img/loading.gif" alt=""></p><p>5.插入18</p><p><img src="\images\dataStructure\68.png" srcset="/img/loading.gif" alt=""></p><p>当前结点的关键字个数大于限制的个数，需进行分裂</p><p><img src="\images\dataStructure\69.png" srcset="/img/loading.gif" alt=""></p><p>6.插入若干数据</p><p><img src="\images\dataStructure\70.png" srcset="/img/loading.gif" alt=""></p><p>7.插入7</p><p><img src="\images\dataStructure\71.png" srcset="/img/loading.gif" alt=""></p><p>当前结点的关键字个数大于限制的个数，需进行分裂</p><p><img src="\images\dataStructure\72.png" srcset="/img/loading.gif" alt=""></p><p>当前结点的关键字个数大于限制的个数，需进行分裂</p><p><img src="\images\dataStructure\73.png" srcset="/img/loading.gif" alt=""></p><p><strong>B+树的删除</strong></p><blockquote><p>以5阶B树为例</p></blockquote><p><img src="\images\dataStructure\74.png" srcset="/img/loading.gif" alt=""></p><p>1.删除22</p><p><img src="\images\dataStructure\75.png" srcset="/img/loading.gif" alt=""></p><p>2.删除15</p><p><img src="\images\dataStructure\76.png" srcset="/img/loading.gif" alt=""></p><p>删除后当前结点只有一个关键字，不满足条件，而兄弟结点有三个关键字，从兄弟结点中借关键字为9,同时更新将父结点中的关键字由10变为9，删除结束</p><p><img src="\images\dataStructure\77.png" srcset="/img/loading.gif" alt=""></p><p>3.删除7</p><p><img src="\images\dataStructure\78.png" srcset="/img/loading.gif" alt=""></p><p><img src="\images\dataStructure\79.png" srcset="/img/loading.gif" alt=""></p><p><img src="\images\dataStructure\80.png" srcset="/img/loading.gif" alt=""></p><h1 id="散列-hash-表"><a href="#散列-hash-表" class="headerlink" title="散列(hash)表"></a>散列(hash)表</h1><p><strong>散列函数</strong></p><p>一个把查找表中的关键字映射为该关键字对应的地址函数，记$Hash(key)=Address$</p><p>1.直接定址法 $Hash(key)=a\times key+b$，($a,b$未常数)</p><p>2.除留余数法 $Hash(key)=key\%p$，($p$为质数)</p><p>3.数字分析法 设关键字是$r$进制数，选取数码分布较为均匀的若干位作为散列地址</p><p>4.平方取中法 取关键字的平方值的中间几位作为散列地址</p><p>5.折叠法 将关键字分割成位数相同的块，取块的叠加和作为散列地址</p><p><strong>冲突处理</strong></p><p>散列函数可能会把两个或两个以上的的不同关键字映射到同一地址，这种情况称为”冲突”</p><p>设散列函数为$Hash(key),H_i$表示发生冲突后第$i$次探测的散列地址</p><p>1.开放定址法</p><script type="math/tex; mode=display">H_i=(Hash(key)+d_i)\%m</script><p>$m$表示散列表长度，$d_i$为增量序列</p><p>$d_i$的选取方法：</p><p>1) 线性探测法 $d_i=0,1,2,3,\cdots,m-1$</p><p>2) 平方探测法 $d_i=0^2,1^2,-1^2,2^2,-2^2,\cdots ,k^2,-k^2(k\leqslant m/2)$</p><p>3) 再散列法或双散列法 $d_i=Hash_2(key)$，即$H_i=(Hash(key)+i*Hash_2(key))\%m$($i$为冲突次数)</p><p>4) 伪随机序列法 $d_i=$伪随机数序列</p><p>2.拉链法</p><p>同义词存储在一个线性链表$L_i$中,散列地址为$i$的同义词链表$L_i$的头指针存放在散列表第$i$个单元中</p><p><strong>散列查找过程</strong></p><p>1.初始化：$address = Hash(key)$</p><p>2.若$L[address]=NULL$,则查找失败；若$L[address]\neq NULL$且$L[address]\neq key$，则$H_1=(address+1)\%m$,若$L[H_1]\neq NULL$且$L[H_1]\neq key$,则$H_2=(H_1+2)\%m$,若$L[H_2]\neq NULL$且$L[H_1]\neq key$,则$H_3=\cdots$</p><p>重复执行$H<em>{i+1}=(H_i+(i+1))\%m$ ($i=1,2,3,\cdots,m-1$),直到$L[H</em>{i+1}]=key或L[H_{i+1}]=NULL$</p><h1 id="字符串模式匹配"><a href="#字符串模式匹配" class="headerlink" title="字符串模式匹配"></a>字符串模式匹配</h1><p>1.简单的模式匹配算法</p><p>从主串S的指定字符开始，和模式串的第一个字符比较，若相等则继续逐个比较后续字符，直到模式串中的每个字符依次和主串的一个连续字符序列相等，则匹配成功；若比较过程中有某对字符不相等，则从主串的下一个字符重新与模式串的第一个字符相比较。</p><pre><code class="lang-c++">int matching(String target, String pattern, int begin) {        // i为目标串target的索引        int i = begin;        // j为模式串pattern的索引        int j = 0;        if (target == null || pattern == null || begin &gt; target.length()) {            return -1;        }        while (i &lt; target.length() &amp;&amp; j &lt; pattern.length()){            if (target[i] == pattern[j]) {                i++;                j++;            } else {                i = i - j + 1;                j = 0;            }        }        // 模式串是否存在于目标串        if (j == pattern.length()) {            return i - pattern.length() ;        }        return -1;    }</code></pre><p>2.KMP模式匹配算法</p><p>wait</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>opencv3(2) 图像载入-显示-输出</title>
    <link href="/2019/07/10/opencv3(2)%20%E5%9B%BE%E5%83%8F%E8%BD%BD%E5%85%A5-%E6%98%BE%E7%A4%BA-%E8%BE%93%E5%87%BA/"/>
    <url>/2019/07/10/opencv3(2)%20%E5%9B%BE%E5%83%8F%E8%BD%BD%E5%85%A5-%E6%98%BE%E7%A4%BA-%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<ul><li>载入函数</li></ul><pre><code class="lang-cpp">Mat imread( const String&amp; filename, int flags = IMREAD_COLOR );IMREAD_UNCHANGED   = -1, //!&lt; If set, return the loaded image as is (with alpha channel, otherwise it gets cropped).IMREAD_GRAYSCALE   = 0,  //!&lt; If set, always convert image to the single channel grayscale image.IMREAD_COLOR       = 1,  //!&lt; If set, always convert image to the 3 channel BGR color image.IMREAD_ANYDEPTH    = 2,  //!&lt; If set, return 16-bit/32-bit image when the input has the corresponding depth, otherwise convert it to 8-bit.IMREAD_ANYCOLOR    = 4,  //!&lt; If set, the image is read in any possible color format.Mat img = imread(&quot;D:/learn/dota.jpg&quot;);</code></pre><ul><li>显示函数</li></ul><pre><code class="lang-cpp">imshow(&quot;dota&quot;, img);</code></pre><ul><li>输出函数</li></ul><pre><code class="lang-cpp">bool imwrite( const String&amp; filename, InputArray img,              const std::vector&lt;int&gt;&amp; params = std::vector&lt;int&gt;());imwrite(&quot;D:/new_dota.jpg&quot;, img);</code></pre><ul><li><p>实例</p><pre><code class="lang-cpp">#include &lt;iostream&gt;  #include &lt;opencv2/core/core.hpp&gt;  #include &lt;opencv2/highgui/highgui.hpp&gt;  using namespace cv;int main() {  //图像显示  Mat logo = imread(&quot;D:/learn/logo.jpg&quot;);  imshow(&quot;logo&quot;, logo);  //图像混合  Mat img = imread(&quot;D:/learn/dota.jpg&quot;);  imshow(&quot;img&quot;, img);  Mat imgROI;  imgROI = img(Rect(800, 350, logo.cols, logo.rows));  //logo加载到背景图  addWeighted(imgROI,0.5,logo,0.3,0,imgROI);  imshow(&quot;dota_logo&quot;, img);  //保存混合的图像  imwrite(&quot;D:/learn/dota_logo.jpg&quot;,img);  waitKey(0);}</code></pre><p><img src="/images/opencv3/18.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/opencv3/19.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/opencv3/20.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/opencv3/21.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>读取视频文件 调用摄像头 写入视频文件</p><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;opencv2/opencv.hpp&gt;using namespace std;using namespace cv;int main() {  namedWindow(&quot;cap&quot;, cv::WINDOW_AUTOSIZE);  VideoCapture cap;  Mat frame;  cap.open(0);  //视频流写出  Size size = Size(cap.get(CV_CAP_PROP_FRAME_WIDTH), cap.get(CV_CAP_PROP_FRAME_HEIGHT));  VideoWriter writer;  writer.open(&quot;test.avi&quot;, -1, 10, size);  //  for (;;){      cap &gt;&gt; frame;      imshow(&quot;out&quot;, frame);      writer &lt;&lt; frame;      if (waitKey(33) &gt;= 0) break;  }  cap.release();  //waitKey(0);  return 0;}</code></pre></li></ul><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>opencv3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>opencv3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>opencv3(1-1) vs2015配置opencv3开发环境</title>
    <link href="/2019/07/10/opencv3(1-1)%20vs2015%E9%85%8D%E7%BD%AEopencv3%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <url>/2019/07/10/opencv3(1-1)%20vs2015%E9%85%8D%E7%BD%AEopencv3%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h2 id="vs2015配置opencv3开发环境"><a href="#vs2015配置opencv3开发环境" class="headerlink" title="vs2015配置opencv3开发环境"></a>vs2015配置opencv3开发环境</h2><p>官网地址:<a href="https://opencv.org/" target="_blank" rel="noopener">https://opencv.org/</a></p><ul><li><p>下载<br><img src="/images/opencv3/1.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"><br><img src="/images/opencv3/2.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"></p></li><li><p>下载完成后双击安装,并配置环境变量<br><img src="/images/opencv3/3.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"></p></li><li>打开VS2015,新建项目<br><img src="/images/opencv3/4.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"><br><img src="/images/opencv3/5.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"><br><strong>配置opencv</strong><br><img src="/images/opencv3/6.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"></li><li>添加包含目录<br><img src="/images/opencv3/7.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"><br><img src="/images/opencv3/8.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"></li><li>添加库目录<br><img src="/images/opencv3/9.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"><br><img src="/images/opencv3/10.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"></li><li>添加附加依赖项 将vc14下的lib都添加进来,以d结尾的lib文件为调试使用<br><img src="/images/opencv3/11.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"><br><img src="/images/opencv3/12.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"></li><li>测试<br><img src="/images/opencv3/13.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"><br><img src="/images/opencv3/14.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;using namespace cv;int main() {  Mat img = imread(&quot;D:/learn/dota.jpg&quot;);  imshow(&quot;dota&quot;, img);   waitKey(6000);}</code></pre></li><li>运行<br><img src="/images/opencv3/15.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"></li><li>结果<br><img src="/images/opencv3/16.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"></li></ul><hr><p><strong>opencv模块简介</strong><br><img src="/images/opencv3/17.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"></p><ul><li>calib3d<br>相机校准和3维重建相关的内容,包括多视角几何算法、单个立体摄像头标定、物体姿态估计、立体相似性算法等</li><li>core<br>核心功能模块,包含opencv基本数据结构、动态数据结构、绘图函数、数组操作、辅助函数/系统函数/宏、OpenGL互操作</li><li>imgproc<br>图像处理模块,包含线性和非线性的图像滤波、图像几何变换、直方图、结构分和形状描述、运动分析、运动分析和对象跟踪、特征检测、目标检测</li><li>features2d<br>2D功能模块,包含特征检测和描述、特征检测器通用接口、描述符提取器、描述符匹配器、通用描述符匹配器接口、关键点绘制函数和匹配功能绘制函数</li><li>flann<br>高维近似近邻快速搜索算法库,包含快速近似最近邻搜索、聚类</li><li>gpu<br>运用GPU加速计算机视觉模块</li><li>highgui<br>高层GUI图形用户界面,包含媒体输入输出、视频捕捉、图像和视频编码解码、图形交互界面接口</li><li>legacy<br>废弃的代码库,用于向下兼容</li><li>ml<br>机器学习模块，包含统计模型、贝叶斯分类器、支持向量机、决策树、提升、随机树、神经网络</li><li>objdetect<br>目标检测模块,包含级联分类和LatentSVM</li><li>photo<br>图像修复和去噪</li><li>stitching<br>图像拼接模块,包含拼接流水线、特点寻找和匹配图像、估计旋转、自动校准、图片歪斜、接缝估测、曝光补偿、图片混合</li><li>superres<br>超分辨率技术模块</li><li>video<br>视频分析组件,包含运动估计、背景分离、对象跟踪</li><li>videostab<br>视频稳定组件</li></ul><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>opencv3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>opencv3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++教程(4) C++标准库</title>
    <link href="/2019/07/09/C++%E6%95%99%E7%A8%8B(4)%20C++%E6%A0%87%E5%87%86%E5%BA%93/"/>
    <url>/2019/07/09/C++%E6%95%99%E7%A8%8B(4)%20C++%E6%A0%87%E5%87%86%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h3 id="Pair"><a href="#Pair" class="headerlink" title="Pair"></a>Pair</h3><p>Class Pair将两个value视为一个单元</p><pre><code class="lang-cpp">namespace std{    template&lt;typename T,typename U&gt;    struct pair{        T first;        U second;        ...    };}</code></pre><p><img src="/images/pair.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h3><p>tuple可拥有任意类型任意数量的元素</p><pre><code class="lang-cpp">std::tuple&lt;int, double, char,std::string&gt; tuple(1, 2.3, &#39;y&#39;, &quot;hello wolrd&quot;);</code></pre><p><img src="/images/tuple.jpg" srcset="/img/loading.gif" alt=""><br>tuple不允许迭代,运行时传入索引值将报错</p><pre><code class="lang-cpp">std::get&lt;i&gt;(tuple);//错误</code></pre><h3 id="Smart-Pointer-智能指针"><a href="#Smart-Pointer-智能指针" class="headerlink" title="Smart Pointer(智能指针)"></a>Smart Pointer(智能指针)</h3><p>Smart Pointer能够得知本身是否为指向某个对象的最后一个指针,当其为指向某个对象的最后一个指针且被删除时即会销毁所指对象</p><h4 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h4><p>共享式拥有 多个smart pointer指向同一对象,对象和资源在最后一个smart pointer销毁时被释放</p><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;memory&gt;using namespace std;int main() {    shared_ptr&lt;string&gt; x(new string(&quot;kyleson&quot;));    shared_ptr&lt;string&gt; y(new string(&quot;monica&quot;));    (*x)[0] = &#39;K&#39;;    y-&gt;replace(0, 1, &quot;J&quot;);    vector&lt;shared_ptr&lt;string&gt;&gt; person;    person.push_back(x);    person.push_back(y);    person.push_back(x);    person.push_back(y);    for (auto ptr : person)        cout &lt;&lt; *ptr &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;    *x = &quot;Nonica&quot;;    for (auto ptr : person)        cout &lt;&lt; *ptr &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;    cout &lt;&lt; &quot;use_count:&quot; &lt;&lt; person[0].use_count() &lt;&lt; endl;//所指对象当前拥有者(指针)数量    getchar();    return 0;}Kyleson Jonica Kyleson JonicaNonica Jonica Nonica Jonicause_count:3</code></pre><p>当string的最后一个拥有者shared_ptr被销毁,所指对象随即调用delete<br>对象的delete不一定发生在 程序终点 , 将nullptr赋值给x或者调整vector大小使其只含有y,则都会调用delete</p><h4 id="自定义delete"><a href="#自定义delete" class="headerlink" title="自定义delete"></a>自定义delete</h4><pre><code class="lang-cpp">    shared_ptr&lt;string&gt; x(new string(&quot;kyleson&quot;),                         [](string *p){                            cout &lt;&lt; &quot;delete&quot; &lt;&lt; *p;                            delete p;                        });</code></pre><p>当最后一个拥有者被销毁时,将调用该lambda函数</p><p>shared point的默认调用delete，而非delete [],当智能指针指向数组时需自定义delete</p><pre><code class="lang-cpp">shared_ptr&lt;int&gt; p(new int[10], [](int *p) {delete[] p; });shared_ptr&lt;int&gt; p(new int[10],std::default_delete&lt;int[]&gt;());//利用unique_ptr提供的辅助函数</code></pre><h4 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h4><p>weak_ptr共享但不拥有某对象,一旦最末拥有该对象的shared_ptr失去拥有权,任何weak_ptr都会自动成空</p><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;memory&gt;using namespace std;class Person {public:    string name;    shared_ptr&lt;Person&gt; mother;    shared_ptr&lt;Person&gt; father;    vector&lt;shared_ptr&lt;Person&gt;&gt; kids;    Person(const string &amp;name,            shared_ptr&lt;Person&gt; m = nullptr,            shared_ptr&lt;Person&gt; f = nullptr) :           name(name), mother(m), father(f) {};    ~Person(){        std::cout &lt;&lt; &quot;delete &quot; &lt;&lt; name &lt;&lt; endl;    }};shared_ptr&lt;Person&gt; initFamily(const string &amp;name) {    shared_ptr&lt;Person&gt; mom(new Person(name + &quot;&#39;s mom&quot;));    shared_ptr&lt;Person&gt; dad(new Person(name + &quot;&#39;s dad&quot;));    shared_ptr&lt;Person&gt; kid(new Person(name, mom, dad));    mom-&gt;kids.push_back(kid);    dad-&gt;kids.push_back(kid);    return kid;}int main() {    shared_ptr&lt;Person&gt; p = initFamily(&quot;kyleson&quot;);    cout &lt;&lt; &quot;kyleson&#39;s family exits&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;- kyleson is shared &quot; &lt;&lt; p.use_count() &lt;&lt; &quot; times&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;- name of 1st kid of kyleson&#39;s mom:&quot;        &lt;&lt; p-&gt;mother-&gt;kids[0]-&gt;name &lt;&lt; endl;    p = initFamily(&quot;Ninoca&quot;);    cout &lt;&lt; &quot;- Ninoca is shared &quot; &lt;&lt; p.use_count() &lt;&lt; &quot; times&quot; &lt;&lt; endl;    getchar();    return 0;}kyleson&#39;s family exits- kyleson is shared 3 times- name of 1st kid of kyleson&#39;s mom:kyleson- Ninoca is shared 3 times</code></pre><p>程序结束时,并未打印”delete kyleon”或“delete Ninoca”，即未执行析构函数,Person内部存在循环指向,其对象在程序结束时仍至少被一个shared_ptr指向.</p><pre><code class="lang-cpp">vector&lt;weak_ptr&lt;Person&gt;&gt; kids;cout &lt;&lt; &quot;- name of 1st kid of kyleson&#39;s mom:&quot;        &lt;&lt; p-&gt;mother-&gt;kids[0].lock()-&gt;name &lt;&lt; endl;kyleson&#39;s family exits- kyleson is shared 1 times- name of 1st kid of kyleson&#39;s mom:kylesondelete kylesondelete kyleson&#39;s daddelete kyleson&#39;s mom- Ninoca is shared 1 times...</code></pre><p>使用weak_ptr将会解决循环指向问题,当改变p的指向后调用了析构函数,且当程序结束时”Ninoca”的析构函数也将被调用</p><pre><code class="lang-cpp">int *x = new int;shared_ptr&lt;int&gt; sp1(x);shared_ptr&lt;int&gt; sp2(x);//错误shared_ptr&lt;int&gt; sp3 = sp1;//正确</code></pre><p>问题出在sp1和sp2意味着”两个指向团队”,都会在丢失x的拥有权时释放资源，因此相应的资源会被释放两次而导致错误</p><pre><code class="lang-cpp">class Person {public:    ...    void setParentAndTheirKids(shared_ptr&lt;Person&gt; m = nullptr, shared_ptr&lt;Person&gt; f = nullptr) {        mother = m;        father = f;        if (m != nullptr)            m-&gt;kids.push_back(shared_ptr&lt;Person&gt;(this));//错误 引入了新的指向团队        if (f != nullptr)            f-&gt;kids.push_back(shared_ptr&lt;Person&gt;(this));//错误 引入了新的指向团队    }};</code></pre><p>根据this建立的shared_ptr同样建立了新的”指向团队”</p><pre><code class="lang-cpp">class Person :std::enable_shared_from_this&lt;Person&gt;{public:    ...    void setParentAndTheirKids(shared_ptr&lt;Person&gt; m = nullptr, shared_ptr&lt;Person&gt; f = nullptr) {        mother = m;        father = f;        if (m != nullptr)            m-&gt;kids.push_back(shared_from_this());        if (f != nullptr)            f-&gt;kids.push_back(shared_from_this());    }};</code></pre><h4 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h4><p>独占式拥有 同一时间只有一个smart pointer指向该对象</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++教程(3) 模板和泛型编程</title>
    <link href="/2019/07/06/C++%E6%95%99%E7%A8%8B(3)%20%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    <url>/2019/07/06/C++%E6%95%99%E7%A8%8B(3)%20%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>通过 template <typename T>定义函数模板,T的类型由编译时根据模板函数的使用情况而定 即根据传入的实参推断T的类型.由此模板函数即可处理任何数据类型,而不用为每种数据类型编写重复的函数代码</p><pre><code class="lang-cpp">#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;int compare(const T &amp;a, const T &amp;b) {    if(a &lt; b) return -1;    if(a &gt; b) return 1;    return 0;}int main() {    int a = 1, b = 5;    double c = 2, d = -1;    string e = &quot;A&quot;, f = &quot;A&quot;;    std::cout &lt;&lt; compare(a, b) &lt;&lt; std::endl;    std::cout &lt;&lt; compare(c, d) &lt;&lt; std::endl;    std::cout &lt;&lt; compare(e, f) &lt;&lt; std::endl;    getchar();    return 0;}结果: -1 1 0</code></pre><p>模板函数返回值</p><pre><code class="lang-cpp">template &lt;typename T&gt;T compare(const T &amp;a, const T &amp;b) {    T temp = b;    ....    return temp;}</code></pre><p>多个模板函数参数</p><pre><code class="lang-cpp">template &lt;typename T,typename U&gt;int compare(const T &amp;a, const U &amp;b) {    ....}</code></pre><p>内联模板函数</p><pre><code class="lang-cpp">template &lt;typename T&gt;inline int min(const T &amp;a, const T &amp;b);</code></pre><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;string&gt;#include &lt;stdexcept&gt;using namespace std;template &lt;class T&gt;class Stack {    private:        vector&lt;T&gt; elems;    public:        void push(T const&amp;); //入栈        void pop();          //出栈        T top() const;       //栈顶元素        bool empty() const {            return elems.empty();        }};template &lt;class T&gt;void Stack&lt;T&gt;::push(T const&amp; elem){    elems.push_back(elem);}template &lt;class T&gt;void Stack&lt;T&gt;::pop(){    if (elems.empty()) {        throw out_of_range(&quot;Stack&lt;&gt;::pop(): empty stack&quot;);    }    elems.pop_back();}template &lt;class T&gt;T Stack&lt;T&gt;::top() const{    if (elems.empty()) {        throw out_of_range(&quot;Stack&lt;&gt;::top(): empty stack&quot;);    }    return elems.back();}int main(){    try {        Stack&lt;int&gt;    intStack;  // int 类型的栈         Stack&lt;string&gt; stringStack;    // string 类型的栈         // 操作 int 类型的栈         intStack.push(7);        cout &lt;&lt; intStack.top() &lt;&lt; endl;        // 操作 string 类型的栈         stringStack.push(&quot;hello&quot;);        cout &lt;&lt; stringStack.top() &lt;&lt; std::endl;        stringStack.pop();        //stringStack.pop();    }    catch (exception const&amp; ex) {        cerr &lt;&lt; &quot;Exception: &quot; &lt;&lt; ex.what() &lt;&lt; endl;        getchar();        return -1;    }    getchar();    return 0;}</code></pre><p>Note:T top() <strong>cons</strong>t; 表示函数Top()为只读操作,不能对类成员进行修改<br>默认模板参数</p><pre><code class="lang-cpp">template &lt;class T=int&gt; class Stack {...}</code></pre><h3 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h3><p>普通类里定义模板函数或模板内部类</p><pre><code class="lang-cpp">class Car {    template &lt;typename T&gt; void run(T &amp;);};//定义template&lt;typename T&gt; void Car::run(T &amp; a,){...}</code></pre><p>类模板里定义独立的成员模板</p><pre><code class="lang-cpp">template &lt;typename T&gt; class Car {    template &lt;typename U&gt; void run (U a, U b);};//定义template&lt;typename T&gt;template&lt;typename U&gt;void Car&lt;T&gt;::run(U a, U b){...}</code></pre><h3 id="函数模板显式实参"><a href="#函数模板显式实参" class="headerlink" title="函数模板显式实参"></a>函数模板显式实参</h3><p>显示模板实参在调用时由用户指出</p><pre><code class="lang-cpp">template &lt;typename T1,typename T2,typename T3&gt;T3 sum(T1,T2)；//T3为显示模板实参double a = 2.0,b = 3.0;auto val = sum&lt;int&gt;(a,b);//指定显示模板实参T3为int，T2,T3由a，b推断得出</code></pre><h3 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h3><pre><code class="lang-cpp">template &lt;typename T,typename ... Args&gt;void foo(T &amp;t, const Args&amp; ... rest);foo(1,&#39;A&#39;);foo(1,2,&#39;C&#39;);</code></pre>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++教程(2) 面向对象编程</title>
    <link href="/2019/07/05/C++%E6%95%99%E7%A8%8B(2)%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <url>/2019/07/05/C++%E6%95%99%E7%A8%8B(2)%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="定义和声明"><a href="#定义和声明" class="headerlink" title="定义和声明"></a>定义和声明</h3><pre><code class="lang-cpp">#include&lt;iostream&gt;int add(int, int); //声明函数int main(){    int a = 6, b = 9;    int c = add(a, b);    std::cout &lt;&lt; c &lt;&lt; std::endl;    getchar();    return 0;}//定义函数int add(int a , int b){    int c = a + b;    return c;}</code></pre><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><pre><code class="lang-cpp">int func(int val) //副本传递//副本传递时,修改val不影响原来的val值int func(int &amp;val) //引用传递int func(int *val) //指针传递//指针和引用传递时,修改val会影响原来的val值int func(int a, int b, int args ...);//可变参数</code></pre><pre><code class="lang-cpp">#实例 数字交换#include&lt;iostream&gt;void func1(int, int);void func2(int &amp;, int &amp;);void func3(int *, int *);int main(){    int a = 6, b = 9;    func1(a, b);    std::cout &lt;&lt; &quot;func1 ----&gt; a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot;&lt;&lt; b &lt;&lt; std::endl; //a,b未交换    func2(a, b);    std::cout &lt;&lt; &quot;func2 ----&gt; a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; std::endl; //a,b被交换    func3(&amp;a, &amp;b);    std::cout &lt;&lt; &quot;func3 ----&gt; a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; std::endl;//a,b被交换    getchar();    return 0;}void func1(int a , int b){    int temp = 0;    temp = a;    a = b;    b = temp;}void func2(int &amp;a, int &amp;b) {    int temp = 0;    temp = a;    a = b;    b = temp;}void func3(int *a, int *b) {    int *temp = 0;    temp = a;    a = b;    b = temp;}结果:func1 ----&gt; a:6 b:9func2 ----&gt; a:9 b:6func3 ----&gt; a:9 b:6</code></pre><h3 id="函数地址作为函数参数"><a href="#函数地址作为函数参数" class="headerlink" title="函数地址作为函数参数"></a>函数地址作为函数参数</h3><pre><code class="lang-cpp">#include&lt;iostream&gt;void swap(int &amp;, int &amp;);void func1(int &amp;, int &amp;, void(*pf)(int &amp;, int &amp;));int main(){    int a = 6, b = 9;    void(*pf)(int &amp;, int &amp;);    pf = swap;    (*pf)(a,b);    std::cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; std::endl; //a,b被交换    int c = 17, d = 29;    func1(c,d,pf);    std::cout &lt;&lt; &quot;c:&quot; &lt;&lt; c &lt;&lt; &quot; d:&quot; &lt;&lt; d &lt;&lt; std::endl; // c,d被交换    getchar();    return 0;}void func1(int &amp;c,int &amp;d,void (*pf)(int &amp;,int &amp;)) {    (*pf)(c,d);}void swap(int &amp;a, int &amp;b) {    int temp = 0;    temp = a;    a = b;    b = temp;}结果:a:9 b:6c:29 d:17</code></pre><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>常规函数的调用过程<br>程序执行到”函数指令”代码处时,立即存储”函数指令”代码的内存地址,并将函数参数复制到堆栈,然后跳到函数起点的内存单元((函数的内存地址,非”函数指令”代码地址)执行函数代码,函数执行结束后跳回保存的”函数指令”内存地址处,即跳回到程序执行函数指令的那一行,然后继续执行余下的指令.<br>内联函数调用过程<br>程序执行到”函数指令”代码处时,编译器将调用的函数代码替换掉该函数指令,无需再跳转到函数的位置去执行.速度比常规函数调用快,但内存开销大,假设程序有10个地方条用了同一个内联函数,则程序中将包含该内联函数代码的10个副本.</p><p><img src="/images/func.png" srcset="/img/loading.gif" alt=""></p><pre><code class="lang-cpp">#include &lt;iostream&gt;using namespace std;inline int Max(int x, int y){     return (x &gt; y) ? x : y;}int main(){     std::cout &lt;&lt; &quot;Max (20,10):&quot; &lt;&lt; Max(20, 10) &lt;&lt; std::endl;     std::cout &lt;&lt; &quot;Max (0,200): &quot; &lt;&lt; Max(0, 200) &lt;&lt; std::endl;     std::cout &lt;&lt; &quot;Max(100,1010): &quot; &lt;&lt; Max(100, 1010) &lt;&lt; std::endl;     return 0;}结果:Max (20,10): 20Max (0,200): 200Max (100,1010): 1010</code></pre><h3 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h3><p>带默认参数的函数 必须从右至左添加默认值</p><pre><code class="lang-cpp">void func(int a,int b,double c = 3.14); //合法void func(int a,int b = 2,double c); //非法#调用时具有默认参数的参数可选func(1,2);func(1,2,3);</code></pre><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h3><p>person.h 声明类person的头文件<br>若在类中声明函数暨定义,则函数当作内联函数处理</p><pre><code class="lang-cpp">#include&lt;string&gt;class person {public:    person();    person(std::string name);    std::string print_info(std::string name,int year);    void print_name();    void print();    int add(int a,int b){return a + b}//当作内联函数处理private:    std::string name;};</code></pre><p>person.cpp 定义类person中的函数和变量</p><pre><code class="lang-cpp">#include &quot;person.h&quot;#include&lt;iostream&gt;#include&lt;string&gt;person::person(){};person::person(std::string name){    person::name = name;}std::string person::print_info(std::string name, int year){    std::cout &lt;&lt; &quot;your name is &quot; &lt;&lt; name &lt;&lt; &quot; and your age is &quot; &lt;&lt; year &lt;&lt; std::endl;    return &quot;hi &quot; + name;}void person::print_name(){    std::cout &lt;&lt; person::name &lt;&lt; std::endl;}void person::print(){    std::cout &lt;&lt; &quot;hello person &quot; &lt;&lt; std::endl;}</code></pre><p>main.cpp 使用person类</p><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;string&gt;#include &quot;person.h&quot;int main(){    person p1;    p1.print();    person p2(&quot;kyleson&quot;);    p2.print_name();    std::string info = p2.print_info(&quot;kyleson&quot;,19);    std::cout &lt;&lt; info &lt;&lt; std::endl;    getchar();    return 0;}结果:hello personkylesonyour name is kyleson and your age is 19hi kyleson</code></pre><h3 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h3><p>Date类中的成员函数(+const)表示函数为只读函数,不能对类Date的成员和状态进行修改</p><pre><code class="lang-cpp">class Date {    int d, m, y;public:    int day() const { return d; }    int month() const;};int Date::month() const {    return Date::m;}</code></pre><h3 id="mutable成员"><a href="#mutable成员" class="headerlink" title="mutable成员"></a>mutable成员</h3><p>mutable修饰的成员仍可被常量成员函数修改</p><pre><code class="lang-cpp">class Date {    int d, m, y;public:    int day() const { return d; }    int month() const;private:    int century;    mutable int cache;};int Date::month() const {    Date::century = 0;//错误,month()函数不可修改century的值    Date::cache = 0;    return Date::m;}</code></pre><h3 id="自引用"><a href="#自引用" class="headerlink" title="自引用"></a>自引用</h3><pre><code class="lang-cpp">class Date {    int d = 12, m = 6, y =2018;public:    Date&amp; add_day(){ d++; };    Date&amp; add_month(){ m++; };    Date&amp; add_year() { y++; };private:    int cache;    mutable int modied;};int main(){    Date date;    date.add_year().add_month().add_day();    getchar();    return 0;}</code></pre><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>类的析构函数是类的一种特殊的成员函数,在每次删除所创建的对象时执行<br>析构函数的名称与类的名称完全相同,由波浪号(~)作为其前缀,析构函数不会返回任何值,也不能带有任何参数.析构函数有助于在跳出程序(比如关闭文件、释放内存等）前释放资源.</p><pre><code class="lang-cpp">#include &lt;iostream&gt;using namespace std;class Line{  public:     Line(); // 构造函数声明     ~Line(); // 析构函数声明};Line::Line(void){     cout &lt;&lt; &quot;Object is being created&quot; &lt;&lt; endl;}Line::~Line(void){     cout &lt;&lt; &quot;Object is being deleted&quot; &lt;&lt; endl;     }// 程序的主函数int main(){     Line line;     return 0;}结果:Object is being createdObject is being deleted</code></pre><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>访问类的 private 和 protected 成员</p><pre><code class="lang-cpp">#include &lt;iostream&gt;using namespace std;class Box{     double width;     public:                friend void printWidth(Box box);             void setWidth(double wid);};void Box::setWidth(double wid){     width = wid;}//注意：printWidth() 不是任何类的成员函数void printWidth(Box box){     cout &lt;&lt; &quot;Width of box : &quot; &lt;&lt; box.width &lt;&lt; endl;}int main(){    Box box;    box.setWidth(10.0);    printWidth(box);    return 0;}</code></pre><h3 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h3><pre><code class="lang-cpp">#include &lt;iostream&gt;using namespace std;class Box{public:       Box(double length = 2.0){       length = length; } int compare(Box box){       return this-&gt; length &gt; box. length; }private:      double length; };int main(void){     Box Box1(3.3);      Box Box2(8.5);      if(Box1.compare(Box2)){          cout &lt;&lt; &quot;Box2 is smaller than Box1&quot; &lt;&lt; endl;     }else{         cout &lt;&lt; &quot;Box2 is equal to or larger than Box1&quot; &lt;&lt; endl;}    return 0;}</code></pre><h3 id="指向类的指针"><a href="#指向类的指针" class="headerlink" title="指向类的指针"></a>指向类的指针</h3><pre><code class="lang-cpp">#include &lt;iostream&gt;using namespace std;class Box{public:     Box(double h = 2.0){         height = h; } double Volume(){        return length * breadth *height; }private:       double height; };int main(void){      Box Box1(3.3);       Box *ptrBox;       ptrBox = &amp;Box1;      cout &lt;&lt; &quot;Volume of Box1: &quot; &lt;&lt; ptrBox-&gt;Volume() &lt;&lt; endl;      return 0;}</code></pre><h3 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h3><p>静态成员在类的所有对象中是共享的, 无论创建多少个类的对象，静态成员都只有一个副本</p><pre><code class="lang-cpp">class Box{    public:         static int objectCount;         Box(double h = 2.0){         height = h;         objectCount++;     }     double Volume(){         return length * breadth *height;     }    private:          double height; };int Box::objectCount = 0;int main(void){     Box Box1(3.3);      Box Box2(8.5);      cout &lt;&lt; &quot;Total objects: &quot; &lt;&lt; Box::objectCount &lt;&lt; endl; //objectCount = 2     return 0;}</code></pre><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><pre><code class="lang-cpp">#include &lt;iostream&gt;using namespace std;// 基类class Shape {  public:    void setWidth(int w) {        width = w;    }    void setHeight(int h) {        height = h;    }  protected:    int width;    int height;};// 派生类class Rectangle : public Shape {  public:    int getArea() {        return (width * height);     }};int main(void) {    Rectangle Rect;    Rect.setWidth(5);    Rect.setHeight(7);    cout &lt;&lt; &quot;Total area:&quot; &lt;&lt; Rect.getArea() &lt;&lt; endl;    getchar();    return 0;}</code></pre><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><pre><code class="lang-cpp">// 基类class Shape {...};class PaintCost {...};// 多继承class Rectangle : public Shape, public PaintCost {...};</code></pre><h3 id="虚函数和纯虚函数-virtual-修饰符"><a href="#虚函数和纯虚函数-virtual-修饰符" class="headerlink" title="虚函数和纯虚函数 virtual 修饰符"></a>虚函数和纯虚函数 virtual 修饰符</h3><p>类中被声明为虚函数的函数在基类中实现也可被派生类重写.<br>类中被声明为纯虚函数的函数在基类中只能声明,定义纯虚函数是为定义一个接口,必须由派生类实现,且这个类是抽象类</p><pre><code class="lang-cpp">class Shape {     //虚函数     virtual int area(){       cout &lt;&lt; &quot;Parent class area :&quot; &lt;&lt; endl;       return 0;     }};class Rectangle : public Shape {     //重写的虚函数     int area(){        cout &lt;&lt; &quot;Rectangle class area :&quot; &lt;&lt; endl;        return (width * height);     }};class Shape {     //纯虚函数 由派生类实现     virtual int area() = 0;};</code></pre><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多个派生类根据需要对基类的虚函数进行了不同的实现,在函数调用时会根据派生类的不同进行相应的调用</p><pre><code class="lang-cpp">#include &lt;iostream&gt; using namespace std;class Shape {  public:    virtual void area() {        cout &lt;&lt; &quot;Parent class area :&quot; &lt;&lt; endl;    }};class Rectangle : public Shape {  public:    void area() {        cout &lt;&lt; &quot;Rectangle class area &quot; &lt;&lt; endl;    }};class Triangle : public Shape {  public:    void area() {        cout &lt;&lt; &quot;Triangle class area &quot; &lt;&lt; endl;    }};int main() {    Shape *shape;    Rectangle rec;    Triangle tri;    shape = &amp;rec;    shape-&gt;area();    shape = &amp;tri;    shape-&gt;area();    getchar();    return 0;}结果:Rectangle class area Triangle class area</code></pre><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><pre><code class="lang-cpp">class Date {  public:    int d = 12, m = 6, y = 2018;    Date operator+(const Date &amp;a);    void operator++();};Date Date::operator+(const Date &amp; a){    Date c;    c.d = this-&gt;d + a.d;    c.m = this-&gt;m + a.m;    c.y = this-&gt;y + a.y;    return c;}void Date::operator++(){    this-&gt;y++;    this-&gt;m++;    this-&gt;d++;}int main(){    Date a,b;    Date c = a + b;    std::cout &lt;&lt; c.y &lt;&lt; std::endl;    Date d;    ++d;//++d == d.operator++();    std::cout &lt;&lt; d.y;    getchar();    return 0;}</code></pre><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><pre><code class="lang-cpp">//捕获并处理异常void task_master(){    try{        auto result = do_task();    }catch(some_error){        //todo     }}//抛出异常int do_task(){    if(...)        return result;    else        throw some_error{};}#include &lt;iostream&gt;using namespace std;double division(int a, int b){   if( b == 0 ){      throw &quot;Division by zero condition!&quot;;   }   return (a/b);}int main (){   int x = 50;   int y = 0;   double z = 0;   try {     z = division(x, y);     cout &lt;&lt; z &lt;&lt; endl;   }catch (const char* msg) {     cerr &lt;&lt; msg &lt;&lt; endl;   }   return 0;}</code></pre><p>C++标准异常</p><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;exception&gt;using namespace std;struct MyException : public exception{  const char * what() const throw (){    return &quot;C++ Exception&quot;;  }};int main(){  try{    throw MyException();  }catch(MyException&amp; e){    std::cout &lt;&lt; &quot;MyException caught&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; e.what() &lt;&lt; std::endl;  }catch(std::exception&amp; e){    //其他的错误  }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++教程(1) 基础</title>
    <link href="/2019/07/05/C++%E6%95%99%E7%A8%8B(1)%20%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/07/05/C++%E6%95%99%E7%A8%8B(1)%20%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="C-尝鲜"><a href="#C-尝鲜" class="headerlink" title="C++尝鲜"></a>C++尝鲜</h2><pre><code class="lang-cpp">#include&lt;iostream&gt;using namespace std;int main(){    int num = 0;    cout &lt;&lt; &quot;how old are you ?&quot; &lt;&lt; endl;    cin &gt;&gt; num;    cout &lt;&lt; &quot;you are&quot; &lt;&lt; num &lt;&lt; &quot; years old&quot; &lt;&lt; endl;    return 0;}</code></pre><pre><code class="lang-cpp">#include&lt;iostream&gt; 引入输入输出流----------------------------------------std::cout 标准输出 std::cout &lt;&lt; 变量; std::cout &lt;&lt; 变量 &lt;&lt; string &lt;&lt; endl; 拼接std::cout &lt;&lt; 变量 &lt;&lt; std::endl; 添加换行----------------------------------------std::cin 标准输入std::cin &gt;&gt; 变量</code></pre><hr><h2 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h2><p><strong>声明和定义变量</strong><br>多个文件使用同一个变量,声明和定义必须分离,且变量的定义只能出现在一个文件中,其他使用到该变量的文件则必须对其声明,不能重复定义<br>(头文件 climits定义了基本数据类型的最大最小值符号常量)</p><pre><code class="lang-cpp">声明变量: extern int i;定义变量 :        int j;         int j = 3.14;        extern int i = 0;  初始化后的extern标记的变量不再是声明变量而是定义变量</code></pre><p><strong>声明常量</strong></p><pre><code class="lang-cpp">const int month = 12;</code></pre><p><strong>auto关键字</strong><br>auto根据初始化值的类型推断变量的类型</p><pre><code class="lang-cpp">auto n =100;auto x =1.5 ;auto str = &quot;kyeleson&quot;</code></pre><p><strong>引用 左值引用&amp; 右值引用&amp;&amp;</strong></p><pre><code class="lang-cpp">int val = 1024; int &amp;ref_val = ival;int i = ref_val; i 被初始化为val的值</code></pre><p>ref_val指向val<br>引用即别名,并非引用对象,仅仅为所存在的对象声明一个新名字<br>引用的初始值必须是一个对象,只能被初始化一次,不可修改<br>一个变量可以定义多个引用<br>对引用的操作与对变量的直接操作完全一样，即修改引用ref_val等同于修改val</p><pre><code class="lang-cpp">#include&lt;iostream&gt;int main(){    int val = 10;    int &amp;ref_val = val;    ref_val = 32;    std::cout &lt;&lt; val &lt;&lt; std::endl;    getchar();    return 0;}结果:32</code></pre><p>右值引用—&gt;临时对象,绑定到右值,可修改且不会再被利用<br>利用廉价的移动操作代替昂贵的拷贝操作以此优化性能</p><pre><code class="lang-cpp">string &amp;&amp;str(&quot;hello&quot;);//右值引用//旧式swap函数template &lt;class T&gt;string swap(T &amp;a ,T &amp;b){    T temp = a;//拷贝a值    a = b;//拷贝b值    b = temp;//拷贝temp值}//右值引用版//temp为右值引用 临时对象template &lt;class T&gt;string swap(T &amp;a ,T &amp;b){    //move(x) == static_cast&lt;T&amp;&amp;&gt;(x)    T temp = move(a);//直接读取a右值    a = move(b);//直接读取b右值    b = move(temp);//直接读取temp右值}</code></pre><p><strong>数组</strong></p><pre><code class="lang-cpp">一维数组int array[5];int array[] = { 1,2,3,4 }；double array[4]{ 1.2,3.4,3.2,4.5 }; //C++11char array[] = { &#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;\0&#39; }；char array[2] = { &#39;a&#39;,&#39;b&#39;,&#39;\0&#39; }；//C风格char array[2] ={&#39;A&#39;,&#39;b&#39;}; // C++自动添加&#39;\0&#39;char str[] = &quot;hello&quot;;多维数组int zippo[4][2];int array[][];非法int array[][4];合法声明n维数组时除了最左边的方括号可以留空外,其他都需要填写数值zippo == &amp;zippo[0];zippo[0] == &amp;zippo[0][0] == zippo; [ zippo和zippo[0]起始于同一地址 具有相同的数值 ]*&amp;zippo[0][0] == **zippo == zippo[0][0]zippo[2][1] == *(*(zippo+2)+1)</code></pre><p><strong>字符串</strong><br>(字符串处理:直到遇到’\0’才结束)</p><pre><code class="lang-cpp">char array[] = { &#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;\0&#39; }；//C风格char array[2] = { &#39;a&#39;,&#39;b&#39;,&#39;\0&#39; }；//C风格char array[2] ={&#39;A&#39;,&#39;b&#39;}; // C++自动添加&#39;\0&#39;char str[] = &quot;hello&quot;;// C++自动添加&#39;\0&#39;(char[int] 定义的字符串是字符串常量 不可使用直接修改)## string类#include&lt;string&gt;string str = &quot;hello&quot;;str = &quot;world&quot;; //可修改string str = {&quot;hello world&quot;};string str{&quot;hello world&quot;};string c(5, &#39;A&#39;); //c = &quot;AAAAA&quot;</code></pre><p><strong>结构体</strong></p><pre><code class="lang-cpp">struct person{    char name[20];    int year;    char sex;};person p = {&quot;kyleson&quot;,19,&#39;男&#39;};std::cout &lt;&lt; p1.name &lt;&lt; std::endl;person *pp = &amp;p;//pp-&gt;name == (*pp).nameC++结构体中可以定义函数 C语言则不可struct sample{    int a;    int b;    int add() {return a + b;}};sample s = { 1,2 };std::cout &lt;&lt; s.add() &lt;&lt; std::endl;</code></pre><p>每个struct只能有唯一的定义<br>对于两个struct,即使成员相同其本身仍是不同的类型</p><pre><code class="lang-cpp">struct addr{    int num;};addr x;addr y = x;//错误,类型不匹配int i = x;//错误,类型不匹配</code></pre><p><strong>联合体 union</strong><br>union是特殊的struct,其所有成员都分配在同一地址空间,即在相同的内存位置存储不同的数据类型,union实际占用的空间大小与其最大的成员相同,并且在同一时刻union只保存一个成员的值</p><pre><code class="lang-cpp">union value{   char sex;   int sex_num;}value val;val.sex = &#39;男&#39;;//根据类型需求设置成员及值</code></pre><p><strong>枚举</strong><br>enum Name{…}枚举值隐式转换为整数类型,枚举值名字与枚举本身位于同一作用域</p><pre><code class="lang-cpp">enum color{ red,blue,black,white };color brand = red;std::cout &lt;&lt; brand &lt;&lt; std::endl;brand = 10;// 错误 非枚举类型brand = color(blue);brand = color(4);int c = red;//隐式转换为intenum bit{one = 10,two = 22,three};bit b = three; //three = 23</code></pre><p>enum class Name{…}限定作用域的强类型枚举,枚举值不会隐式转换为其他类型,枚举值名字位于枚举局部作用域</p><pre><code class="lang-cpp">enum class Color{red,green,yellow};Color c = Color::red;//局部作用域Color color = red;//错误int c = Color::red;//错误</code></pre><p>指定枚举初始类型</p><pre><code class="lang-cpp">enum class color:char{red,green,yellow};</code></pre><p><strong>指针</strong><br>指向对象的对象[存储指向对象的地址],在生命周期内可指向不同的对象</p><pre><code class="lang-cpp">int *p; //p指向int类型对象的指针int val = 19;int *ip = &amp;val;ip是指向变量val的指针,存储变量val的地址 此处&amp;:取地址符 非引用std::cout &lt;&lt; ip ---&gt; val的地址值std::cout &lt;&lt; *ip ---&gt; val的值 42</code></pre><p>指针的值(状态):指向一个对象、指向紧邻对象所占空间的下一个位置、空指针、无效指针<br>利用指针访问对象:操作符 *</p><pre><code class="lang-cpp">int num = 12; int * p = &amp;num; std::cout &lt;&lt; *p &lt;&lt;std::endl;打印结果:12</code></pre><p>空指针:不指向任何对象 </p><pre><code class="lang-cpp">int *p = nullptr;int *p =0;</code></pre><p>通过new分配内存</p><pre><code class="lang-cpp">int *p = new int;*p = 10;std::cout &lt;&lt; *p &lt;&lt; std::endl;delete p;</code></pre><p>void* 指针:存放任意对象的地址</p><pre><code class="lang-cpp">double pi = 3.14,*pd = &amp;pi ;void pv = &amp;pi;pv == pd ? --&gt; truenote：不能直接操作void*指针所指向的对象,对象类型未知</code></pre><p>指针的指针:指向指针的指针,存储指针的本身的地址</p><pre><code class="lang-cpp">int val = 1024;int *p = &amp;val; //指向一个int类型的变量int **pp = &amp;p;//指向一个int类型的指针变量</code></pre><p><img src="/images/pointer.jpg" srcset="/img/loading.gif" alt=""><br>指向常量的指针,不允许被修改</p><pre><code class="lang-cpp">const double pi = 3.14;const double *p1 = &amp;pi;double *p2 = &amp;pi;// 错误 p2被定义为普通指针*p1 = 42; //错误 不允许赋值</code></pre><p>const指针:常量指针,指针本身也是常量,必须被初始化</p><pre><code class="lang-cpp">int errNum = 0;int *const curErr = &amp;errNum; //curErr一直指向errNum对象const double pi = 3.14;const double *const pip = &amp;pi ;// pip指向常量对象的常量指针int num = 1;curErr = &amp;num; //错误 指向的对象不允许被改变*curErr = 1; //正确 指向的对象非常量,其值可被修改*pip = 1; //错误 指向的对象为常量,其值不能被修改</code></pre><p>函数指针 指向函数的指针,保存着函数代码起始处的地址</p><pre><code class="lang-cpp">函数：void toUpper(char*);指向函数的指针：void (*pf) (char*);pf = toUpper; 函数指针赋值char mis[6]=&quot;hello&quot;;#把toUpper作用于mis(*pf)(mis);pf(mis)bool (*pf)(const string &amp;,const string &amp;)</code></pre><p><strong> 指针和数组</strong></p><pre><code class="lang-cpp">int array[5] = {1,2,3,4 };array本身是指向array第一个元素的指针std::cout&lt;&lt; *array; ---&gt; 1char array[] = { &#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39; };char str1 = array[0];char str2 = *array;char str4 = array[1];char str3 = *(array +1);std::cout &lt;&lt; str1 &lt;&lt; str2 &lt;&lt; str3 &lt;&lt; str4 &lt;&lt; std::endl;输出:a a b bchar *start = begin(array); //指向array首元素的指针char *end = end(array); //指向array尾元素下一位置的指针 默认的空字符int *pts[10]; //pts:含有10个整型指针的数组int(*ptr)[10]; //ptr:指向(含有10个整型的数组)的指针char *name = &quot;kyleson&quot;;char str[5] = &quot;ABC&quot;;char *p = str;int array[] = { 1,2,3 };int *pa = array;std::cout &lt;&lt; name &lt;&lt; *name &lt;&lt; *(name + 1) &lt;&lt; std::endl;//值: kyleson k ystd::cout &lt;&lt; p &lt;&lt; *p &lt;&lt; std::endl;//值: ABC Astd::cout &lt;&lt; pa &lt;&lt; *pa &lt;&lt; std::endl; //值: 000000F0E032F900 1std::cout &lt;&lt; string ----&gt; (字符串处理:直到遇到&#39;\0&#39;才结束)</code></pre><p><strong>类型别名 typedef</strong></p><pre><code class="lang-cpp">typedef double wages; //wages是double的同义词typedef wages base,*p; //base是wages的同义词,p是double* 的同义词wage hourly,weekly; //等价于double hourly,weekly;typedef char* pstr; //复合类型,指向char的指针const pstr str = 0; //指向char的常量指针,并不是指向常量char的指针const pstr* ps; //指向[指向char类型的常量指针]的指针const char* str ;//指向常量char的指针</code></pre><p><strong>类型指示符 decltype</strong></p><pre><code class="lang-cpp">decltype(fun()) sum = x ; //sum的类型是函数fun()的返回类型</code></pre><p><strong>vector 对象的集合</strong></p><pre><code class="lang-cpp">#include&lt;vector&gt;vector&lt;string&gt; strs;//定义空集合vector&lt;string&gt; vetor = {&quot;a&quot;,&quot;person&quot;,&quot;hi&quot;};// 列表初始化vector&lt;int&gt; v_num(10,9); //创建指定数量的元素 每个元素被赋值为9vector&lt;int&gt; ten_num(10); // 10个元素 每个元素被初始化为0strs.push_back(&quot;hello&quot;);//添加元素</code></pre>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(1)Faster R-CNN implemented by Keras</title>
    <link href="/2019/07/04/(1)Faster%20R-CNN%20%20implemented%20by%20Keras/"/>
    <url>/2019/07/04/(1)Faster%20R-CNN%20%20implemented%20by%20Keras/</url>
    
    <content type="html"><![CDATA[<p><strong>训练数据</strong><br>训练数据集下载地址:<br>1.下载class-descriptions-boxable.csv 即 V4下的Metadata ClassNames (训练数据集的所有类别)<br><a href="https://storage.googleapis.com/openimages/web/download.html" target="_blank" rel="noopener">https://storage.googleapis.com/openimages/web/download.html</a><br>2.下载train-images-boxable.csv和train-annotations-bbox.csv (已标记的图片集)<br><a href="https://www.figure-eight.com/dataset/open-images-annotated-with-bounding-boxes/" target="_blank" rel="noopener">https://www.figure-eight.com/dataset/open-images-annotated-with-bounding-boxes/</a><br>note:原始训练集有600个类别,数据量庞大,只抽取其中两个类别的图片集作为训练数据集,如Car,Person</p><p><img src="\images\object-detection\open-image-files.jpg" srcset="/img/loading.gif" alt=""></p><hr><p><strong>数据集预览</strong></p><pre><code class="lang-python">import numpy as npimport timeimport sysimport osimport randomfrom skimage import ioimport pandas as pdfrom matplotlib import pyplot as pltfrom shutil import copyfileimport cv2import tensorflow as tfbase_path = &#39;D:/data/open-image-v4&#39;#数据集下载的主目录images_boxable_fname = &#39;train-images-boxable.csv&#39;annotations_bbox_fname = &#39;train-annotations-bbox.csv&#39;class_descriptions_fname = &#39;class-descriptions-boxable.csv&#39;</code></pre><p>原始图片预览</p><pre><code class="lang-python">images_boxable = pd.read_csv(os.path.join(base_path, images_boxable_fname))images_boxable.head()</code></pre><p><img src="\images\object-detection\1.jpg" srcset="/img/loading.gif" alt=""></p><p>图片标记数据预览</p><pre><code class="lang-python">annotations_bbox = pd.read_csv(os.path.join(base_path, annotations_bbox_fname))annotations_bbox.head()</code></pre><p><img src="\images\object-detection\2.jpg" srcset="/img/loading.gif" alt=""></p><p>类别预览</p><pre><code class="lang-python">class_descriptions = pd.read_csv(os.path.join(base_path, class_descriptions_fname))class_descriptions.head()</code></pre><p><img src="\images\object-detection\3.jpg" srcset="/img/loading.gif" alt=""></p><p>通过annotations_bbox将目标/类别在原图上标记出来</p><pre><code class="lang-python">image_name = images_boxable[&#39;image_name&#39;][5]image_url = images_boxable[&#39;image_url&#39;][5]print(image_name,image_url)</code></pre><p>e17acd05b631d330.jpg <a href="https://requestor-proxy.figure-eight.com/figure_eight_datasets/open-images/train/e17acd05b631d330.jpg" target="_blank" rel="noopener">https://requestor-proxy.figure-eight.com/figure_eight_datasets/open-images/train/e17acd05b631d330.jpg</a></p><pre><code class="lang-python">img = io.imread(image_url) #读取网络图片height, width, _ = img.shapeprint(img.shape)plt.figure(figsize=(15,10))plt.subplot(1,2,1)plt.title(&#39;Original Image&#39;)plt.imshow(img)img_id = image_name[:16]bboxs = annotations_bbox[annotations_bbox[&#39;ImageID&#39;]==img_id]img_bbox = img.copy()for index, row in bboxs.iterrows():    xmin = row[&#39;XMin&#39;]    xmax = row[&#39;XMax&#39;]    ymin = row[&#39;YMin&#39;]    ymax = row[&#39;YMax&#39;]    xmin = int(xmin*width)    xmax = int(xmax*width)    ymin = int(ymin*height)    ymax = int(ymax*height)    label_name = row[&#39;LabelName&#39;]    class_series = class_descriptions[class_descriptions[&#39;name&#39;]==label_name]    class_name = class_series[&#39;class&#39;].values[0]    cv2.rectangle(img_bbox,(xmin,ymin),(xmax,ymax),(0,255,0),2)    font = cv2.FONT_HERSHEY_SIMPLEX    cv2.putText(img_bbox,class_name,(xmin,ymin-10), font, 1,(0,255,0),2)plt.subplot(1,2,2)plt.title(&#39;Image with Bounding Box&#39;)plt.imshow(img_bbox)plt.show()</code></pre><p><img src="\images\object-detection\4.jpg" srcset="/img/loading.gif" alt=""></p><hr><p><strong>训练集构造(检测car、person)</strong></p><p>抽取数据类别,Car,Person</p><pre><code class="lang-python">car = class_descriptions[class_descriptions[&#39;class&#39;]==&#39;Car&#39;]person = class_descriptions[class_descriptions[&#39;class&#39;]==&#39;Person&#39;]print(car)print(person)</code></pre><p>570  /m/0k4j   Car<br>68  /m/01g317  Person</p><p>抽取car、person原始图片下载地址和对应的标记框数据</p><pre><code class="lang-python">#car、person全部标记框数据car_bbox = annotations_bbox[annotations_bbox[&#39;LabelName&#39;]==car[&#39;name&#39;].values[0]]person_bbox = annotations_bbox[annotations_bbox[&#39;LabelName&#39;]==person[&#39;name&#39;].values[0]]car_ids = car_bbox[&#39;ImageID&#39;]person_ids = person_bbox[&#39;ImageID&#39;]#一张图片包含多个标记框,去掉重复的原始图片idcar_ids = np.unique(car_ids)person_ids = np.unique(person_ids)print(&#39;car_ids:&#39;+str(len(car_ids)),&#39;person_ids:&#39;+str(len(person_ids)))</code></pre><p>car_ids:89465 car_ids:248384</p><p>随机选取1000张car和1000张person图片作为训练集</p><pre><code class="lang-python">#打乱次序copy_car_ids = car_ids.copy()random.seed(1)random.shuffle(car_ids)copy_person_ids = person_ids.copy()random.seed(1)random.shuffle(person_ids)n = 1000sub_car_ids = copy_car_ids[:n]sub_person_ids = copy_person_ids[:n]print(sub_car_ids[0:10],sub_person_ids[0:10])</code></pre><p>[‘17729c78b866181e’ ‘7b77dbbc71105e1c’ ‘c9a719e92a035033’<br> ‘58539243ddf350d1’ ‘b4bd75496b4880d8’ ‘6b54b697b13d6573’<br> ‘1e8eab50c0f6ff3a’ ‘ec6ff911833016f3’ ‘a10c03baa942e135’<br> ‘81c73298cc8d5349’] [‘763f5e853b1895df’ ‘d469ba5b2e558fc7’ ‘5348a30462ad2308’<br> ‘751439461f7a5fd3’ ‘5734bee1abe8c58e’ ‘730c2135df540687’<br> ‘14920852dd7e8c93’ ‘6bce959fa9db8fbc’ ‘254dbd00353a1d22’<br> ‘f7b5eabe2c2713c8’]</p><p>获取原始图片下载地址</p><pre><code class="lang-python">sub_car_urls = [images_boxable[images_boxable[&#39;image_name&#39;]==name+&#39;.jpg&#39;] for name in sub_car_ids]sub_person_urls = [images_boxable[images_boxable[&#39;image_name&#39;]==name+&#39;.jpg&#39;] for name in sub_person_ids]print(sub_car_urls[0].values[0][0])  print(sub_car_urls[0].values[0][1])</code></pre><p>17729c78b866181e.jpg<br><a href="https://requestor-proxy.figure-eight.com/figure_eight_datasets/open-images/train/17729c78b866181e.jpg" target="_blank" rel="noopener">https://requestor-proxy.figure-eight.com/figure_eight_datasets/open-images/train/17729c78b866181e.jpg</a></p><p>保存urls到磁盘供复用 </p><pre><code class="lang-python">sub_car_urls_csv = pd.DataFrame()sub_person_urls_csv = pd.DataFrame()for i in range(1000):    sub_car_urls_csv = sub_car_urls_csv.append(sub_car_urls[i], ignore_index = True)    sub_person_urls_csv = sub_person_urls_csv.append(sub_person_urls[i], ignore_index = True)sub_car_urls_csv.to_csv(os.path.join(&#39;D:/data/open-image-v4&#39;,&#39;sub_car_urls.csv&#39;),index=False)sub_person_urls_csv.to_csv(os.path.join(&#39;D:/data/open-image-v4&#39;,&#39;sub_person_urls.csv&#39;),index=False)</code></pre><p>下载图片到磁盘(D:/data/open-image-v4/下新建train-data和test-data文件夹,再分别在train-data和test-data下新建文件夹car和person)</p><pre><code class="lang-python">sub_car_pd = pd.read_csv(os.path.join(base_path, &#39;sub_car_urls.csv&#39;))sub_person_pd = pd.read_csv(os.path.join(base_path, &#39;sub_person_urls.csv&#39;))print(sub_car_pd[&#39;image_name&#39;][0])print(sub_car_pd[&#39;image_url&#39;][0])#建议开启多线程下载#训练图片for i in range(800):    img_car = io.imread(sub_car_pd[&#39;image_url&#39;][i])    car_saved_path = os.path.join(&#39;D:/data/open-image-v4/train-data/car&#39;,sub_car_pd[&#39;image_name&#39;][i])    io.imsave(car_saved_path, img_car)for j in range(800):    img_person = io.imread(sub_person_pd[&#39;image_url&#39;][j])    person_saved_path = os.path.join(&#39;D:/data/open-image-v4/train-data/person&#39;,sub_person_pd[&#39;image_name&#39;][j])    io.imsave(person_saved_path, img_person)#测试图片for i in range(800,1000):    img_car = io.imread(sub_car_pd[&#39;image_url&#39;][i])    car_saved_path = os.path.join(&#39;D:/data/open-image-v4/test-data/car&#39;,sub_car_pd[&#39;image_name&#39;][i])    io.imsave(car_saved_path, img_car)for j in range(800,1000):    img_person = io.imread(sub_person_pd[&#39;image_url&#39;][j])    person_saved_path = os.path.join(&#39;D:/data/open-image-v4/test-data/person&#39;,sub_person_pd[&#39;image_name&#39;][j])    io.imsave(person_saved_path, img_person)</code></pre><p>0000048549557964.jpg<br><a href="https://requestor-proxy.figure-eight.com/figure_eight_datasets/open-images/train/0000048549557964.jpg" target="_blank" rel="noopener">https://requestor-proxy.figure-eight.com/figure_eight_datasets/open-images/train/0000048549557964.jpg</a></p><p>下载完成后,如图所示</p><p><img src="\images\object-detection\5.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="\images\object-detection\6.jpg" srcset="/img/loading.gif" alt=""></p><p>将train-data/car、train-data/person合并到同一文件夹train-data/all下,train-test同理<br>note:由于一张图片可能同时包含car和person,因此合并时会将重复的图片剔除而只保留一张</p><pre><code class="lang-python">file_names = [&#39;car&#39;,&#39;person&#39;]train_path = &#39;D:/data/open-image-v4/train-data&#39;for i in range(len(file_names)):    train_images = os.listdir(os.path.join(train_path,file_names[i]))    for j in range(len(train_images)):        original_path = os.path.join(os.path.join(train_path, label_names[i]), train_images[j])        new_path = os.path.join(os.path.join(train_path, &#39;all&#39;), train_images[j])        copyfile(original_path, new_path)print(&#39;all_train_images&#39;,len(os.listdir(os.path.join(train_path, &#39;all&#39;))))test_path = &#39;D:/data/open-image-v4/test-data&#39;for i in range(len(file_names)):    test_images = os.listdir(os.path.join(test_path,file_names[i]))    for j in range(len(test_images)):        original_path = os.path.join(os.path.join(test_path, label_names[i]), test_images[j])        new_path = os.path.join(os.path.join(test_path, &#39;all&#39;), test_images[j])        copyfile(original_path, new_path)      print(&#39;all_test_images&#39;,len(os.listdir(os.path.join(test_path, &#39;all&#39;))))</code></pre><p>all_train_images 1558<br>all_test_images 401</p><p>构造包含了标记框的训练集和测试集 train.csv和test.csv</p><pre><code class="lang-python">class_descriptions = pd.read_csv(&quot;D:/data/open-image-v4/class-descriptions-boxable.csv&quot;)car = class_descriptions[class_descriptions[&#39;class&#39;]==&#39;Car&#39;]person = class_descriptions[class_descriptions[&#39;class&#39;]==&#39;Person&#39;]print(car,&#39;\n&#39;+car[&#39;name&#39;].values[0])print(person,&#39;\n&#39;+person[&#39;name&#39;].values[0])</code></pre><p>570  /m/0k4j   Car<br>/m/0k4j<br>68  /m/01g317  Person<br>/m/01g317</p><p>抽取car、person的标记框数据</p><pre><code class="lang-python">annotations_bbox = pd.read_csv(&#39;D:/data/open-image-v4/train-annotations-bbox.csv&#39;)car_bbox = annotations_bbox[annotations_bbox[&#39;LabelName&#39;]==car[&#39;name&#39;].values[0]]person_bbox = annotations_bbox[annotations_bbox[&#39;LabelName&#39;]==person[&#39;name&#39;].values[0]]annotations_bbox = pd.concat([car_bbox,person_bbox])print(annotations_bbox.shape)</code></pre><p>(1282796, 13)</p><pre><code class="lang-python">train_df = pd.DataFrame(columns=[&#39;FileName&#39;, &#39;XMin&#39;, &#39;YMin&#39;, &#39;XMax&#39;, &#39;YMax&#39;, &#39;ClassName&#39;])train_path = &#39;D:/data/open-image-v4/train-data/all&#39;train_images = os.listdir(train_path)for i in range(len(train_images)):    sys.stdout.write(&#39;Parse train_imgs &#39; + str(i+1) + &#39;; Number of boxes: &#39; + str(len(train_df)) + &#39;\r&#39;)    sys.stdout.flush()    img_name = train_images[i]    img_id = img_name[0:16]    tmp_df = annotations_bbox[annotations_bbox[&#39;ImageID&#39;]==img_id]    for index, row in tmp_df.iterrows():        labelName = row[&#39;LabelName&#39;]        if labelName == car[&#39;name&#39;].values[0]:            className = &#39;car&#39;        elif labelName == person[&#39;name&#39;].values[0]:            className = &#39;person&#39;        train_df = train_df.append({&#39;FileName&#39;: img_name,                                             &#39;XMin&#39;: row[&#39;XMin&#39;],                                             &#39;YMin&#39;: row[&#39;YMin&#39;],                                             &#39;XMax&#39;: row[&#39;XMax&#39;],                                             &#39;YMax&#39;: row[&#39;YMax&#39;],                                             &#39;ClassName&#39;:className},ignore_index=True)train_df.to_csv(os.path.join(&#39;D:/data/open-image-v4/train-data&#39;, &#39;train.csv&#39;),index=False)</code></pre><p>Parse train_imgs 1557; Number of boxes: 5722</p><pre><code class="lang-python">test_df = pd.DataFrame(columns=[&#39;FileName&#39;, &#39;XMin&#39;, &#39;YMin&#39;, &#39;XMax&#39;, &#39;YMax&#39;, &#39;ClassName&#39;])test_path = &#39;D:/data/open-image-v4/test-data/all&#39;test_images = os.listdir(test_path)for i in range(len(test_images)):    sys.stdout.write(&#39;Parse train_imgs &#39; + str(i+1) + &#39;; Number of boxes: &#39; + str(len(test_df)) + &#39;\r&#39;)    sys.stdout.flush()    img_name = test_images[i]    img_id = img_name[0:16]    tmp_df = annotations_bbox[annotations_bbox[&#39;ImageID&#39;]==img_id]    for index, row in tmp_df.iterrows():        labelName = row[&#39;LabelName&#39;]        if labelName == car[&#39;name&#39;].values[0]:            className = &#39;car&#39;        elif labelName == person[&#39;name&#39;].values[0]:            className = &#39;person&#39;        test_df = test_df.append({&#39;FileName&#39;: img_name,                                             &#39;XMin&#39;: row[&#39;XMin&#39;],                                             &#39;YMin&#39;: row[&#39;YMin&#39;],                                             &#39;XMax&#39;: row[&#39;XMax&#39;],                                             &#39;YMax&#39;: row[&#39;YMax&#39;],                                             &#39;ClassName&#39;:className},ignore_index=True)test_df.to_csv(os.path.join(&#39;D:/data/open-image-v4/test-data&#39;, &#39;test.csv&#39;),index=False)</code></pre><p>Parse train_imgs 401; Number of boxes: 1413</p><pre><code class="lang-python">train_df.head()</code></pre><p><img src="\images\object-detection\7.jpg" srcset="/img/loading.gif" alt=""></p><pre><code>test_df.head()</code></pre><p><img src="\images\object-detection\8.jpg" srcset="/img/loading.gif" alt=""></p><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>目标检测</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VGG16Net</title>
    <link href="/2019/07/03/VGG16Net/"/>
    <url>/2019/07/03/VGG16Net/</url>
    
    <content type="html"><![CDATA[<p><img src="\images\dp-net\VGG16_Summary_Table.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="\images\dp-net\vgg16-neural-network.jpg" srcset="/img/loading.gif" alt=""></p><pre><code class="lang-python">import tensorflow as tffrom tensorflow import kerasfrom tensorflow.keras import layers#模型model = keras.Sequential()# 1st Layermodel.add(layers.Conv2D(input_shape=(224,224,3),filters=64,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))model.add(layers.Conv2D(filters=64,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))model.add(layers.MaxPool2D(pool_size=(3,3),strides=(2,2),padding=&#39;same&#39;))# 2nd Layermodel.add(layers.Conv2D(filters=128,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))model.add(layers.Conv2D(filters=128,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))model.add(layers.MaxPool2D(pool_size=(3,3),strides=(2,2),padding=&#39;same&#39;))# 3rd Layermodel.add(layers.Conv2D(filters=256,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))model.add(layers.Conv2D(filters=256,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))model.add(layers.Conv2D(filters=256,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))model.add(layers.MaxPool2D(pool_size=(3,3),strides=(2,2),padding=&#39;same&#39;))# 4th Layermodel.add(layers.Conv2D(filters=512,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))model.add(layers.Conv2D(filters=512,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))model.add(layers.Conv2D(filters=512,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))model.add(layers.MaxPool2D(pool_size=(3,3),strides=(2,2),padding=&#39;same&#39;))# 5th Layermodel.add(layers.Conv2D(filters=512,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))model.add(layers.Conv2D(filters=512,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))model.add(layers.Conv2D(filters=512,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))model.add(layers.MaxPool2D(pool_size=(3,3),strides=(2,2),padding=&#39;same&#39;))# Passing it to a Fully Connected layermodel.add(layers.Flatten())# 7th Fully Connected Layermodel.add(layers.Dense(4096,activation=&#39;relu&#39;))model.add(layers.Dropout(0.5))# 7th Fully Connected Layermodel.add(layers.Dense(4096,activation=&#39;relu&#39;))model.add(layers.Dropout(0.5))# Output Layermodel.add(layers.Dense(1000,activation=&#39;softmax&#39;))model.summary()</code></pre><pre><code>_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================conv2d_31 (Conv2D)           (None, 224, 224, 64)      1792      _________________________________________________________________conv2d_32 (Conv2D)           (None, 224, 224, 64)      36928     _________________________________________________________________max_pooling2d_13 (MaxPooling (None, 112, 112, 64)      0         _________________________________________________________________conv2d_33 (Conv2D)           (None, 112, 112, 128)     73856     _________________________________________________________________conv2d_34 (Conv2D)           (None, 112, 112, 128)     147584    _________________________________________________________________max_pooling2d_14 (MaxPooling (None, 56, 56, 128)       0         _________________________________________________________________conv2d_35 (Conv2D)           (None, 56, 56, 256)       295168    _________________________________________________________________conv2d_36 (Conv2D)           (None, 56, 56, 256)       590080    _________________________________________________________________conv2d_37 (Conv2D)           (None, 56, 56, 256)       590080    _________________________________________________________________max_pooling2d_15 (MaxPooling (None, 28, 28, 256)       0         _________________________________________________________________conv2d_38 (Conv2D)           (None, 28, 28, 512)       1180160   _________________________________________________________________conv2d_39 (Conv2D)           (None, 28, 28, 512)       2359808   _________________________________________________________________conv2d_40 (Conv2D)           (None, 28, 28, 512)       2359808   _________________________________________________________________max_pooling2d_16 (MaxPooling (None, 14, 14, 512)       0         _________________________________________________________________conv2d_41 (Conv2D)           (None, 14, 14, 512)       2359808   _________________________________________________________________conv2d_42 (Conv2D)           (None, 14, 14, 512)       2359808   _________________________________________________________________conv2d_43 (Conv2D)           (None, 14, 14, 512)       2359808   _________________________________________________________________max_pooling2d_17 (MaxPooling (None, 7, 7, 512)         0         _________________________________________________________________flatten_3 (Flatten)          (None, 25088)             0         _________________________________________________________________dense_11 (Dense)             (None, 4096)              102764544 _________________________________________________________________dropout_8 (Dropout)          (None, 4096)              0         _________________________________________________________________dense_12 (Dense)             (None, 4096)              16781312  _________________________________________________________________dropout_9 (Dropout)          (None, 4096)              0         _________________________________________________________________dense_13 (Dense)             (None, 1000)              4097000   =================================================================Total params: 138,357,544Trainable params: 138,357,544Non-trainable params: 0_________________________________________________________________</code></pre><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>神经网络模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统(3) 内存管理</title>
    <link href="/2019/06/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(3)%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2019/06/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(3)%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>操作系统对内存的划分和动态分配。</p><ul><li>内存空间的分配与回收</li><li>地址转换：逻辑地址和物理地址的转换</li><li>内存空间扩充：虚拟存储技术</li><li>存储保护：保证各道作业在各自的存储空间运行，互不干扰</li></ul><p><strong>内存连续分配管理</strong></p><ol><li><p>单一连续分配：内存分为系统区和用户区，只能用于单用户、单任务操作系统中</p></li><li><p>固定分区分配：将用户内存空间划分为若干个固定大小(分区相等或不等)的区域</p></li><li><p>动态分区分配：根据进程大小动态建立分区，并使分区大小正好适合进程的需要</p><p>分配策略，根据算法找到满足进程需要的空闲分区</p><ul><li><p>首次适应：空闲分区以地址递增的次序链接</p><p>(缺点：低地址出现较多小的空闲分区，查找都需经过这些分区，增加了查找开销)</p></li><li><p>最佳适应：空闲分区以容量递增的次序链接</p><p>(缺点：产生最多的外部碎片)</p></li><li><p>最坏适应：空闲分区以容量递减的次序链接</p><p>(缺点：可能会导致没有可用的大内存块)</p></li><li><p>邻近适应：分配内存时从上次查找结束的地址位置继续查找</p></li></ul></li></ol><p><img src="\images\system\4.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>内存非连续分配管理</strong></p><p>wait….</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Alexnet</title>
    <link href="/2019/06/28/Alexnet/"/>
    <url>/2019/06/28/Alexnet/</url>
    
    <content type="html"><![CDATA[<p><img src="\images\dp-net\AlexNet_Summary_Table.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="\images\dp-net\AlexNet-1.png" srcset="/img/loading.gif" alt=""></p><pre><code class="lang-py">import tensorflow as tffrom tensorflow import kerasfrom tensorflow.keras import layers#模型model = keras.Sequential()# 1st Convolutional Layermodel.add(layers.Conv2D(input_shape=(227,227,3),filters=96,kernel_size=[11,11],strides=(4,4),padding=&#39;valid&#39;,activation=&#39;relu&#39;))model.add(layers.MaxPool2D(pool_size=(3,3),strides=(2,2),padding=&#39;valid&#39;))# 2nd Convolutional Layermodel.add(layers.Conv2D(filters=256,kernel_size=[5,5],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))model.add(layers.MaxPool2D(pool_size=(3,3),strides=(2,2),padding=&#39;valid&#39;))# 3rd Convolutional Layermodel.add(layers.Conv2D(filters=384,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))# 4th Convolutional Layermodel.add(layers.Conv2D(filters=384,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))# 5th Convolutional Layermodel.add(layers.Conv2D(filters=256,kernel_size=[3,3],strides=(1,1),padding=&#39;same&#39;,activation=&#39;relu&#39;))model.add(layers.MaxPool2D(pool_size=(3,3),strides=(2,2),padding=&#39;valid&#39;))# Passing it to a Fully Connected layermodel.add(layers.Flatten())# 6th Fully Connected Layermodel.add(layers.Dense(4096,activation=&#39;relu&#39;))model.add(layers.Dropout(0.5))# 7th Fully Connected Layermodel.add(layers.Dense(4096,activation=&#39;relu&#39;))model.add(layers.Dropout(0.5))# Output Layermodel.add(layers.Dense(1000,activation=&#39;softmax&#39;))model.summary()</code></pre><pre><code class="lang-cpp">_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================conv2d_25 (Conv2D)           (None, 55, 55, 96)        34944     _________________________________________________________________max_pooling2d_13 (MaxPooling (None, 27, 27, 96)        0         _________________________________________________________________conv2d_26 (Conv2D)           (None, 27, 27, 256)       614656    _________________________________________________________________max_pooling2d_14 (MaxPooling (None, 13, 13, 256)       0         _________________________________________________________________conv2d_27 (Conv2D)           (None, 13, 13, 384)       885120    _________________________________________________________________conv2d_28 (Conv2D)           (None, 13, 13, 384)       1327488   _________________________________________________________________conv2d_29 (Conv2D)           (None, 13, 13, 256)       884992    _________________________________________________________________max_pooling2d_15 (MaxPooling (None, 6, 6, 256)         0         _________________________________________________________________flatten_3 (Flatten)          (None, 9216)              0         _________________________________________________________________dense_12 (Dense)             (None, 4096)              37752832  _________________________________________________________________dropout_9 (Dropout)          (None, 4096)              0         _________________________________________________________________dense_13 (Dense)             (None, 4096)              16781312  _________________________________________________________________dropout_10 (Dropout)         (None, 4096)              0         _________________________________________________________________dense_14 (Dense)             (None, 1000)              4097000   _________________________________________________________________dropout_11 (Dropout)         (None, 1000)              0         _________________________________________________________________dense_15 (Dense)             (None, 1000)              1001000   =================================================================Total params: 63,379,344Trainable params: 63,379,344Non-trainable params: 0_________________________________________________________________</code></pre><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>神经网络模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx-rtmp流媒体服务</title>
    <link href="/2019/06/26/nginx-rtmp%E6%B5%81%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1/"/>
    <url>/2019/06/26/nginx-rtmp%E6%B5%81%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<ol><li><p>安装ffmpeg</p><pre><code class="lang-bash">#安装h264视频编解码库sudo apt-get updatesudo apt-get install libx264-dev#安装ffmpeg#通过源安装&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;sudo add-apt-repository ppa:djcj/hybrid #添加源sudo apt-get updatesudo apt-get install ffmpegsudo ffmpeg -version #验证是否安装成功#源码安装&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;wget http://ffmpeg.org/releases/ffmpeg-3.0.9.tar.bz2sudo tar jxvf ffmpeg-3.0.9.tar.bz2cd ffmpeg-3.0.9/sudo ./configure --enable-shared --enable-pthreads --enable-gpl  --enable-avresample $ --enable-libx264 --enable-libtheora  --disable-yasmsudo make   sudo make install</code></pre></li><li><p>安装nginx</p><pre><code class="lang-bash">#源码安装&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;#安装依赖sudo apt-get install build-essentialsudo apt-get install libtoolsudo apt-get updatesudo apt-get install libpcre3 libpcre3-devsudo apt-get install zlib1g-devsudo apt-get install openssl#安装sudo mkdir nginxcd nginxgit clone https://github.com/arut/nginx-rtmp-module.gitsudo wget http://nginx.org/download/nginx-1.12.0.tar.gzsudo tar -zxvf nginx-1.12.0.tar.gzcd nginx-1.12.0/sudo ./configure --prefix=/usr/local/nginx --with-http_ssl_module --add-module=../nginx-rtmp-modulesudo makesudo make install#启动：sudo /usr/local/nginx/sbin/nginx#orsudo /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</code></pre></li><li><p>配置Nginx流媒体服务器</p><pre><code class="lang-bash">#停止sudo /usr/local/nginx/sbin/nginx -s stop sudo vim /usr/local/nginx/conf/nginx.conf#添加rtmp {    server {            listen 1935;            chunk_size 4096;            application live {                    live on;                    record on;                    }    }}#重新启动sudo /usr/local/nginx/sbin/nginx</code></pre></li><li><p>ffmpeg 推流</p><pre><code class="lang-bash">ffmpeg -re -i /home/test.mp4 -vcodec copy -acodec copy -b:v 800k -b:a 32k -f flv rtmp://localhost/live</code></pre></li><li><p>客户端拉流</p><p>使用vlc打开网络串流,输入流媒体服务器地址:rtmp://服务器IP:1935/live/ ,即可播放</p></li></ol><p><strong>nginx的删除</strong></p><pre><code class="lang-bash">$ sudo service nginx stop$ sudo apt-get --purge remove nginx$ sudo apt-get autoremove$ dpkg --get-selections|grep nginx#结果:nginx-common$ sudo apt-get --purge remove nginx-common</code></pre><p><code>版权</code>声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构(4) 树与二叉树</title>
    <link href="/2019/06/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(4)%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2019/06/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(4)%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>树的定义:树是$N(N\geqslant 0)$个结点的有限集合。特别的，当$N=0$时，称为空树。</p><p>任意非空树满足的条件：</p><ul><li>有且仅有一个特定的称为<strong>根</strong>的结点</li><li>当$N&gt;1$时，其余结点可分为$m$个互不相交的有限集合$T_1,T_2,\dots,T_m$,其中每个集合本身又是一棵树，并且称为根结点的子树</li></ul><p>树是一种递归的数据结构</p><ul><li>根结点无前驱结点，除根结点外的其余所有结点有且仅有一个前驱结点</li><li>树中所有结点可以有零个或多个后继结点</li></ul><p><strong>基本术语</strong></p><p><img src="\images\dataStructure\2.jpg" srcset="/img/loading.gif" alt=""></p><ol><li>结点$K$,结点$A,B,E$为到结点$K$的唯一路径上的结点，$A,B$为$K$的<strong>祖先结点</strong>，$K$为$A,B$的子孙结点；$E$为$K$的<strong>双亲结点</strong>，$K$为$E$的<strong>孩子结点</strong>，有相同双亲的结点为<strong>兄弟结点</strong>，如$K$和$L$互为兄弟节点；</li><li>树中一个子结点的个数称为该结点的度，树中结点的最大度数称为树的度；</li><li>度大于$0$的结点称为分支结点,如$B,C,D$,度为$0$的结点称为叶子结点，如$K,L,M$；</li><li>树的深度为树中结点的最大层数，如图的树形结构深度为4</li><li>两个结点之间的路径为两个结点之间所经过的结点序列，路径长度为路径上经过的边的个数，如$A$到$K$的路径长度为3；</li><li>森林是$m$课互不相交的树的集合；</li></ol><h1 id="二叉树概念"><a href="#二叉树概念" class="headerlink" title="二叉树概念"></a>二叉树概念</h1><p>定义:每个结点至多只有两颗子树的树形结构，即二叉树中不存在度大于2的结点，二叉树有左右之分，次序不可颠倒。</p><p><strong>二叉树的形态</strong>：</p><p><img src="\images\dataStructure\3.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>满二叉树：</strong>一颗高度为$h$，并且含有$2^h-1$个结点的二叉树</p><p>对于编号$i$结点，如果有双亲，其双亲为[$i/2$]，如果孩子结点，左孩子为$2i$,右孩子为$2i+1$</p><p><img src="\images\dataStructure\4.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>完全二叉树</strong>：设深度为$h$，有$n$个结点的二叉树，当且仅当其每一个结点都与深度为$h$的满二叉树中编号为$1\sim n$的结点<strong>一一对应</strong>，称为完全二叉树。</p><p>特点：</p><ol><li>若$i\leqslant[n/2] $,则结点$i$为分支节点，否则为叶子节点；</li><li>如果有度为1的结点，只可能有一个，且该结点只有左孩子无右孩子；</li></ol><p><strong>平衡二叉树</strong>：树上<strong>任一结点</strong>的左子树和右子树的深度差不超过1</p><p><strong>二叉树的性质：</strong></p><ol><li>非空二叉树上叶子结点数等于度为2的结点数加1，即$N_0=N_2+1$</li><li>非空二叉树上第$K$层至多有$2^{k-1}个结点(K\geqslant 1)$</li><li>深度为$h$的二叉树至多有$2^{h}-1$个结点</li><li>对于具有$1 \sim n$编号的完全二叉树，具有如下关系<ul><li>当$i&gt;1$时，结点$i$的双亲结点编号为$[i/2]$,当$i$为偶数时其为双亲结点的左孩子，当$i$为奇数时其为双亲结点的右孩子</li><li>当$2i\leqslant n $时，结点$i$的左孩子编号为$2i$，否则无左孩子</li><li>当$2i+1\leqslant n $时，结点$i$的左孩子编号为$2i +1$，否则无右孩子</li><li>结点$i$所在深度为$[\log _2{i}+1]$</li></ul></li><li>具有$n$个结点的完全二叉树的深度为$[\log _2{(n+1)}]$或$[\log _2{n}]+1$</li></ol><p><strong>二叉树的顺序存储</strong></p><p>将完全二叉树上编号为$i$的结点元素存储在某个数组下标为$i-1$的分量中。</p><p>对于一般的二叉树，使用0表示不存在的空结点，下标从1开始。</p><p><img src="\images\dataStructure\5.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>二叉树的链式存储</strong></p><pre><code class="lang-c++">typedef struct biTreeNode{    ElemType data;    struct biTreeNode *left,*right;//左右孩子指针}biTreeNode,*biTree;</code></pre><h1 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h1><ol><li><p>先序遍历</p><p>访问根结点$\rightarrow$先序遍历左子树$\rightarrow $先序遍历右子树</p><pre><code class="lang-c++">void preOrder(BiTree tree){    if(tree != null){        visit(tree);        preOrder(tree-&gt;left);        preOrder(tree-&gt;right);    }}</code></pre></li><li><p>中序遍历</p><p>中序遍历左子树$\rightarrow$访问根结点$\rightarrow $中序遍历右子树</p><pre><code class="lang-c++">void inOrder(BiTree tree){    if(tree != null){        inOrder(tree-&gt;left);        visit(tree);        inOrder(tree-&gt;right);    }}</code></pre></li><li><p>后序遍历</p><p>后序遍历左子树$\rightarrow$后序遍历右子树$\rightarrow $访问根结点</p><pre><code class="lang-c++">void postOrder(BiTree tree){    if(tree != null){        postOrder(tree-&gt;left);        postOrder(tree-&gt;right);        visit(tree);    }}</code></pre><p><img src="\images\dataStructure\6.jpg" srcset="/img/loading.gif" alt=""></p><ul><li>先序遍历：1 2 4 6 3 5 </li><li>中序遍历：2 6 4 1 3 5</li><li>后序遍历：6 4 2 5 3 1</li></ul></li><li><p>非递归遍历算法</p><pre><code class="lang-c++">//中序遍历非递归算法void inOrder*(BiTree tree){    initStack(stack);//初始化栈    BiTree p = tree;//遍历指针    while(p || !isEmpty(stack)){        if(p){            push(stack,p);            p = p-&gt;left;        }        else{            pop(stack,p);            visit(p);            p = p-&gt;right;        }    }}</code></pre></li><li><p>层次遍历</p><p>按图中箭头的顺序进行遍历，先访问第一层，再访问第二层,$\dots$</p><p><img src="\images\dataStructure\7.jpg" srcset="/img/loading.gif" alt=""></p><pre><code class="lang-c++">void levelOrder(BiTree tree){    initQueue(queue);    biTree p;    enQueue(queue,tree);//根节点入队    while(!isEmpty(queue)){        deQueue(queue,p);//队头元素出队        visit(p);        if(p-&gt;left != null)            enQueue(queue,p-&gt;left);        if(p-&gt;right != null)            enQueue(queue,p-&gt;right);    }}</code></pre></li><li><p>根据遍历序列构造二叉树</p><ul><li>二叉树的先序序列和中序序列可以唯一确定一颗二叉树。先序序列中，第一结点为根节点，在中序序列中，根结点将其分为两个子序列，根据该子序列在先序序列中找到对应的左子序列和右子序列，其先序序列中，左子序列第一个结点为左子树的根节点，右子序列的第一个结点为右子树的根结点，如此递归。</li><li>二叉树的后序序列和中序序列可以唯一确定一颗二叉树。后序序列的最后一个结点为根节点。</li><li>层次遍历序列和中序序列可以唯一确定一颗二叉树。</li></ul><p>求先序序列$ABCDEFGHI$和中序遍历$BCAEDGHFI$所确定的二叉树</p><p><img src="\images\dataStructure\8.jpg" srcset="/img/loading.gif" alt=""></p></li></ol><h1 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h1><p>二叉树线索化时通常规定，若无左子树，令leftChild指向其前驱结点，leftTag = 1；若无右子树，令right-child指向其后继结点,rightTag = 1。</p><p><strong>线索二叉树的存储结构</strong></p><pre><code class="lang-c++">typedef struct threadNode{    ElemType data;    struct threadNode *leftChild,rightChild;    int leftTag,rightTag;}</code></pre><p><strong>线索二叉树的构造</strong></p><pre><code class="lang-c++">//中序遍历-二叉树线索化//指针pre指向中序遍历时上一个刚刚访问过的结点void inThreadNode(threadNode &amp;p,threadNode &amp;pre){    if(p != null){        inThreadNode(p-&gt;leftChild,pre);//递归线索化左子树        if(p-&gt;leftChild == null){ //建立前驱线索            p-&gt;leftChild = pre;            p-&gt;leftTag = 1;        }        if(pre != null &amp;&amp; pre-&gt;rightCihld == null){//建立后继线索            pre-&gt;rightChild = p;            pre-&gt;rightTag = 1;        }        pre = p;        inthreadNode(p-&gt;rightChild,pre);//递归线索化右子树    }}void createInThreadNode(threadNode T){    threadNode pre = null;    if(T != null){        inThreadNode(T,pre);        pre-&gt;rightChild = null;//处理遍历的最后一个结点        pre-&gt;rightTag = 1;    }}</code></pre><p><img src="\images\dataStructure\9.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>线索二叉树的遍历</strong></p><ul><li><p>求中序线索二叉树中中序序列的第一个结点</p><pre><code class="lang-c++">threadNode * firstNode(threadNode *p){    while(p-&gt;leftTag == 0)        p = p-&gt;leftChild;    return p;}</code></pre></li><li><p>求中序线索二叉树中结点p在中序序列下的后继结点</p><pre><code class="lang-c++">threadNode * nextNode(threadNode *p){    if(p-&gt;rightTag == 0)        return firstNode(p-&gt;rightChild);    else return p-&gt;rightChild;}</code></pre></li><li><p>遍历算法</p><pre><code class="lang-c++">void * inThreadNode(threadNode *T){    for(threadNode *p = firstNode(T);p != NULL;p = nextNode(p))        visit(p);}</code></pre></li></ul><h1 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h1><ol><li><p>双亲表示法</p><pre><code class="lang-c++">#define MAX_TREE_SIZE 100typedef struct{    ElemType data;//数据    int parent;//双亲位置域}Node;typedef struct{    Node nodes[MAX_TREE_SIZE];    int n;//结点数}Tree;</code></pre><p><img src="\images\dataStructure\10.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>孩子表示法</p><p>将每个结点的孩子结点都用单链表链接起来形成一个线性结构</p><p><img src="\images\dataStructure\11.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>孩子兄弟表示法</p><p>以二叉链表作为树的存储结构，每个结点包括：结点值、指向结点第一个孩子的指针、指向结点下一个兄弟结点的指针</p><pre><code class="lang-c++">typedef struct Node{    ElemType data;//数据    struct Node *firstChild,*nextSibling;//第一个孩子和兄弟指针}Node,*Node;</code></pre><p><img src="\images\dataStructure\12.jpg" srcset="/img/loading.gif" alt=""></p></li></ol><p><strong>树、森林与二叉树的转换</strong></p><p>树转换为二叉树的规则：每个结点的左指针指向它的第一个孩子结点，右指针指向它在树中的相邻兄弟结点，由于根结点没有兄弟，因此由树转换而来的二叉树没有右子树。</p><p><img src="\images\dataStructure\13.jpg" srcset="/img/loading.gif" alt=""></p><h1 id="树与二叉树的应用"><a href="#树与二叉树的应用" class="headerlink" title="树与二叉树的应用"></a>树与二叉树的应用</h1><ol><li><p>并查集</p></li><li><p>二叉排序树</p><p><strong>定义</strong>：</p><ul><li>若左子树非空，则左子树上所有结点关键值均小于根节点的关键值</li><li>若右子树非空，则右子树上所有结点关键值均大于根节点的关键值</li><li>左右子树本身也为一颗二叉排序树</li></ul><p><img src="\images\dataStructure\14.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>二叉排序树的查找</strong></p><p>从根节点开始，若给定值与根结点关键值相等则查找成功；若根结点大于给定值则在左子树中查找；若根结点小于给定值则在右子树中查找</p><pre><code class="lang-c++">//查找函数返回指向关键值为key的结点指针pbiTreeNode * biTreeNodeSearch(biTree tree,ElemType key){    while(tree != NULL &amp;&amp; key != tree-&gt;data){        if(key &lt; tree-&gt;data)            tree = tree-&gt;leftChild;        else            tree = tree-&gt;rightChild;    }    return tree;}</code></pre><p><strong>二叉排序树的插入</strong></p><p>若原二叉树为空，则直接插入结点；若根结点大于给定值则插入到左子树中；若根结点小于给定值则插入到右子树中</p><pre><code class="lang-c++">![15](F:\jiaopaner\source\images\dataStructure\15.jpg)bool biTreeNodeInsert(biTree tree,ElemType key){    if(tree == null){        tree = (biTree)malloc(sizeof(biTreeNode));        tree-&gt;data = key;        tree-&gt;leftChild=  tree-rightChild = NULL;        return true;    }    else if(key == tree-&gt;data)        return false;    else if(key &lt; tree-&gt;data)        return biTreeNodeInsert(tree-&gt;lefgChild,key);    else if(key &gt; tree-&gt;data)        return biTreeNodeInsert(tree-&gt;rightChild,key);}</code></pre><p><strong>二叉排序树的删除</strong></p><ul><li><p>删除的结点为叶结点，则直接删除，不会破坏二叉树的排序性质</p></li><li><p>若删除结点$z$只有一颗左子树(或右子树)，则让$z$的左子树(或右子树)成为$z$结点的父结点的子树，即代替$z$的位置</p><p><img src="\images\dataStructure\15.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="\images\dataStructure\16.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>若删除结点$z$有左、右子树，则令$z$的右子树中中序第一个子女代替$z$，并转换相应的位置</p><p><img src="\images\dataStructure\17.jpg" srcset="/img/loading.gif" alt=""></p></li></ul></li><li><p>平衡二叉树</p><p>定义：任意结点的左右子树高度差不超过1的二叉排序树</p><p><strong>平衡二叉树的插入</strong></p><p>平衡二叉树插入新结点会破坏平衡性，因此插入新结点后需要做调整，以重新达到平衡性</p><p><img src="\images\dataStructure\18.jpg" srcset="/img/loading.gif" alt=""></p><p>平衡性调整策略</p><ul><li><p>LL平衡旋转(右单旋转)</p><p>在根结点$A$的左孩子(L)结点$B$的左子树(L)结点$BL$上插入了结点,破坏了平衡性的调整策略，$B$结点右上旋转代替$A$成为根结点，$A$结点成为$B$的右子树根结点，且$B$的右子树作为$A$结点的左子树</p><p><img src="\images\dataStructure\19.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>RR平衡旋转(左单旋转)</p><p>在根结点$A$的右孩子(R)结点$C$的右子树(R)结点$CR$上插入了结点,破坏了平衡性的调整策略，$C$结点左上旋转代替$A$成为根结点，$A$结点成为$C$的左子树根结点，且$C$的左子树作为$A$结点的右子树</p><p><img src="\images\dataStructure\20.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>LR平衡旋转(先左后右双旋转)</p><p>在根结点$A$的左孩子(L)结点$B$的右子树(R)结点$BR$上插入了结点,破坏了平衡性的调整策略</p><p><img src="\images\dataStructure\21.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>RL平衡旋转(先右后左双旋转)</p><p>在根结点$A$的右孩子(R)结点$C$的左子树(L)结点$CR$上插入了结点,破坏了平衡性的调整策略</p><p><img src="\images\dataStructure\22.jpg" srcset="/img/loading.gif" alt=""></p></li></ul></li><li><p><strong>哈夫曼树和哈夫曼编码</strong></p><p>树结点赋予权值，从根结点到任意结点的路径长度(经过的边数)与该结点权值的乘积称为该结点的带权路径长度，树中所有<strong>叶结点</strong>的带权路径长度之和称为该树的带权路径长度$WPL$。</p><script type="math/tex; mode=display">WPL=\sum_{i=1}^{n}w_i\times l_i</script><p>其中$w_i$为第$i$个叶结点的权值，$l_i$为根结点到第$i$个叶结点的路径长度</p><p>在含有$n$个带权叶子结点的二叉树中，其中$WPL$最小的二叉树称为哈夫曼树(最优二叉树)</p><p><img src="\images\dataStructure\23.jpg" srcset="/img/loading.gif" alt=""></p><p>$WPL(a)=7\times2+5\times2+2\times2+4\times2=36$</p><p>$WPL(b)=7\times3+5\times3+1\times2+4\times2=46$</p><p>$WPL(c)=7\times1+5\times2+2\times3+4\times3=35$</p><p>$c$树为哈夫曼树</p><p><strong>哈夫曼树的构造</strong></p><ul><li>将$n$个带权结点作为$n$课仅含一个结点的二叉树，构成森林$F$</li><li>构造一个新结点$P$，并从$F$中选取两棵权值最小的树作为新结点的左、右子树，将新结点的权值置为左、右子树权值之和</li><li>从$F$中删除上述选取的两棵树，同时将新结点$P$加入$F$中</li><li>重复2、3步骤，直至$F$中只剩下一棵树</li></ul><p><img src="\images\dataStructure\24.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>哈夫曼编码</strong></p><p>对频率高的字符赋予短编码，对频率低的字符赋予长编码，从而使字符平均编码长度减短</p><p>哈夫曼编码：对每个字符当作一个独立的结点，其权值为字符出现的次数，构造哈夫曼树</p><p><img src="\images\dataStructure\25.jpg" srcset="/img/loading.gif" alt=""></p></li></ol><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构(3) 栈和队列</title>
    <link href="/2019/06/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(3)%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <url>/2019/06/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(3)%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p><strong>栈</strong>：只允许在一端进行插入或删除操作的线性表。</p><p>栈顶：允许插入和删除的一端。栈底：固定的，不允许插入和删除的一端。</p><p>特性：先进后出。</p><h2 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h2><pre><code class="lang-c++">#define MaxSize 50typedef struct{    ElemType data[MaxSize];//存放栈中元素    int top;//栈顶指针 空栈 top=-1} Stack;#初始化void initStack(Stack &amp;s){    s.top = -1;}#判断栈空bool stackEmpty(Stack &amp;s){    if(s.top == -1)        return true;    else        return false;}#进栈bool push(Stack &amp;s,ElemType x){    if(s.top == MaxSize-1)        return false;    s.data[++s.top] = x;    return true;}#出栈bool pop(Stack &amp;s,ElemType &amp;x){    if(s.top == -1)        return false;    x = s.data[s.top--];    return true;}#读取栈顶元素bool getTop(Stack &amp;s,ElemType &amp;x){    if(s.top == -1)        return false;    x = s.data[s.top];    return true;}</code></pre><h2 id="栈的链式存储"><a href="#栈的链式存储" class="headerlink" title="栈的链式存储"></a>栈的链式存储</h2><pre><code class="lang-c++">typedef struct LinkNode{    ElemType data;    struct LinkNode *next;} *LinkStack;</code></pre><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p><strong>队列</strong>：只允许在表的一端进行插入，在表的另一端进行删除。</p><p>队头：允许删除的一端。队尾：允许插入的一端。</p><p>特性：先进先出</p><h2 id="队列的顺序存储结构"><a href="#队列的顺序存储结构" class="headerlink" title="队列的顺序存储结构"></a>队列的顺序存储结构</h2><pre><code class="lang-c++">#define MaxSize 50typedef struct{    ElemType data[MaxSize];//存放队列元素    int front,rear;//队头指针、队尾指针}Queue;</code></pre><p><strong>循环队列</strong></p><pre><code class="lang-c++">#初始化void InitQueue(Queue &amp;queue){    queue.rear = queue.front = 0;}#判断队列空bool isEmpty(Queue queue){    if(queue.rear == queue.front)        return true;    else        return false;}#入队bool enQueue(Queue &amp;queue,ElemType x){    if((queue.rear+1)%MaxSize == queue.front)        return false;//队列满    queue.data[queue.rear] = x;    queue.rear = (queue.rear+1) % MaxSize;    return true;}#出队bool deQueue(Queue &amp;queue,ElemType &amp;x){    if(queue.rear+1 == queue.front)        return false;//队列空    x = queue.data[queue.font];    queue.front = (queue.front+1) % MaxSize;    return true;}</code></pre><h2 id="队列的链式存储结构"><a href="#队列的链式存储结构" class="headerlink" title="队列的链式存储结构"></a>队列的链式存储结构</h2><pre><code class="lang-c++">typedef struct{    ElemType data;    struct LinkNode *next}LinkNode;typedef struct{    LinkNode *front,*rear;}LinkQueue;#初始化void InitQueue(LinkQueue &amp;queue){    queue.front = queue.rear=(LinkNode*)malloc(sizeof(LinkNode));    queue.front.next = null;}#判断队列空bool isEmpty(LinkQueue queue){    if(queue.front == queue.rear)        return true;    else        return false;}#入队void enQueue(LinkQueue &amp;queue,ElemType x){    s = (LinkNode *)malloc(sizeof(LinkNode));    s-&gt;data = x;    s-&gt;next = null;    queue.rear-&gt;next = s;    queue.rear = s;}#出队bool deQueue(LinkQueue &amp;queue,ElemType &amp;x){    if(queue.front == queue.rear)        return false;    p = queue.front-&gt;next;    x = p-&gt;data;    queue.front-&gt;next = p-&gt;next;    if(queue.rear == p)        queue.rear = queue.front;    free(p);    return true;}</code></pre><h1 id="栈和队列的应用"><a href="#栈和队列的应用" class="headerlink" title="栈和队列的应用"></a>栈和队列的应用</h1>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统(2) 进程管理</title>
    <link href="/2019/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(2)%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <url>/2019/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(2)%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h1><p>在多道程序环境下，允许多个程序并发执行，因此失去封闭性并具有间断性和不可再现性的特征，为此引入进程，更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性。</p><p><strong>进程控制块(PCB)</strong>：描述进程的基本情况和运行状态，进而控制和管理进程。</p><p>PCB是进程存在的唯一标志。创建进程实质是创建PCB，撤销进程实质是撤销PCB。</p><p><strong>进程映像</strong>：由程序段、相关数据段、PCB组成。</p><p><strong>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</strong></p><p><strong>特征</strong></p><ul><li>动态性：进程是程序的一次执行，具有生命周期。动态性是进程最基本的特征。</li><li>并发性、独立性、异步性、结构性</li></ul><p><strong>进程的状态与转换</strong></p><p><img src="\images\system\1.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>进程创建过程</strong></p><p>终端用户登录、作业调度、系统提供服务、用户程序的应用等请求都会引起进程的创建。</p><ol><li>为新进程分配唯一的进程标识号，申请空白的PCB；</li><li>为进程分配资源，分配进程的程序、数据和用户栈必要的内存空间；</li><li>初始化PCB，初始化标志信息、处理机状态信息、处理机控制信息、设置进程优先级；</li><li>将新进程插入到就绪队列等待调度；</li></ol><p><strong>进程终止过程</strong></p><p>正常结束、异常结束(存储区越界、保护错、非法指令、特权指令错、I/O故障)、外界干预等都会引起进程的终止。</p><ol><li>根据被终止进程标识符检索PCB，读取该进程的状态；</li><li>若被终止的进程处于执行状态则立即终止，将处理机资源分配给其他进程；</li><li>若有子进程，将其所有的子进程终止；</li><li>释放该进程的所有资源；</li><li>将PCB从所在队列中删除</li></ol><p>进程的创建、撤销以及要求系统设备完成的I/O操作都是利用系统调用而进入内核。</p><p><strong>进程的切换</strong></p><ol><li>保存处理机上下文，包括程序计数器和其他寄存器；</li><li>更新PCB信息；</li><li>进程的PCB移入相应的队列，如就绪、阻塞；</li><li>选择另一个进程，并更新其PCB；</li><li>更新内存管理的数据结构；</li><li>恢复处理机上下文；</li></ol><p><strong>进程的通信</strong></p><ul><li><p>共享存储</p><p>通过对共享空间进行读写操作实现进程间的信息交换</p></li><li><p>消息传递</p><p>进程间的数据交换以格式化的消息为单位</p></li><li><p>管道通信</p><p>消息传递的特殊方式，所谓管道是指连接一个读进程和一个写进程以实现进程之间通信的一个共享文件。</p><p>写进程以字符流的形式将大量的数据写入管道。</p></li></ul><p><strong>线程</strong></p><p>线程是基本的CPU执行单元，线程是进程中的一个实体，是被系统独立调度和分派的基本单位。线程不拥有系统资源，只拥有在运行中必不可少的资源，可与同属同一进程的其他线程共享进程所拥有的全部资源。同一进程中的多个线程可以并发执行。</p><p>在传统操作系统中，拥有资源和独立调度的基本单位都是进程，引入多线程的操作系统中，线程是独立调度的基本单位，进程是拥有资源的基本单位。</p><h1 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h1><p>处理及调度是对处理机进行分配，即从进程就绪队列中按照一定的算法选择进程并为其分配处理机，以实现进程并发执行。</p><p><strong>调度层次</strong></p><ul><li>作业调度：只调入/调出一次；</li><li>中级调度：内存调度，提高内存利用率和系统吞吐量，进程的挂起/就绪；</li><li>进程调度：按照某种算法调度进程执行； </li></ul><p>进程调度和切换程序是操作系统的内核程序。</p><p><strong>进程调度方式</strong></p><ul><li>非剥夺方式/非抢占方式：一旦将CPU分配给某个进程，只有当该进程执行完或转换到等待状态时才会进行进程的切换。实现简单、开销小，适用于大多数批处理系统，但不适用于实时和分时系统。</li><li>剥夺调度方式/抢占方式：若有某个更紧迫的进程需要调度，则立即暂定正在运行的进程，将处理机分配给更为紧迫的进程。剥夺原则：优先权、短进程优先、时间片原则。</li></ul><p><strong>调度的基本原则</strong></p><ol><li><p>CPU利用率</p></li><li><p>系统吞吐量：单位时间内CPU完成的作业数量；</p></li><li><p>周转时间：作业提交到作业完成的时间；</p><p>周转时间 = 作业完成时间 - 作业提交时间</p><p>带权周转时间 = $\frac{作业周转时间}{作业实际运行时间}$</p></li><li><p>等待时间</p></li><li><p>响应时间</p></li></ol><p><strong>调度算法</strong></p><ul><li><p>先来先服务(FCFS)调度算法：每次从就绪队列中选择最先进入该队列的进程进行执行，直到进程完成或因某种原因阻塞才释放处理机；算法简单、效率低，对长作业有利，利于CPU繁忙型作业、不利于I/O繁忙型作业。</p></li><li><p>短作业优先(SJF)调度算法：每次从就绪队列中选择一个估计运行时间最短的进程进行执行。对长作业不利、未考虑作业紧迫度，平均等待时间、平均周转时间最少。</p></li><li><p>优先级调度算法：每次从就绪队列中选择优先级最高的进程进行执行。</p></li><li><p>高响应比优先调度算法：同时考虑每个进程的等待时间和估计的运行时间，在进行进程调度前先计算就绪队列中每个进程的响应比，选择响应比最高的进程进行执行。</p><p>响应比$R_p=\frac{等待时间+要求服务的时间}{要求服务的时间}$</p></li><li><p>时间片轮转调度算法：总是选择就绪队列中第一个进程进行执行(先来先服务)，但仅能运行一个时间片，时间片用完即使进程并未完成运行，也必须释放处理机给下一个就绪进程。被剥夺的进程则重新排队，等待调度。</p></li><li><p>多级反馈队列调度算法：</p><ol><li>设置多个队列，赋予每个队列不同的优先级，第1级队列优先级最高，依次降低;</li><li>赋予每个队列不同的进程执行时间片，第1级队列时间片最短，依次递增；</li><li>新进程首先进入第1级队列末尾排队，按照先来先服务调度算法等待调度，若该进程能在第1级的时间片内完成，则撤离系统，否则转入下一级队列末尾排队，依次类推。</li><li>仅当第1级队列为空时才调度第2级队列的进程执行，依次类推。若处理正在执行第$i$级队列中的进程，当新进程进入优先级较高的$i-1$级别队列时，则新进程抢占处理机，当前第$i$级进程转入第$i$级末尾重新排队。</li></ol></li></ul><h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><p>协调进程之间互相制约的关系。</p><ol><li>临界资源：一次仅允许一个进程使用的资源称为临界资源。对临界资源的访问必须互斥进行。</li><li>同步：需要在某些位置上协调进程之间的<strong>工作次序</strong>而等待、传递信息所产生的制约关系。</li><li><p>互斥：当一个进程使用临界资源时，其他要求进入临界区的进程必须等待。</p><p><strong>准则</strong>：</p></li></ol><ul><li>空闲让进：临界区空闲时，允许一个请求进入临界区的进程立即进入临界区</li><li>忙则等待：当已有进程进入临界区，其他试图进入临界区的进程必须等待<ul><li>有限等待：对访问请求的进程，应保证在有限时间内进入临界区</li></ul></li><li>让权等待：当进程不能进入临界区时，应立即释放处理器，防止进程忙等待</li></ul><p><strong>互斥的基本方法</strong></p><p>1.软件实现方法</p><p><strong>单标志法</strong></p><p>设置公用整型变量turn,用于指示被允许进入临界区的进程编号，进程必须交替进入临界区，否则违背空闲让进</p><pre><code class="lang-c++">//P0进程while(turn!=0); //等待critical section;//临界区turn = 1;remainder section;//P1进程while(turn!=1); //等待critical section;//临界区turn = 0;remainder section;</code></pre><p><strong>双标志法</strong></p><p>设置$flag[k]$,进入临界区前先检查进程$P_k$是否进入临界区,进程之间不需要交替进入，缺点为进程$p_i和p_j$可能同时进入临界区，违背忙等待</p><pre><code class="lang-c++">//Pi进程while(flag[j] == true); //等待flag[i] = true;critical section;//临界区flag[i] = false;remainder section;//Pj进程while(flag[i] == true); //等待flag[j] = true;critical section;//临界区flag[j] = false;remainder section;</code></pre><p>设置$flag[k]$,进入临界区前先设置本身进程标志为true,再检查进程$P_k$是否进入临界区,缺点是由于进程互相“谦让”容易形成饥饿现象，即进程都无法进入临界区</p><pre><code class="lang-c++">//Pi进程flag[i] = true;while(flag[j] == true); //等待critical section;//临界区flag[i] = false;remainder section;//Pj进程flag[j] = true;while(flag[i] == true); //等待critical section;//临界区flag[j] = false;remainder section;</code></pre><p><strong>Peterson 算法</strong></p><p>进入临界区前先设置本身进程标志为true,再设置turn标志，最后检查进程$P_k$是否进入临界区</p><pre><code class="lang-c++">//Pi进程flag[i] = true;turn = j;while(flag[j] == true &amp;&amp; turn == j); //等待critical section;//临界区flag[i] = false;remainder section;//Pj进程flag[j] = true;turn = i;while(flag[i] == true &amp;&amp; turn == i); //等待critical section;//临界区flag[j] = false;remainder section;</code></pre><p>2.硬件实现方法</p><p><strong>中断屏蔽</strong></p><p>CPU只在发生中断时引起进程切换，屏蔽中断能够保证当前运行的进程将临界区的代码顺利执行完毕</p><p><strong>硬件指令</strong></p><p>TestAndSet指令(原子操作)，为每个临界资源设置共享布尔变量lock,true表示资源正被占用</p><pre><code class="lang-c++">bool TestAndSet(bool *lock){    bool old;    old = *lock;    *lock = true;    return old;}//进程while(TestAndSet(&amp;lock)) //等待critical section;//临界区lock = false;remainder section;</code></pre><p><strong>Swap指令</strong></p><pre><code class="lang-c++">Swap(bool *x,bool *y){    bool temp;    temp = *x;    *x = *y;    *y = temp;}//进程key = true;//为每个进程设置局部布尔变量while(key != false) //等待    Swap(*lock,&amp;key)critical section;//临界区lock = false;remainder section;</code></pre><p><strong>信号量</strong></p><p>1.整型信号量：定义为表示资源数目的整型量$S$</p><pre><code class="lang-c++">//申请资源wait(S){    while(S &lt;= 0);    S = S-1;}//释放资源signal(S){    S = S+1;}</code></pre><p>2.记录型信号量：定义为表示资源数目的整型量$value$和进程链表$L$(用于链接等待该资源的进程)</p><pre><code class="lang-c++">typedef struct{    int value;    struct process *L;}semaphore;//申请资源void wait(semaphore S){    S.value--;    if(S.value &lt; 0){        add this process to S.L;        block(S.L);//进程阻塞，放弃处理机    }}//释放资源void signal(semaphore S){    S.value++;    if(S.value &lt;= 0){//仍有进程等待        remove a process P from S.L;        wakeup(P);//唤醒进程    }}</code></pre><p>利用信号量实现进程同步</p><pre><code class="lang-c++">//进程Py中的y语句需要使用进程Px中x语句的运行结果semaphore S = 0；Px(){    ...    x；    singal(S);//通知进程Py,语句x已完成    ...}Py(){    ...    wait(S);//检查语句x是否已完成    y；    ...}</code></pre><p>利用信号量实现进程互斥</p><pre><code class="lang-c++">semaphore S = 1;//初始化信号量 资源数量Px(){    ...    wait(S);//访问资源，加锁    x；//临界区    singal(S);//访问结束，解锁    ...}Py(){    ...    wait(S);//访问资源，加锁    y；//临界区    singal(S);//访问结束，解锁    ...}</code></pre><p>利用信号量实现前驱关系</p><p><img src="\images\system\2.jpg" srcset="/img/loading.gif" alt=""></p><p>$a:S1 \rightarrow S2,b:S1\rightarrow S3;c:S2 \rightarrow S4,d:S2\rightarrow S5;$</p><p>$e:S3 \rightarrow S6,f:S4\rightarrow S6,g:S5 \rightarrow S6$</p><pre><code class="lang-c++">semaphore a=b=c=d=e=f=g=0;//S1(){    ...    singal(a);singal(b);//S1完成}S2(){    ...    wait(a);    ...    singal(c);singal(d);//S2完成}S3(){    ...    wait(b);    ...    singal(e);//S3完成}S4(){    ...    wait(c);    ...    singal(f);//S4完成}S5(){    ...    wait(d);    ...    singal(g);//S5完成}S6(){    wait(e);    wait(f);    wait(g);    ...}</code></pre><p><strong>经典同步问题</strong></p><ol><li><p>生产消费者问题</p><pre><code class="lang-c++">semaphore mutex = 1;//临界区互斥信号量semaphore empty = n;//空闲缓冲区数semaphore full = 0;//满缓冲区数//生产者进程producer(){    while(true){        produce an item in nextp;        wait(empty);//获取空缓冲区单元        wait(mutex);//进入临界区        add nextp ti buffer;//将数据放入缓冲区        singal(mutex);        singal(full);    }}//消费者进程consumer(){    while(true){        wait(full);        wait(mutex);        remove an item from buffer;        singal(mutex);        singal(empty);        consume the item;    }}//empty和full的wait操作必须在mutex前</code></pre></li></ol><ol><li><p>读者-写者问题</p><ul><li>允许多个读者同时对共享文件进行读操作</li><li>只允许一个写者向共享文件写数据</li><li>写者完成写操作之前不允许其他读者进行读操作</li><li>写者执行写操作之前，应让已有读者和写者全部退出</li></ul><pre><code class="lang-c++">//读进程优先int count = 0;//当前读者数量semaphore mutex = 1;//用于更新count时的互斥semaphore rw = 1;//互斥访问共享文件//写者进程writer(){    while(true){        wait(rw);        writing;        signal(rw);    }}//读者进程reader(){    while(true){        wait(mutex);        if(count == 0)//第一个读者读取时            wait(rw);//阻止写进程写操作        count++;        signal(mutex);        reading;        wait(mutex);//读取完毕        count--;        if(count == 0)//当最后一个读进程读取完毕            signal(rw)        signal(mutex);    }}</code></pre><pre><code class="lang-c++">//写进程优先int count = 0;//当前读者数量semaphore mutex = 1;//用于更新count时的互斥semaphore rw = 1;//互斥访问共享文件semaphore w = 1;//用于实现写优先//写者进程writer(){    while(true){        wait(w)        wait(rw);        writing;        signal(rw);        signal(w);    }}//读者进程reader(){    while(true){        wait(w);//无写进程时进入        wait(mutex);        if(count == 0)//第一个读者读取时            wait(rw);//阻止写进程写操作        count++;        signal(mutex);        signal(w);        reading;        wait(mutex);//读取完毕        count--;        if(count == 0)//当最后一个读进程读取完毕            signal(rw)        signal(mutex);    }}</code></pre></li></ol><ol><li><p>哲学家进餐问题</p><pre><code class="lang-c++">semaphore chopstick[5]={1,1,1,1,1};//五根筷子semaphore mutex =  1;//设置取筷子的信号量//i号哲学家进程Pi(){    do{        wait(mutex);        wait(chopstick[i]);//取左边筷子        wait(chopstick[(i+1]%5);//取右边筷子        signal(mutex);        eat;        signal(chopstick[i]);        signal(chopstick[(i+1]%5);        think;    }}</code></pre></li></ol><ol><li><p>吸烟者问题w</p><pre><code class="lang-c++">int random;semaphore offerTobaccoAndPaper;//烟草和纸semaphore offerTobaccoAndGlue;//烟草和胶水semaphore offerPaperAndGlue;//纸和胶水semaphore finish = 0;//记录抽烟完成//供应者进程provider(){    while(true){        random = rand.random(3);//1-3的整数随机数        if(random == 1){            signal(offerTobaccoAndPaper);//提供烟草和纸        }        else if(random == 1){            signal(offerTobaccoAndGlue);//提供烟草和胶水        }        else{            signal(offerPaperAndGlue);//提供纸和胶水        }        wait(finish);    }}//拥有烟草者进程process(){    while(true){        wait(offerPaperAndGlue);        ...        signal(finish);    }}//拥有纸者进程process(){    while(true){        wait(offerTobaccoAndGlue);        ...        signal(finish);    }}//拥有胶水者进程process(){    while(true){        wait(offerTobaccoAndPaper);        ...        signal(finish);    }}</code></pre></li></ol><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>定义：多个进程因竞争不可剥夺资源而造成的互相等待，若无外力作用，进程都将无法向前推进。</p><p>产生死锁的必要条件(同时满足)</p><ul><li>互斥条件：某资源仅由一个进程占有</li><li>不剥夺条件：进程所获得资源在未使用完毕前，不可直接剥夺</li><li>请求和保持条件：进程已获得资源A，同时提出对资源B的请求，单资源B被其他进程占有，此失请求进程被阻塞，但对其资源A保持不放</li><li>循环等待条件：$p<em>i$等待的资源被$p</em>{i+1}$占有,$\dots$,$p_n$等待的资源被$p_0$占有</li></ul><p>死锁处理策略</p><ol><li>预防死锁：设置限制条件，破环产生死锁的必要条件</li><li>避免死锁：资源动态分配中，用某种方法防止系统进入不安全状态</li><li>死锁检测及解除：允许死锁发生，通过系统检测及时地解除死锁</li></ol><p><strong>银行家算法</strong></p><p>可利用资源矢量Available：每类资源可用的数目</p><p>最大需求矩阵Max：每个进程对每类资源的最大需求</p><p>分配矩阵Allocation：每个进程已分配到每类资源数目</p><p>需求矩阵Need：每个进程尚需的每类资源数目 $Need = Max - Allocation$</p><p>假设系统中有5个进程$p_0,p_1,p_2,p_3,p_4$和三类资源${A,B,C}$,各类资源数目分别为$10、5、7$,在$t_0$时刻资源分配情况如下表，求资源分配安全序列。</p><p><img src="\images\system\3.jpg" srcset="/img/loading.gif" alt=""></p><ol><li><p>求出Need矩阵</p><script type="math/tex; mode=display">\begin{bmatrix}7 & 5 & 3\\ 3 & 2 & 2\\ 9 & 0 & 2\\ 2 & 2 & 2\\ 4 & 3 & 3\end{bmatrix}(MAX)-\begin{bmatrix}0 & 1 & 0\\ 2 & 0 & 0\\ 3 & 0 & 2\\ 2 & 1 & 1\\ 0 & 0 & 2\end{bmatrix}(Allocation)=\begin{bmatrix}7 & 4 & 3\\ 1 & 2 & 2\\ 6 & 0 & 0\\ 0 & 1 & 1\\ 4 & 3 & 1\end{bmatrix}(Need)</script></li><li><p>Available向量与Need矩阵各行进行比较，找出比Available向量小的行，如$$</p><script type="math/tex; mode=display">p_1(1,2,2)<(3,2,2)\\p_3(0,1,1)<(3,2,2)</script><p>选择$p_1$(或$p_3$)加入安全序列</p></li><li><p>释放$p_1$所占有的资源，即把$p_1$的Allocation与Available向量相加,等到新的Available向量</p><script type="math/tex; mode=display">(2,0,0)+(3,3,2)=(5,3,2)=Available(new)</script></li><li><p>再用更新后的Available向量和Need向量矩阵重复步骤2</p></li></ol><p>安全序列：$[p_1,p_3,p_4,p_2,p_0]$</p><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统(1) 概述</title>
    <link href="/2019/06/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1)%20%E6%A6%82%E8%BF%B0/"/>
    <url>/2019/06/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1)%20%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>操作系统是指控制和管理整个计算机系统的硬件和软件资源，并合理的组织调度计算机的工作和资源分配，以提供给用户和其他软件方便的接口和环境的程序集合。</p><h1 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h1><p><strong>并发</strong>：两个或多个事件在同一时间间隔内发生。</p><p><strong>共享</strong></p><ul><li>互斥共享：一段时间内只允许一个进程访问资源，其余进程必须等待；</li><li>同时访问：进程交替的对资源进行访问，即分时共享；</li></ul><p><strong>虚拟</strong>：物理上的若干个实体变为若干个逻辑上的对应物，如虚拟内存、虚拟处理器等。</p><p>虚拟技术：时分复用技术，如处理器的分时共享；空分复用技术，如虚拟存储器。</p><p><strong>异步</strong>：为允许多个程序并发执行，进程的执行并非一贯到底，而是走走停停，以不可预知的速度向前推进。</p><h1 id="目标和功能"><a href="#目标和功能" class="headerlink" title="目标和功能"></a>目标和功能</h1><p><strong>作为计算机系统的管理者</strong>:处理及管理、存储器管理、文件管理、设备管理。</p><p><strong>作为用户与计算机硬件件的接口</strong>：命令接口(联机命令接口、脱机命令接口)、程序接口(系统调用、广义指令)。</p><h1 id="操作系统发展分类"><a href="#操作系统发展分类" class="headerlink" title="操作系统发展分类"></a>操作系统发展分类</h1><ol><li><strong>手工操作阶段</strong>：用户独占全机、CPU等待手工操作</li><li><strong>批处理阶段</strong><ul><li>单道批处理系统：系统对作业的处理成批处理,内存中始终保留一道作业；</li><li>多道批处理系统：允许多个程序同时进入内存并在CPU上交替运行，由作业调度程序自动选择作业运行；</li><li>分时操作系统：共享主机、人机交互</li><li>实时操作系统：及时性和可靠性</li><li>网络操作系统和分布式操作系统</li><li>个人操作系统</li></ul></li></ol><h1 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h1><p>操作系统内核工作在核心态，用户程序工作在用户态，从用户态转为核心态的唯一途径是中断或异常。</p><p>访管指令在用户态执行，产生中断事件，转为核心态，但其不是特权指令，特权指令在和心态执行。</p><p><strong>时钟管理</strong>：实现进程的切换。</p><p><strong>中断机制</strong>：进程管理和调度、系统功能调用、设备驱动、文件访问。</p><ul><li>外中断：外设请求、人为干预</li><li>内中断(异常)：指令中断、硬件故障、软件中断</li></ul><p><strong>原语</strong>：底层公用小程序，处于操作系统最底层、程序的运行具有原子性、运行时间短。</p><p><strong>系统控制的数据结构和处理</strong>：作业控制块、进程控制块、设备控制块、链表、消息队列、缓冲区、内存分配表等。</p><p>系统调用需出发trap命令,进入中断处理的程序在核心态执行，属于操作系统程序。</p><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构(2) 线性表</title>
    <link href="/2019/05/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(2)%20%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2019/05/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(2)%20%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h3><p>线性表是具有相同数据类型的$n$个数据元素的有限序列<br>除第一个元素,每个元素有且仅有一个直接前驱,除最后一个元素,每个元素有且仅有一个后继 </p><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>线性表的顺序存储称为顺序表,用一组地址连续的存储单元依次存储线性表中的数据元素，因此逻辑上相邻的两个元素在物理位置上也相邻</p><p><strong>顺序表描述</strong></p><pre><code class="lang-cpp">#define MaxSize 50typedef struct {    ElemType data[MaxSize];//顺序表元素 静态分配    int length;//当前长度}SqList;#define InitSize 100typedef struct {    ElemType *data;//顺序表元素 动态分配数组的指针    int MaxSize,length;//数组最大容量和当前元素个数}SqList;L.data = (ElemType *)malloc(sizeof(ElemType) * InitSize);//cL.data = new ElemType(InitSize);//C++</code></pre><p>顺序表最主要的特点是随机访问,通过首地址和元素序号可在O(1)的时间复杂度内找到指定的元素</p><p><strong>插入操作</strong><br>在顺序表L的第i个位置插入新元素e</p><pre><code class="lang-cpp">bool ListInsert(SqList &amp;L, int i, ElemType e) {    if (i &lt; 1 || i &gt; L.length+1)        return false;    if (L.length &gt; = MaxSize)        return false;    for (int index = L.length; index &gt;= i; index--)        L.data[index] = L.data[index - 1];    L.data[i-1] = e;    L.length++;    return true;}</code></pre><p><strong>删除操作</strong><br>删除顺序表L中第i个位置的元素,删除的元素用引用变量e返回</p><pre><code class="lang-cpp">bool ListDelete(SqList &amp;L, int i, ElemType &amp;e) {    if (i &lt; 1 || i &gt; L.length)        return false;    e = L.data[i - 1];    for (int index = i; index &lt; L.length; index++)        L.data[index-1] = L.data[index];    L.length--;    return true;}</code></pre><p><strong>按值查找</strong><br>在顺序表L中查找一个元素值等于e的元素,并返回其位置(非索引)</p><pre><code class="lang-cpp">int ListDelete(SqList L,ElemType e) {    int index;    for (index = 0; index &lt; L.length; index++)        if (L.data[index] == e)            return index + 1;    return 0;}</code></pre><p>1.长度为$n$的顺序表$L$,编写一个时间复杂度为<script type="math/tex">O(n)</script>、空间复杂度为<script type="math/tex">O(1)</script>的算法，该算法删除线性表中所以值为x的数据元素。</p><pre><code class="lang-c++">void delX(Sqlist &amp;L,ElemType x){    int k = 0 ;    for(int i = 0;i &lt; L.length;i++){        if(L[i] != x){            L.data[k] = L.data[i];            k++;        }    }    L.length = k;}</code></pre><p>2.从有序顺序表中删除所有其值重复的元素，使表中所有的值均不相同。</p><pre><code class="lang-c++">bool delSame(Sqlist &amp;L){    if(L.length = 0)        return false;    int i,j;    for(i = 0,j = 1;j &lt; L.length;j++){        if(L.data[i] != L.data[j])            L.data[++i] = L.data[j];    }    L.length = i;    return true;}</code></pre><p>3.将两个有序顺序表合并成一个新的有序顺序表，并由函数返回其结果顺序表。</p><pre><code class="lang-c++">bool merge(Sqlist A,Sqlist B,Sqlist &amp;C){    if(A.length + B.length &gt; C.maxSize)        return false;    int i = 0,j = 0,k = 0;    while(i &lt; A.length &amp;&amp; j &lt; B.length){        if(A.data[i] &lt;= B.data[j])            C.data[k++] = A.data[i++];        else            C.data[k++] = B.data[j++]    }    while(i &lt; A.length){        C.data[k++] = A.data[i++];    }    while(j &gt; B.length){        C.data[k++] = B.data[j++];    }    C.length = k+1;    return true;}</code></pre><p>4.线性表<script type="math/tex">(a_1,a_2,...,a_n)</script>中的元素递增有序存储于计算机内，设计算法完成在最短的时间内在表中查找数值为x的元素，若存在则将其与后继元素交换，否则插入表中并使表中元素仍然递增有序。</p><pre><code class="lang-c++">void searchExchangeInsert(Sqlist &amp;L,ElemType x){    int low = 0,high = n -1,mid;    while(low &lt;= high){        mid = (low + high) / 2;        if(L.data[mid] == x)            break;        else if(L.data[mid] &lt; x)            low = mid + 1;        else            high = mid - 1;    }    if(L.data[mid] == x &amp;&amp; mid != (n-1)){        ElemType temp = L.data[mid];        L.data[mid] = L.data[mid+1];        L.[mid+1] = temp;    }    if(low &gt; high){        for(int i = n- 1;i &gt; high;i--)            L.data[i+1] = L.data[i];        L.data[i+1] = x;    }}</code></pre><p>5.设将<script type="math/tex">n(n>1)</script>个整数存放到一维数组R中。设计一个高效的算法将R中保存的序列循环左移<script type="math/tex">p(0<p<n)</script>个位置，即将R中的数据由<script type="math/tex">(x_0,x_1,...,x_{n-1})</script>变换为<script type="math/tex">(x_p,x_{p+1},...,x_{n-1},x_0,x_1,...,x_{p-1})</script></p><p>算法思想:</p><p>令<script type="math/tex">A=(x_0,x_1,...,x_{p-1}),B=(x_p,x_{p+1},...,x_{n-1}),C=BA</script>,<script type="math/tex">A^{-1}=(x_{p-1},x_{p-2},...,x_1,x_0)</script></p><script type="math/tex; mode=display">AB \rightarrow A^{-1}B\rightarrow A^{-1}B^{-1}\rightarrow (A^{-1}B^{-1})^{-1}\rightarrow BA</script><pre><code class="lang-c++">void Reverse(int R[],int from,int to){    for(int i = 0; i &lt; (to-from+1)/2;i++){        int temp = R[from+i];        R[from+i] = R[to-i];        R[to-i] = temp;    }}void Converse(int R[],int n,int p){    Reverse(R,0,p-1);    Reverse(R,p,n-1);    Reverse(R,0,n-1);}</code></pre><p>6.长度为L的升序序列S，处在第[L/2]个位置的输称为S的中位数，两个序列的中位数是含它们所有元素升序序列的中位数，现有两个等长的升序序列A和B，设计算法找出序列A和序列B的中位数。</p><p>算法思想：</p><p>设<script type="math/tex">a</script>为A的中位数，<script type="math/tex">b</script>为B的中位数</p><ol><li>若<script type="math/tex">a=b</script>，则<script type="math/tex">a</script>或<script type="math/tex">b</script>即为所求中位数；</li><li>若<script type="math/tex">a<b</script>，舍弃序列A中较小的一半，同时舍弃序列B中较大的一半，两次舍弃的长度相等；</li><li>若<script type="math/tex">a>b</script>，舍弃序列A中较大的一半，同时舍弃序列B中较小的一半，两次舍弃的长度相等；</li><li>在保留的两个升序序列中,重复1，2，3,直到两个序列只含有一个元素为止，较小者为所求中位数；</li></ol><pre><code class="lang-c++">int mediSearch(int A[],int B[],int n){    int sa=0,da=n-1,ma;    int sb=0,db=n-1,mb;    while(sa != da || sb != db){        ma = (sa+da)/2;        mb = (sb+db)/2;        if(A[ma] == B[mb]){            return A[ma];        }        if(A[ma] &lt; B[mb]){            if((sa+da)%2 == 0){//元素个数为奇数                sa = ma;                db = mb;            }            else{                sa = ma + 1;                db = mb;            }        }        else{            if((sb+db)%2 == 0){//元素个数为奇数                da = ma;                sb = mb;            }            else{                da = ma;                sb = mb + 1;            }        }    }    return A[sa] &lt; B[sb]?A[sa]:B[sb];}</code></pre><p>7.已知一个整数序列<script type="math/tex">A=(a_0,a_1,...a_{n-1})</script>，其中<script type="math/tex">0\leqslant a_{i}\leqslant n</script>,若存在<script type="math/tex">a_{p1}=a_{p2}=...a_{pm}=x</script>,且<script type="math/tex">m>n/2</script>,则称<script type="math/tex">x</script>为A的主元素。例如<script type="math/tex">A=(0,5,5,3,5,7,5,5)</script>，5为A的主元素，<script type="math/tex">B=(0,5,5,3,5,1,5,7)</script>,则B中没有主元素。设计算法找出A的主元素并输出，否则输出-1；</p><pre><code class="lang-c++">int majority(int A[],int n){    int i,c,count = 1;//c保存候选主元素    c = A[0];    for(i = 1;i &lt; n;i++){        if(A[i] == c)            count++;        else{            if(count &gt; 0)                count--;            else{                c = A[i];                count = 1 ;            }        }    }    if(count &gt; 0)        for(i = count = 0;i &lt; n; i++){//统计候选主元素实际出现的次数            if(A[i] == c)                count++;        }    if(count &gt; (n/2))        return c；    else        return -1;}</code></pre><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>由于顺序表的插入、删除操作需要移动大量元素,影响运行效率,由此引入线性表的链式存储,链式存储不需要使用地址连续的存储单元,即逻辑上相邻的元素不要求在物理位置上也相邻</p><p><strong>单链表</strong></p><p>通过一组任意的存储单元来存储线性表中的数据元素,每个链表节点除了存放元素本身,还需要存放指向后继的指针,其是非随机存取结构</p><pre><code class="lang-cpp">typedef struct Node{    ElemType data; //XX    struct Node *next;//指针域}Node,*LinkList;</code></pre><p>通常用头指针来标识一个单链表,在单链表第一个节点前附加一个节点称为头节点,头节点的数据域不设任何信息<br><img src="/images/dataStructure/1.jpg" srcset="/img/loading.gif" alt=""><br>头指针和头节点：<br>1.不管带不带头节点,头指针始终指向链表的第一个节点<br>2.引入头节点,统一操作,统一空表和非空表的处理</p><p><strong>采用头插法建立单链表</strong></p><pre><code class="lang-cpp">LinkList createList(LinkList &amp;L){    Node *node;    int x;    L = (LinkList)malloc(sizeof(Node));    L-&gt;next = null;    scanf(&quot;%d&quot;,&amp;x);    while(x != 10){        node = (Node*)malloc(sizeof(Node));        node-&gt;data = x;        node-&gt;next = L-&gt;next;        L-&gt;next = node;        scanf(&quot;%d&quot;,x);    }    return L;}</code></pre><p><strong>采用尾插法建立单链表</strong></p><pre><code class="lang-cpp">LinkList createList(LinkList &amp;L){    int x;    L = (LinkList)malloc(sizeof(Node));    Node *node,*tail = L;    scanf(&quot;%d&quot;,&amp;x);    while(x != 10){        node = (Node*)malloc(sizeof(Node));        node-&gt;data = x;        tail-&gt;next = node;        tail = node;        scanf(&quot;%d&quot;,x);    }    tail-&gt;next = null;    return L;}</code></pre><p><strong>按序号查找节点值</strong></p><pre><code class="lang-cpp">Node* getElem(LinkList L，int i){    int j=1;    Node *p= L-&gt;next;//头节点    if(i == 0)        return L;    if(i &lt; 1)        return null;    while(p &amp;&amp; j &lt; i){ //从第一个节点开始查找        p = p-&gt;next;        j++    }    return p;}</code></pre><p><strong>按值查找表节点</strong></p><pre><code class="lang-cpp">Node* getElem(LinkList L，ElemType  e){    Node *p= L-&gt;next;//头节点    while(p &amp;&amp; p-&gt;data != e){ //从第一个节点开始查找        p = p-&gt;next;    }    return p;}</code></pre><p><strong>插入节点操作</strong></p><pre><code class="lang-cpp">p = getElem(L,i-1);//查找插入位置i的前驱节点s-&gt;next = p-&gt;next;p-&gt;next = s;</code></pre><p><strong>删除节点操作</strong></p><pre><code class="lang-cpp">p = getElem(L,i-1);//查找删除位置i的前驱节点q = p-next;p-&gt;next = q-&gt;next;free(q);</code></pre><p><strong>双链表</strong></p><p>双链表通过prior和next，分别指向前驱节点和后继节点<br>双链表的按值查找和按位查找操作和单链表相同</p><pre><code class="lang-cpp">typedef struct Node{    ElemType data;    struct Node *prior;    struct Node *next;}Node,*DoubleList;</code></pre><p><strong>插入节点操作</strong></p><pre><code class="lang-cpp">p = getElem(L,i-1);//查找插入位置i的前驱节点s-&gt;next = p-&gt;next;p-&gt;next-prior = s;s-&gt;prior = p;p-&gt;next = s;</code></pre><p><strong>删除节点操作</strong></p><pre><code class="lang-cpp">p = getElem(L,i-1);//查找删除位置i的前驱节点q = p-next;p-&gt;next = q-&gt;next;p-&gt;next-&gt;prior = p;free(q);</code></pre><h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>静态链表是由数组来描述线性表的链式存储结构,节点也有数据域data和指针域next</p><pre><code class="lang-cpp">#define MaxSize 50typedef struct{    ElemType data;    int next ;//下一个元素的数组下标}StaticLinkList[MaxSize];</code></pre><ol><li><p>在带头结点的单链表L中，删除所有值为x的结点，并释放其空间。</p><pre><code class="lang-c++">void deleteX(LinkList &amp;L){    Node *p = L-&gt;next,*pre = L;*q;//pre为p的前驱结点    while(p != null){        if(p-&gt;data == x){            q = p;            p = p-&gt;next;            pre-&gt;next = p;            free(q);        }        else{            pre = p;            p = p-&gt;next;        }    }}</code></pre></li><li><p>设L为带头结点的单链表，编写算法实现从尾到头反向输出每个结点的值。</p><pre><code class="lang-c++">//递归方法void reversePrint(LinkList &amp;L){    if(L-&gt;next != nulll){        reversePrint(L-next);    }    printf(L-&gt;data)}//借助栈</code></pre></li><li><p>编写在带头结点的单链表L中删除最小值结点的高效算法，假设最小值唯一。</p><pre><code class="lang-c++">LinkList deleteMinNode(LinkList &amp;L){    Node *p = L-&gt;next,*pre = L;// pre为p的前驱结点    Node *minPre = pre,*min = p;//最小值的前驱和当前最小值    while(p!= null){        if(p-&gt;data &lt; min-&gt;data){            min = p;            minPre = pre;        }        pre = p;        p = p-&gt;next;    }    minPre-&gt;next = min-&gt;next;    free(min);    return L;}</code></pre></li><li><p>试编写算法将带头结点的链表逆置，且空间复杂度为$O(1)$</p><pre><code class="lang-c++">LinkList reverse(LinkList L){    Node *p,*r;//p为工作指针，r为后继指针    p = L-&gt;next;    L-&gt;next = NULL;    while(p != NULL){        r = p-&gt;next;        p-&gt;next = L-&gt;next;        L-&gt;next = p;        p = r;    }}</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构(1) 基本概念</title>
    <link href="/2019/05/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(1)%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2019/05/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(1)%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p><strong>数据</strong></p><p>数据是信息的载体，是描述客观事物的数、字符以及所有能输入到计算机且能被计算机识别和处理的符号集合。</p><p><strong>数据元素</strong></p><p>数据的基本单位，数据元素由数据项组成。如一条学生记录就是一个数据元素，它由姓名、学号、性别等数据项组成。</p><p><strong>数据对象</strong></p><p>具有相同性质的的数据元素集合，是数据的子集。</p><p><strong>抽象数据类型</strong></p><p>一个数学模型且定义在该模型上的一组操作，通常用数据对象、数据关系、基本操作集表示。</p><p><strong>数据结构</strong></p><p>数据结构包括逻辑结构、存储结构和数据的运算，算法的设计取决于选定的逻辑结构，算法的实现依赖于采用的存储结构。</p><blockquote><p>逻辑结构</p></blockquote><p>线性结构：结构中的数据元素只存在一对一的关系(线性表、栈和队列、串、数组、广义表)</p><p>非线性结构：结构中数据元素存在一对多的关系(树)、多对多的关系(图)</p><p>存储结构：顺序存储、链式存储、索引存储、散列存储</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数</title>
    <link href="/2019/04/26/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <url>/2019/04/26/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><p><strong>概念：行列式是一个数，是取自不同行不同列的n个元素的乘积的代数和</strong></p><p>二阶行列式：<br>$\begin{vmatrix}a &amp; b\ c &amp; d\end{vmatrix}=ad-bc$</p><p>三阶行列式：<br>$\begin{vmatrix}a<em>{1} &amp; a</em>{2} &amp; a<em>{3}\ b</em>{1} &amp; b<em>{2} &amp; b</em>{3}\c<em>{1} &amp; c</em>{2} &amp; c<em>{3}\end{vmatrix}=a</em>{1}b<em>{2}c</em>{3}+a<em>{2}b</em>{3}c<em>{1}+a</em>{3}b<em>{1}c</em>{2}-a<em>{3}b</em>{2}c<em>{1}-a</em>{2}b<em>{1}c</em>{3}-a<em>{1}b</em>{3}c_{2}$(对角线法则)</p><p>n阶乘行列式：<br>$\begin{vmatrix}a<em>{11} &amp; a</em>{12} &amp; … &amp; a<em>{1n}\ a</em>{21} &amp; a<em>{22} &amp; … &amp; a</em>{2n}\\vdots &amp;\vdots &amp; &amp;\vdots &amp;\a<em>{n1} &amp; a</em>{n2} &amp; … &amp; a<em>{nn}\end{vmatrix}=\sum</em>{j<em>{1}j</em>{2}…j<em>{n}}(-1)^{r(j</em>{1}j<em>{2}…j</em>{n})}a<em>{1j</em>{1}}a<em>{2j</em>{2}}…a<em>{nj</em>{n}}$(完全展开式)</p><p>$r(j<em>{1}j</em>{2}…j<em>{n})$ 为排列 $j</em>{1}j<em>{2}…j</em>{n}$ 的逆序数</p><p><strong>性质</strong></p><ol><li><p>经转置行列式的值不变. $\left | A^{T} \right |=\left | A \right |$</p></li><li><p>两行或两列互换的行列式变号. </p></li><li><p>$\begin{vmatrix}a<em>{11} &amp; a</em>{12} &amp; … &amp; a<em>{1n}\ a</em>{21} &amp; a<em>{22} &amp; … &amp; a</em>{2n}\\vdots &amp;\vdots &amp; &amp;\vdots &amp;\a<em>{n1} &amp; a</em>{n2} &amp; … &amp; a<em>{nn}\end{vmatrix}=-\begin{vmatrix}a</em>{21} &amp; a<em>{22} &amp; … &amp; a</em>{2n}\a<em>{11} &amp; a</em>{12} &amp; … &amp; a<em>{1n}\ \vdots &amp;\vdots &amp; &amp;\vdots &amp;\a</em>{n1} &amp; a<em>{n2} &amp; … &amp; a</em>{nn}\end{vmatrix}$</p></li><li><p>某行或某列有公因数k,可把k提取到行列式外.<br>$\begin{vmatrix}ka<em>{11} &amp; ka</em>{12} &amp; … &amp; ka<em>{1n}\ a</em>{21} &amp; a<em>{22} &amp; … &amp; a</em>{2n}\\vdots &amp;\vdots &amp; &amp;\vdots &amp;\a<em>{n1} &amp; a</em>{n2} &amp; … &amp; a<em>{nn}\end{vmatrix}=k\begin{vmatrix}a</em>{11} &amp; a<em>{12} &amp; … &amp; a</em>{1n}\ a<em>{21} &amp; a</em>{22} &amp; … &amp; a<em>{2n}\\vdots &amp;\vdots &amp; &amp;\vdots &amp;\a</em>{n1} &amp; a<em>{n2} &amp; … &amp; a</em>{nn}\end{vmatrix}$</p></li><li><p>某行或某列所有元素都为两个数之和，则可写成两个行列式之和.</p><p>$\begin{vmatrix}a<em>{1} &amp; a</em>{2}+a<em>{4} &amp; a</em>{3}\ b<em>{1} &amp; b</em>{2}+b<em>{4} &amp; b</em>{3}\c<em>{1} &amp; c</em>{2}+c<em>{4} &amp; c</em>{3}\end{vmatrix}=\begin{vmatrix}a<em>{1} &amp; a</em>{2}&amp; a<em>{3}\ b</em>{1} &amp; b<em>{2}&amp; b</em>{3}\c<em>{1} &amp; c</em>{2}&amp; c<em>{3}\end{vmatrix}+\begin{vmatrix}a</em>{1} &amp; a<em>{4} &amp; a</em>{3}\ b<em>{1} &amp; b</em>{4} &amp; b<em>{3}\c</em>{1} &amp; c<em>{4} &amp; c</em>{3}\end{vmatrix}$</p></li><li><p>某行或某列的k倍加至某行或某列，行列式不变.</p><p>$\begin{vmatrix}a<em>{11} &amp; a</em>{12} &amp; … &amp; a<em>{1n}\ a</em>{21} &amp; a<em>{22} &amp; … &amp; a</em>{2n}\\vdots &amp;\vdots &amp; &amp;\vdots &amp;\a<em>{n1} &amp; a</em>{n2} &amp; … &amp; a<em>{nn}\end{vmatrix}=\begin{vmatrix}a</em>{11} &amp; a<em>{12} &amp; … &amp; a</em>{1n}\ a<em>{21}+ka</em>{11} &amp; a<em>{22}+ka</em>{12} &amp; … &amp; a<em>{2n}+ka</em>{1n}\\vdots &amp;\vdots &amp; &amp;\vdots &amp;\a<em>{n1} &amp; a</em>{n2} &amp; … &amp; a_{nn}\end{vmatrix}$</p></li></ol><blockquote><p>特别地,某两行或两列相同或某行或某列元素全为0，则行列式为0；某两行或某两列成比例则行列式为0</p></blockquote><ol><li><p>若 $A$ 是 $n$ 阶矩阵，则 $|kA|=k^n|A|$ ，$|A^*|=|A|^{n-1}$</p></li><li><p>若 $A,B$ 都是 $n$ 阶矩阵，则 $|AB|=|A||B|$</p></li><li><p>若 $A$ 是 $n$ 阶可逆矩阵，则 $|A^{-1}|=|A|^{-1}$</p></li><li><p>若 $n$ 阶矩阵 $A$ 和 $B$ 相似，则 $|A|=|B|$</p></li></ol><p><strong>余子式和代数余子式</strong></p><p>余子式：在 $n$ 阶行列式中，划去元素 $a<em>{ij}$ 所在的第 $i$ 行与第 $j$ 列的所有元素剩下的元素(不改变原来的顺序)所构成的 $n-1$ 阶行列式称为 $a</em>{ij}$ 的余子式,记为 $M_{ij}$</p><p>代数余子式： $a<em>{ij}$ 的代数余子式 $A</em>{ij}=(-1)^{i+j}M_{ij}$</p><p>行列式<br>$\begin{vmatrix}a<em>{11} &amp; a</em>{12} &amp; a<em>{13}\ a</em>{21} &amp; a<em>{22} &amp; a</em>{23}\a<em>{31} &amp; a</em>{32} &amp; a<em>{33}\end{vmatrix}，a</em>{22}的余子式M<em>{22} = \begin{vmatrix}a</em>{11} &amp;  a<em>{13}\ a</em>{31} &amp;  a<em>{33}\end{vmatrix}，a</em>{22}的代数余子式A<em>{22}=(-1)^{(2+2)}\begin{vmatrix}a</em>{11} &amp;  a<em>{13}\ a</em>{31} &amp;  a_{33}\end{vmatrix}$</p><p>行列式等于它任意一行(列)的各元素与其对应的代数式余子式乘积之和</p><p>$|A| = a<em>{i1}A</em>{i1}+a<em>{i2}A</em>{i2}+…+a<em>{in}A</em>{in}(按i行展开)\|A| = a<em>{1j}A</em>{1j}+a<em>{2j}A</em>{2j}+…+a<em>{nj}A</em>{nj}(按j行展开)$</p><p><strong>行列式的计算</strong></p><ol><li><p>三角化</p><p>$\begin{vmatrix}a<em>{11} &amp; a</em>{12} &amp; … &amp; a<em>{1n}\ 0 &amp; a</em>{22} &amp; … &amp; a<em>{2n}\\vdots &amp;\vdots &amp; &amp;\vdots &amp;\0 &amp; 0 &amp; … &amp; a</em>{nn}\end{vmatrix}=\begin{vmatrix}a<em>{11} &amp; 0 &amp; … &amp; 0\ a</em>{21} &amp; a<em>{22} &amp; … &amp; 0\\vdots &amp;\vdots &amp; &amp;\vdots &amp;\a</em>{n1} &amp; a<em>{n2} &amp; … &amp; a</em>{nn}\end{vmatrix}=a<em>{11}a</em>{22}…a_{nn}$</p><p>$\begin{vmatrix}a<em>{11} &amp; a</em>{12} &amp; … &amp; a<em>{1n}\ a</em>{21} &amp; … &amp; a<em>{2n-1} &amp; 0\\vdots &amp; &amp;\vdots &amp;\a</em>{n1} &amp; 0 &amp; … &amp; 0\end{vmatrix}=\begin{vmatrix}0 &amp; … &amp; 0 &amp; a<em>{1n}\ 0 &amp; … &amp; a</em>{2n-1} &amp; a<em>{2n}\\vdots &amp;  &amp;\vdots &amp;\vdots\a</em>{n1} &amp; a<em>{n2} &amp; … &amp; a</em>{nn}\end{vmatrix}=(-1)^{\frac{n(n-1)}{2}}a<em>{1n}a</em>{2n-1}…a_{n1}$</p></li><li><p>公式法(代数余子式) 、递推法 、利用行列式性质、利用矩阵性质</p></li><li><p>利用特征值. $|A| = \prod \lambda_{i}$</p></li><li><p>拉普拉斯展开式<br>$\begin{vmatrix}\mathbf{A} &amp; \mathbf{<em>} \ \mathbf{O} &amp; \mathbf{B}\end{vmatrix}=\begin{vmatrix}\mathbf{A} &amp; \mathbf{O} \ \mathbf{</em>} &amp; \mathbf{B}\end{vmatrix}=|\mathbf{A}||\mathbf{B}|，\begin{vmatrix}\mathbf{O} &amp; \mathbf{A} \ \mathbf{B} &amp; \mathbf{<em>}\end{vmatrix}=\begin{vmatrix}\mathbf{</em>} &amp; \mathbf{A} \ \mathbf{B} &amp; \mathbf{O}\end{vmatrix}=(-1)^{nm}|\mathbf{A}||\mathbf{B}|$</p></li></ol><blockquote><p>   $m、n$ 分别是矩阵 $\mathbf{A}、\mathbf{B}$ 的阶数</p></blockquote><ol><li><p>范德蒙德行列式</p><p>$\begin{vmatrix}1 &amp; 1 &amp; … &amp; 1 \ x_1 &amp;x_2 &amp;… &amp;x_n \ x_1^2 &amp;x_2^2 &amp;… &amp;x_n^2 \ \vdots &amp;\vdots&amp;&amp;\vdots \ x_1^{n-1} &amp;x_2^{n-1} &amp;… &amp;x_n^{n-1} \ \end{vmatrix}=\prod{1\leqslant j\leqslant i\leqslant n}(x_i-x_j)$</p><p>$=(x<em>n-x</em>{n-1})…(x<em>n-x_1)\cdot (x</em>{n-1}-x<em>{n-2})…(x</em>{n-1}-x_1)…(x_3-x_2)(x_3-x_1)(x_2-x_1)$</p></li></ol><p><strong>证明|A| = 0</strong></p><p>Ax = 0 有非零解 、反证法、r(A) &lt; n、0是A的特征值、|A| = -|A|</p><p><strong>行列式的应用</strong></p><ol><li><p>向量组的相关性</p><p>设 $\alpha_1,\alpha_2,\cdots,\alpha_n$ 是 $n$ 个 $n$ 维向量， $A=\alpha_1,\alpha_2,\cdots,\alpha_n$,则 $\alpha_1,\alpha_2,\cdots,\alpha_s$ 线性无关的充分必要条件是 $|A|\neq0$</p></li><li><p>矩阵的满秩与可逆</p><p>$A$ 满秩的充分必要条件是 $|A|\neq0$</p><p>$A$ 可逆的充分必要条件是 $|A|\neq0$</p></li><li><p>方程组的解</p><p>$AX=0$ 只有零解的充分必要条件是 $|A|\neq0$</p><p>$AX=b$ 有唯一解的充分必要条件是 $|A|\neq0$</p></li></ol><p><strong>$n$ 阶行列式的计算</strong></p><p>升阶法、递推法、化为上下三角形法、拆项</p><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><p><strong>概念： $m$ x $n$ 个数排成的 $m$ 行 $n$ 列的集合</strong></p><p>$\begin{bmatrix}a<em>{11} &amp; a</em>{12} &amp; … &amp; a<em>{1n}\ a</em>{21} &amp; a<em>{22} &amp; … &amp; a</em>{2n}\\vdots &amp;\vdots &amp; &amp;\vdots &amp;\a<em>{m1} &amp; a</em>{m2} &amp; … &amp; a_{mn}\end{bmatrix}$ 称为 $m$ x $n$ 矩阵，当 $m=n$ ,矩阵称为$n$ 阶矩阵或 $n$ 阶方阵</p><blockquote><p>行列式是方阵，仅方阵才有行列式</p></blockquote><p><strong>矩阵运算</strong></p><ol><li><p>$A+B=[a<em>{ij}+b</em>{ij}]$ 对应元素相加</p></li><li><p>$kA=[ka_{ij}]$ 所有元素都乘以 $k$</p></li><li><p>$m$ x $n$ 矩阵 $A$ ， $n$ x $s$ 矩阵 $B$ ， $AB=C(m,s),c<em>{ij}=\sum</em>{k=1}^{n}a<em>{ik}b</em>{kj}$</p><p>$\begin{bmatrix}&amp;  &amp; \ (i)\cdots&amp;\cdots&amp;\cdots  \  &amp;  &amp; \end{bmatrix}\begin{bmatrix}&amp; (j)  &amp; \ &amp; \vdots  &amp; \ &amp; \vdots  &amp;  \ &amp; \vdots  &amp;\end{bmatrix}=\begin{bmatrix}&amp; &amp; \ &amp; c_{ij} &amp;  \ &amp; &amp;\end{bmatrix}$</p></li></ol><p>例: $\begin{bmatrix}2 &amp; 1 &amp; 1 \ 1 &amp; 2 &amp; 1\end{bmatrix}\begin{bmatrix}1 &amp; 0 \ 0 &amp; 2 \3 &amp; 1 \end{bmatrix}=\begin{bmatrix}2\cdot1+1\cdot0+1\cdot3 &amp; 2\cdot0+1\cdot2+1\cdot1\ 1\cdot1+2\cdot0+1\cdot3 &amp; 1\cdot0+2\cdot2+1\cdot1\end{bmatrix}=\begin{bmatrix}5 &amp; 3\ 4 &amp; 5\end{bmatrix}$</p><blockquote><p>乘法条件:A的列数=B的行数</p></blockquote><p>矩阵乘法法则:</p><p>$A(BC)=(AB)C;\A(B+C)=AB+AC,(A+B)C=AC+BC;\ (kA)(lB)=klAB;\ AE=A,EA=A \ (A+E)^2=A^2+2A+E$</p><p>$(A+B)^2=(A+B)(A+B)=A^2+AB+BA+B^2\neq  A^2+2AB+B^2$</p><blockquote><p>注意: $AB\neq BA$</p></blockquote><p><strong>矩阵转置</strong></p><p>矩阵 $A$ 的行换成同序数的列得到的新矩阵为矩阵 $A$ 的转置矩阵，记为 $A^T$</p><p>$A=\begin{bmatrix}1&amp; 2 &amp; 3 \ 4&amp; 5&amp; 6\end{bmatrix},A^T=\begin{bmatrix}1 &amp; 4 \ 2 &amp; 5 \3 &amp; 6 \end{bmatrix}$ (横取竖放)</p><p><strong>伴随矩阵</strong></p><p>$A$ 是$n$ 阶矩阵，行列式 $|A|$ 的每个元素 $a<em>{ij}$ 的代数余子式 $A</em>{ij}$ 所构成的矩阵为 $A$ 的伴随矩阵,记为 $A^*$</p><p>$A=\begin{bmatrix}a<em>{11}&amp; a</em>{12}  \ a<em>{21}&amp; a</em>{22} \end{bmatrix}，A^*=\begin{bmatrix}A<em>{11}&amp; A</em>{21}  \ A<em>{12}&amp; A</em>{22} \end{bmatrix}$ (横取竖放)</p><blockquote><p>二阶矩阵的伴随矩阵:主对角线元素互换,副对角线元素变号</p></blockquote><p><strong>逆矩阵</strong></p><p>$A$ 是 $n$ 阶矩阵，若存在 $n$ 阶矩阵 $B$ 使得 $AB=BA=E$ ,则称A是可逆矩阵或非奇异矩阵， $B$ 是 $A$ 的逆矩阵,记为 $A^{-1}=B$ , 且 $A$ 的逆矩阵唯一</p><p>$A$ 可逆 $\Leftrightarrow |A|\neq 0$</p><p>​           $\Leftrightarrow r(A)=n$ </p><p>​           $\Leftrightarrow$ A的列(行)向量组线性无关</p><p>​           $\Leftrightarrow A=P_1P_2\cdots P_s,P_i$ 是初等矩阵</p><p>​           $\Leftrightarrow A$ 与单位矩阵等价</p><p>​           $\Leftrightarrow 0$ 不是A的特征值</p><p>矩阵 $A$ 与矩阵 $B$ 等价的充分必要条件是存在可逆矩阵 $P$ 与 $Q$ ，使得 $PAQ=B$</p><ul><li><p>$A^{-1}=P_t\cdots P_2P_1$ </p><p>$P_t\cdots P_2P_1A=E$</p><p>$P_t\cdots P_2P_1E=A^{-1} \rightarrow (A|E)\rightarrow \cdots\rightarrow(E|A^{-1})$</p></li><li><p>$P_t\cdots P_2P_1A=B$</p><p>$P_t\cdots P_2P_1E=P$ ($P=P_t\cdots P_2P_1$)</p><p>$(A|E)\rightarrow \cdots\rightarrow(B|P)$</p></li></ul><p><strong>正交矩阵</strong></p><p>$n$ 阶矩阵 $A$ ，若满足 $AA^T=A^TA=E$ ，则 $A$ 为正交矩阵</p><p><strong>行阶梯矩阵、行最简矩阵</strong></p><p><strong>矩阵的初等变换</strong></p><p>$E_{i,j}A$ ：对调 $A$ 的 $i,j $行 </p><p>$AE_{i,j}$ ：对调 $A$ 的 $i,j$ 列</p><p><strong>公式</strong></p><p>转置</p><p>   $(A^T)^T=A ;(A+B)^T=A^T+B^T \ (kA)^T=kA^T \ (AB)^T=B^TA^T$</p><p>可逆</p><p>   $(A^{-1})^{-1}=A;(kA)^{-1}=\frac{1}{k}A^{-1}  (k\neq 0) \ (AB)^{-1}=B^{-1}A^{-1};(A^n)^{-1}=(A^{-1})^n$</p><p>   $(A^{-1})^T=(A^T)^{-1};|A^{-1}|=\frac{1}{|A|}\A^{-1}=\frac{1}{|A|}A^*$</p><p>伴随</p><p>   $AA^<em>=A^</em>A=|A|E$</p><p>   $A^<em>=|A|A^{-1};|A^</em>|=|A|^{n-1}$</p><p>   $(A^<em>)^{-1}=(A^{-1})^</em> =\frac{1}{|A|}A\(A^<em>)^T=(A^T)^</em>;(kA)^<em> = k^{n-1}A^</em> ;(A^<em>)^</em>=|A|^{n-2}A$</p><p>   $(AB)^<em> = B^</em>A^*$</p><p>秩</p><p>   $r(A)=r(A^T)=r(A^TA)\r(kA)=r(A),k\neq  0 \r(A+B)\leqslant r(A)+r(B)\r(AB)\leqslant min(r(A),r(B))$</p><p>   若 $A$ 可逆，则 $r(AB)=r(B),r(BA)=r(B)$</p><p>   若 $A$ 为 $m$ x $n$ 矩阵， $B$ 为 $n$ x $s$ 矩阵， $AB=O$ , 则  $r(A)+r(B)\leqslant n$</p><p>   $r\binom{A}{B}=r(A)+r(B)$</p><p>   $r\begin{pmatrix}A &amp; O\ O &amp; B\end{pmatrix}=r(A)+r(B)$</p><p>   设 $A$ 为 $n$ 阶矩阵，则 $r(A)=1$ 的充分必要条件是存在非零 $n$ 维向量 $\alpha,\beta$ ,使得 $A=\alpha\beta^{T}$</p><p>   $\alpha^T\beta=tr(A)$ (主对角线元素相加)</p><p>   $A=\alpha\beta^{T}$ ，则 $A^n=k^{n-1}A$ ,其中 $k=\alpha^T\beta=\beta^{T}\alpha$</p><p>   (满秩=矩阵列向量的个数)</p><ol><li><p>分块矩阵</p><p>$\begin{bmatrix}A_1 &amp; A_2\ A_3 &amp; A_4\end{bmatrix}+\begin{bmatrix}B_1 &amp; B_2\ B_3 &amp; B_4\end{bmatrix}=\begin{bmatrix}A_1+B_1  &amp; A_2+B_2 \ A_3+B_3  &amp; A_4+B_4 \end{bmatrix}$</p><p>$\begin{bmatrix}A &amp; B\ C &amp; D\end{bmatrix}\begin{bmatrix}X &amp; Y\ Z &amp; W\end{bmatrix}=\begin{bmatrix}AX+BZ  &amp; AY+BW \ CX+DZ  &amp; CY+DW\end{bmatrix}$</p><p>$\begin{bmatrix}A &amp; B\ C &amp; D\end{bmatrix}^T=\begin{bmatrix}A^T &amp; C^T\ B^T &amp; D^T\end{bmatrix}$</p><p>若 $B,C$ 分别是 $m$ 阶与 $s$ 阶矩阵，则 $\begin{bmatrix}B &amp; O\ O &amp; C\end{bmatrix}^n =\begin{bmatrix}B^n &amp; O\ O &amp; C^n\end{bmatrix}$</p><p>若 $B,C$ 分别是 $m$ 阶与 $s$ 阶可逆矩阵，则 $\begin{bmatrix}B &amp; O\ O &amp; C\end{bmatrix}^{-1}=\begin{bmatrix}B^{-1} &amp; O\ O &amp; C^{-1}\end{bmatrix}，\begin{bmatrix}O &amp; B\ C &amp; O\end{bmatrix}^{-1}=\begin{bmatrix}O &amp; C^{-1}\ B^{-1} &amp; O\end{bmatrix}$</p></li><li><p>对角矩阵</p><p>$\begin{bmatrix}a_1 &amp;  &amp; \ &amp;  a_2&amp; \ &amp;  &amp; a_3\end{bmatrix}\begin{bmatrix}b_1 &amp;  &amp; \ &amp;  b_2&amp; \ &amp;  &amp; b_3\end{bmatrix}=\begin{bmatrix}a_1b_1 &amp;  &amp; \ &amp;  a_2b_2&amp; \ &amp;  &amp; a_3b_3\end{bmatrix}$</p><p>$\begin{bmatrix}a_1 &amp;  &amp; \ &amp;  a_2&amp; \ &amp;  &amp; a_3\end{bmatrix}^n=\begin{bmatrix}a_1^n &amp;  &amp; \ &amp;  a_2^n&amp; \ &amp;  &amp; a_3^n\end{bmatrix}$</p><p>$\begin{bmatrix}a_1 &amp;  &amp; \ &amp;  a_2&amp; \ &amp;  &amp; a_3\end{bmatrix}^{-1}=\begin{bmatrix}\frac{1}{a_1} &amp;  &amp; \ &amp;  \frac{1}{a_2} &amp; \ &amp;  &amp; \frac{1}{a_3} \end{bmatrix}$</p></li></ol><h1 id="n-维向量"><a href="#n-维向量" class="headerlink" title="$n$ 维向量"></a>$n$ 维向量</h1><p><strong>定义1</strong></p><p>设 $n$ 维列向量 $\alpha =[a_1,a_2,\cdots,a_n]^T,\beta =[b_1.b_2,\cdots,b_n]^T$ ,则</p><p>$\alpha+\beta=[a_1+b_1,a_2+b_2,\cdots,a_n+b_n];\ k\alpha=[ka_1,ka_2,\cdots,ka_n]$</p><p>$(\alpha,\beta)=\alpha^T\beta=a_1b_1+a_2b_2+\cdots+a_nb_n$</p><p>$\begin{Vmatrix}\alpha\end{Vmatrix}=\sqrt{\alpha^T\alpha}=\sqrt{a_1^2+a_2^2+\cdots+a_n^2}$</p><p><strong>定义2</strong></p><p>设 $\alpha_1,\alpha_2,\cdots,\alpha_s$ 是 $n$ 维向量， $k_1,k_2,\cdots,k_s$ 是一组实数，称 $k_1\alpha_1+k_2\alpha_2+\cdots+k_s\alpha_s$ 是 $\alpha_1,\alpha_2,\cdots,\alpha_s$ 的线性组合，若 $k_1\alpha_1+k_2\alpha_2+\cdots+k_s\alpha_s=\beta$ ,则称 $\beta$ 是 $\alpha_1,\alpha_2,\cdots,\alpha_s$ 的线性组合</p><p><strong>定义3</strong></p><p>设 $\alpha_1,\alpha_2,\cdots,\alpha_s$ 是 $n$ 维向量，如果存在不全为零的数使得 $k_1\alpha_1+k_2\alpha_2+\cdots+k_s\alpha_s=0$ ，则称向量组 $\alpha_1,\alpha_2,\cdots,\alpha_s$ 线性相关，当且仅当 $k_1=k_2=\cdots=k_s=0$ 时，称向量组 $\alpha_1,\alpha_2,\cdots,\alpha_s$ 线性无关</p><p><strong>定理1</strong></p><p>$k_1\alpha_1+k_2\alpha_2+\cdots+k_s\alpha_s=\beta$</p><p>$\Leftrightarrow$ 非齐次线性方程组 $[\alpha_1,\alpha_2,\cdots,\alpha_s]\begin{bmatrix}x_1\ x_2\ \vdots \ x_s\end{bmatrix}=\beta$ 有解</p><p>$\Leftrightarrow$ 秩 $r[\alpha_1,\alpha_2,\cdots,\alpha_s]=r[\alpha_1,\alpha_2,\cdots,\alpha_s,\beta]$</p><p><strong>定理2</strong></p><p>$\alpha_1,\alpha_2,\cdots,\alpha_s$ 线性相关</p><p>$\Leftrightarrow$ 齐次线性方程组 $[\alpha_1,\alpha_2,\cdots,\alpha_s]\begin{bmatrix}x_1\ x_2\ \vdots \ x_s\end{bmatrix}=0$ 有非零解</p><p>$\Leftrightarrow$ 秩  $r(\alpha_1,\alpha_2,\cdots,\alpha_s)$ &lt; $s$ </p><p><strong>推论</strong></p><p>1.$n$ 个 $n$ 维向量 $\alpha_1,\alpha_2,\cdots,\alpha_n$ 线性相关的充分必要条件是行列式 $|\alpha_1,\alpha_2,\cdots,\alpha_n|=0$</p><p>2.向量组 $\alpha_1,\alpha_2,\cdots,\alpha_n$ 线性相关的充分必要条件是 $\alpha_1,\alpha_2,\cdots,\alpha_n$ 中至少有一个向量可由其余向量线性表示</p><p>3.含零向量的向量组一定线性相关</p><p>4.若一个向量组线性无关，则该向量组的任何部分向量组都线性无关</p><p>5.若向量组有部分向量组线性相关，则该向量组一定线性相关</p><p>6.$n$ 个 $n$ 维向量 $\alpha_1,\alpha_2,\cdots,\alpha_n$ 线性无关的充分必要条件是行列式 $|\alpha_1,\alpha_2,\cdots,\alpha_n|\neq 0$</p><p>7.两个向量线性相关的充分必要条件是两个向量成比例</p><p>8.若 $A$ 的任意两行两列成比例，则 $A=\alpha\beta^T$</p><h1 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h1><p><strong>定理</strong></p><p>齐次线性方程组 $AX=0$ (零解和非零解)</p><ul><li>只有零解的充分必要条件是 $r(A)=n$ (A为普通矩阵), $|A|\neq0$(A为方阵)</li><li>有非零解的充分必要条件是 $r(A) &lt; n$ (A为普通矩阵), $|A|= 0$(A为方阵)</li></ul><p>非齐次线性线性方程组 $AX=b$ (无解和有解)，增广矩阵 $\overline{A}=(A\vdots b)$</p><ul><li><p>有解的充分必要条件是 $r(A)=r(\overline{A})$</p><p>若 $r(A)=r(\overline{A})=n$ 方程组有唯一解, $|A|\neq0$ (A为方阵时 )</p><p>若 $r(A)=r(\overline{A}) &lt; n$ 方程组有无数个解， $|A|= 0$ (A为方阵时)</p></li><li><p>无解的充分必要条件是 $r(A)\neq r(\overline{A})$</p></li></ul><p><strong>线性方程组解的结构</strong></p><ol><li>设 $X_1,X_2,\cdots,X_s$ 为齐次线性方程组 $AX=0$ 的一组解，则 $k_1X_1+k_2X_2+\cdots+k_sX_s$ 也为 $AX = 0$ 的解</li><li>设 $\eta_0$ 为非齐次线性方程组 $AX=b$ 的一个解，  $X_1,X_2,\cdots,X_s$ 为齐次线性方程组 $AX=0$ 的一组解，则 $k_1X_1+k_2X_2+\cdots+k_sX_s+\eta_0$ 为 $AX=b$ 的一个解</li><li>设 $\eta_1，\eta_2$ 为非齐次线性方程组 $AX=b$ 的两个解，则              $\eta_2-\eta_1$ 为 $AX = 0$ 的一个解</li><li>设 $X_1,X_2,\cdots,X_s$ 为非齐次线性方程组$AX=b$ 的一组解，则 $k_1X_1+k_2X_2+\cdots+k_sX_s$ 也为 $AX = b$ 的解的充分必要条件是      $k_1+k_2+\cdots+k_s=1$</li><li>设 $X_1,X_2,\cdots,X_s$ 为非齐次线性方程组 $AX=b$ 的一组解，则 $k_1X_1+k_2X_2+\cdots+k_sX_s$ 为 $AX = 0$ 的解的充分必要条件是       $k_1+k_2+\cdots+k_s=0$</li></ol><p><strong>解方程组</strong></p><p>化为行阶梯型或行最简</p><p><strong>公共解</strong></p><p>$AX=b$ ， $BX=d$ 两个方程组的解的交集为其公共解</p><p>解法:</p><ul><li>$\begin{pmatrix}A\ B\end{pmatrix}X=\begin{pmatrix}b\ d\end{pmatrix}$ 该方程组的解即为公共解</li><li>先求出(1)的解再代入(2)，解即为公共解</li><li>分别求出(1)(2)的通解，令两个方程组的通解相等，从而求出公共解</li></ul><p><strong>同解</strong></p><p>$AX=O$ ， $BX=O$  , (1)的解也是(2)的解</p><p>(1)、(2)同解的必要条件是 $r(A)=r(B)$</p><h1 id="特征值与特征向量"><a href="#特征值与特征向量" class="headerlink" title="特征值与特征向量"></a>特征值与特征向量</h1><p><strong>定义</strong></p><p>1.设 $A$ 是 $n$ 阶矩阵，如果存在一个数 $\lambda$ 及非零 $n$ 维列向量 $\alpha$  , 使得 $A\alpha=\lambda\alpha$ 成立，则称 $\lambda$ 是 $A$ 的一个特征值， $\alpha$ 是矩阵 $A$ 属于特征值 $\lambda$ 的一个特征向量. <strong>$A$ 有 $n$ 个特征值(包括重数)</strong></p><p>$|\lambda E-A|=0$ 为 $A$ 的特征方程，通过此方程可求出 $A$ 特征值，</p><p>$(\lambda_iE-A)X=0$ 的基础解系为 $\lambda_i$ 对应的线性无关的特征向量</p><p>任何特征值都对应无数个特征向量，但其线性无关的特征向量不超过其重数</p><p>2.设 $A,B$ 都是 $n$ 阶矩阵，如果存在可逆矩阵 $P$ ,使得 $P^{-1}AP=B$ ，则称矩阵 $A,B$ 相似,记作 $A\sim B$</p><p>$P^{-1}A^nP=B^n,A^n=PB^nP^{-1}$</p><p>3.已知 $B=P^{-1}AP$ ， $A$ 的特征值为 $\lambda_1,\lambda_2,\dots,\lambda_n$ ，其对应的特征特征向量为 $\alpha_1,\alpha_2,\dots,\alpha_n$,</p><p>则 $BP^{-1}=P^{-1}A \rightarrow BP^{-1}\alpha_i=P^{-1}A\alpha_i \rightarrow BP^{-1}\alpha_i=\lambda_iP^{-1}\alpha_i$</p><p>即 $B$ 的特征向量为 $\beta_i=P^{-1}\alpha_i$</p><p><strong>矩阵相似的性质</strong></p><ol><li><p>$A\sim A$</p></li><li><p>若 $A\sim B$  , 则 $B\sim A$</p></li><li><p>若 $A\sim B$ ， 则 $A^T\sim B^T$ </p><p>且 $A，B$ 可逆，则 $A^{-1}\sim B^{-1}$ ， $A^<em>\sim B^</em>$</p></li><li><p>若 $A\sim B$ ， $B\sim C$ , 则 $A\sim C$</p></li><li><p>若 $A\sim B$ ， $r(A)=r(B)$ , $|\lambda E-A|=|\lambda E-B|$</p></li><li><p>若 $A\sim B$ ，则 $|A|=|B|,tr(A)=tr(B)$</p></li></ol><p><strong>特征值与特征向量的性质​</strong></p><p>设 $A$ 为 $n$ 阶矩阵， $\lambda_1,\lambda_2,\cdots,\lambda_n$ 为其特征值</p><ol><li>$\lambda_1+\lambda_2+\cdots+\lambda_n=tr(A)$</li><li>$\lambda_1\lambda_2\cdots\lambda_n=|A|$</li></ol><p>设 $A$ 为 $n$ 阶矩阵，且 $A\alpha=\lambda_0\alpha$  ,  $f(x)=a_nx^n+\cdots+a_1x+a_0$ ,令 $f(A)=a_nA^n+\cdots+a_1A+a_0E$ ,则</p><ol><li>若 $A$ 可逆，则 $A^{-1}\alpha=\frac{1}{\lambda_0}\alpha$ ,即 $\frac{1}{\lambda_0}$ 为 $A^{-1}$ 的特征值， $\alpha$ 为 $A^{-1}$ 的特征向量</li><li>若 $A$ 可逆，则 $A^<em>\alpha=\frac{|A|}{\lambda_0}\alpha$ ,即 $\frac{|A|}{\lambda_0}$ 为 $A^</em>$ 的特征值， $\alpha$ 为 $A^*$ 的特征向量</li><li>$f(A)\alpha=f(\lambda_0)\alpha$ ,即 $f(\lambda_0)$ 为 $f(A)$ 的特征值， $\alpha$ 为 $f(A)$ 的特征向量</li></ol><p>$A$ 可逆时， $A^{-1},A^*,A$ 的特征向量相同</p><p><strong>设 $A$ 为 $n$ 阶矩阵, $A$ 的不同特征值对应的特征向量线性无关</strong></p><p><strong>施密特正交化</strong></p><p>把一组<strong>线性无关</strong>的向量组化为一组<strong>两两正交</strong>且规范化的向量组的过程称为施密特正交化</p><p>设 $\alpha_1,\alpha_2,\cdots,\alpha_n$ 线性无关，</p><ol><li><p>正交化</p><p>令 $\beta_1=\alpha_1,\beta_2=\alpha_2-\frac{(\alpha_2,\beta_1)}{(\beta_1,\beta_1)}\beta_1,\cdots$</p><p>$\beta<em>n=\alpha_n-\frac{(\alpha_n,\beta_1)}{(\beta_1,\beta_1)}\beta_1-\frac{(\alpha_n,\beta_2)}{(\beta_2,\beta_2)}\beta_2-\cdots-\frac{(\alpha_n,\beta</em>{n-1})}{(\beta<em>{n-1},\beta</em>{n-1})}\beta_{n-1}$</p><p>则 $\beta_1,\beta_2,\cdots,\beta_n$ 两两正交</p></li><li><p>规范化</p><p>令 $\gamma_1=\frac{1}{|\beta_1|}\beta_1, \gamma_2=\frac{1}{|\beta_2|}\beta_2,\cdots,\gamma_n=\frac{1}{|\beta_n|}\beta_n$</p><p>则 $\gamma_1,\gamma_2,\cdots,\gamma_n$ 为两两正交且规范化的向量组</p></li></ol><p><strong>正交矩阵</strong></p><p>设 $Q$ 为 $n$ 阶矩阵，若 $Q^TQ=E$ 或 $QQ^T=E$  ,称 $Q$ 为正交矩阵</p><p>设 $Q=(\gamma_1,\gamma_2,\cdots,\gamma_n)$ 为 $n$ 阶矩阵,则 $Q$ 为正交矩阵的充分必要条件是 $\gamma_1,\gamma_2,\cdots,\gamma_n$ 为两两正交且规范化的向量组</p><p>若 $Q$ 为正交矩阵，则 $Q^{-1}=Q^T$ , $|Q|=\pm1$ , 特征值为-1或1；且 $Y=QX$ ，则 $|Y|=|X|$<br><strong>实对称矩阵 $A^T=A$</strong></p><ol><li>实对称矩阵的特征值都是实数</li><li><strong>实对称矩阵的不同特征值对应的特征向量正交</strong></li><li>实对称矩阵一定可以相似对角化，特别地若 $A^T=A$ ,则存在正交矩阵 $Q$ 使得 $Q^TAQ=\begin{bmatrix}\lambda_1 &amp; 0 &amp; \cdots &amp; 0\ 0 &amp; \lambda_2 &amp; \cdots &amp; 0\ \vdots &amp; \vdots &amp; \vdots &amp; \vdots\ 0 &amp; 0 &amp; 0 &amp; \lambda_n\end{bmatrix}$ ,$\lambda_1,\lambda_2,\cdots\lambda_n$ 为实对称矩阵$A$的特征值</li></ol><p><strong>矩阵可相似对角化</strong></p><ul><li>矩阵 $A$ 的特征值都是单值</li><li>矩阵 $A$ 为实对称矩阵</li><li>矩阵 $A$ 有 $n$ 个线性无关的特征向量</li><li>矩阵 $A$ 特征值的重数与其对应的线性无关的特征向量个数相等，即 $n-r(\lambda_i E-A)$ =重数, $\lambda_i$ 为重根特征值</li></ul><p>设 $A$ 为 $n$ 阶矩阵，则 $A$ 可相似对角化(与对角矩阵相似)的充分必要条件是 $A$ 有 $n$ 个线性无关的特征向量</p><ol><li><p>由 $|\lambda E-A|=0$ 求出 $A$ 的特征值 $\lambda_1,\lambda_2,\cdots,\lambda_n$</p></li><li><p>由 $(\lambda_i E-A)X=0$ 求出 $A$ 的特征向量 $\delta_1,\delta_2,\cdots,\delta_m$</p></li><li><p>若 $m&lt;n$ 时，矩阵 $A$ 不可对角化；若 $m=n$ 时，矩阵 $A$ 可相似对角化</p><p>由 $A\delta_i=\lambda_i\delta_i$ 得</p><p>$(A\delta_1,A\delta_2,\cdots,A\delta_n)=(\lambda_1\delta_1,\lambda_2\delta_2 ,\cdots,\lambda_n\delta_n )$ 即</p><p>$A(\delta_1,\delta_2,\cdots,\delta_n)=(\delta_1,\delta_2,\cdots,\delta_n)\begin{bmatrix}\lambda_1 &amp; 0 &amp; \cdots &amp; 0\ 0 &amp; \lambda_2 &amp; \cdots &amp; 0\ \vdots &amp; \vdots &amp; \vdots &amp; \vdots\ 0 &amp; 0 &amp; 0 &amp; \lambda_n\end{bmatrix}$</p><p>令 $P=(\delta_1,\delta_2,\cdots,\delta_n)$ ,则 $P$ 可逆，且 $P^{-1}AP=\begin{bmatrix}\lambda_1 &amp; 0 &amp; \cdots &amp; 0\ 0 &amp; \lambda_2 &amp; \cdots &amp; 0\ \vdots &amp; \vdots &amp; \vdots &amp; \vdots\ 0 &amp; 0 &amp; 0 &amp; \lambda_n\end{bmatrix}$</p></li></ol><p><strong>实对称矩阵的对角化</strong></p><ol><li>若求可逆矩阵 $P$ ，则按上述步骤即可</li><li>若求正交矩阵 $Q$ ,将 $\delta_1,\delta_2,\cdots,\delta_n$ 施密特正交化和规范化，令 $Q=(\delta_1,\delta_2,\cdots,\delta_n)$ ,则 $Q^TAQ=\begin{bmatrix}\lambda_1 &amp; 0 &amp; \cdots &amp; 0\ 0 &amp; \lambda_2 &amp; \cdots &amp; 0\ \vdots &amp; \vdots &amp; \vdots &amp; \vdots\ 0 &amp; 0 &amp; 0 &amp; \lambda_n\end{bmatrix}$</li></ol><p><strong>矩阵相似的判断</strong></p><p>$A,B$ 相似的必要条件是 $|\lambda E-A|=|\lambda E-B|$ ,即 $A,B$ 具有相同的特征值</p><p>若 $A,B$ 特征值相同，判断 $A,B$ 相似一般分如下情形：</p><ol><li>若 $A,B$ 都可相似对角化，则 $A \sim B$</li><li>若 $A,B$ 一个可相似对角化，一个不可相似对角化，则 $A,B$ 一定不相似</li><li>若 $A,B$ 都不可相似对角化，一般不讨论</li></ol><h1 id="二次型"><a href="#二次型" class="headerlink" title="二次型"></a>二次型</h1><p><strong>定义1</strong></p><p>含有 $n$ 个变量 $x_1,x_2,\cdots,x_n$ 的二次齐次函数</p><p>$f(x<em>1,x_2,\cdots,x_n)=a</em>{11}x<em>1^2+a</em>{22}x<em>2^2+\cdots+a</em>{nn}x<em>n^2+2a</em>{12}x<em>1x_2+2a</em>{13}x<em>1x_3+\cdots+2a</em>{1n}x<em>1x_n+2a</em>{23}x<em>2x_3+\cdots+2a</em>{2n}x<em>2x_n+\cdots+2a</em>{n-1,n}x_{n-1}x_n$ </p><p>称为 $n$ 元二次型.若规定 $a<em>{ij}=a</em>{ji}$ ，则二次型有矩阵表示 $f(x_1,x_2,\cdots,x_n)=x^TAx$,</p><p>其中 $x=[x<em>1,x_2,\cdots,x_n]^T,A=[a</em>{ij}]$ 且 $A^T=A$ ,称 $A$ 为二次型的矩阵</p><p>例如： $f(x_1,x_2)=x_1^2+5x_2^2+6x_1x_2$ ，有</p><p>​             $f(x_1,x_2)=x_1^2+3x_1x_2+3x_1x_2+5x_2^2$</p><p>​                              $=x_1(x_1+3_x2)+x_2(3x_1+5x_2)$</p><p>​                              $=[x_1,x_2] \begin{bmatrix}x_1 &amp; 3x_2\ 3x_1 &amp; 5x_2 \end{bmatrix}$</p><p>​                             $=[x_1,x_2] \begin{bmatrix}1 &amp; 3\ 3 &amp; 5 \end{bmatrix} \begin{bmatrix}x_1\ x_2\end{bmatrix}=x^TAx$ </p><p>若对任何 $x\neq0$ ,恒有 $x^TAx&gt;0$ ，则称二次型为正定二次型</p><ul><li><p>若二次型中只含有变量的平方项，即 $x^TAx=d_1x_1^2+d_2x_2^2+\cdots+d_nx_n^2$ 称为二次型的标准形</p></li><li><p>若标准形中，平方项的系数 $d<em>j$ 为1，-1或0，即 $x^TAx=x_1^2+x_2^2+\cdots+x_p^2-x</em>{p+1}x^2+\cdots-x_{p+q}^2$ 称为二次型的规范形</p></li><li>标准形中，正平方项的个数 $p$ 称为二次型的正惯性指数，负平方项的个数 $q$ 称为二次型的负惯性指数，系数不为0的个数为二次型的秩</li></ul><p><strong>定义2</strong></p><p>若<br> $\begin{matrix}x<em>1=c</em>{11}y<em>1+c</em>{12}y<em>2+c</em>{13}y<em>3\ x_2=c</em>{21}y<em>1+c</em>{22}y<em>2+c</em>{23}y<em>3\ x_3=c</em>{31}y<em>1+c</em>{32}y<em>2+c</em>{33}y_3\end{matrix}$</p><p>满足 $|C|=\begin{bmatrix}c<em>{11} &amp; c</em>{12} &amp; c<em>{13}\c</em>{21} &amp; c<em>{22} &amp; c</em>{23}\ c<em>{31} &amp; c</em>{32} &amp; c<em>{33}\end{bmatrix} \neq0$<br>称 $x=[x_1,x_2,x_3]^T$ 到 $y=[y_1,y_2,y_3]$ 的坐标变换，即<br>$\begin{bmatrix}x_1\ x_2\ x_3\end{bmatrix}=\begin{bmatrix}c</em>{11} &amp; c<em>{12} &amp; c</em>{13}\ c<em>{21} &amp; c</em>{22} &amp; c<em>{23}\ c</em>{31} &amp; c<em>{32} &amp; c</em>{33}\end{bmatrix}\begin{bmatrix}y_1\ y_2\ y_3\end{bmatrix} 或x=Cy$</p><p>两个 $n$ 阶矩阵 $A$ 和 $B$ ，如果存在可逆矩阵 $C$ 使得 $C^TAC=B$ 则称矩阵 $A$ 和 $B$ 合同，并称 $A$ 到 $B$ 的变换为合同变换， $C$ 为合同变换矩阵</p><p><strong>定理1</strong></p><p>变量 $x=[x_1,x_2,\dots,x_n]^T$ 的 $n$ 元二次型 $x^TAx$ 经坐标变换 $x=Cy$ 后，化为变量 $y=[y_1,y_2,\cdots,y_n]$ 的 $n$ 元二次型  $y^TBy$.</p><p>$x^TAx=(Cy)^TA(Cy)=y^TC^TACy=y^TBy$, 其中 $B=C^TAC$ </p><p><strong>定理2</strong></p><p>任意的 $n$ 元二次型 $x^TAx$ 都可以通过坐标变换化成标准形</p><p>对任一个 $n$ 元二次型 $x^TAx$ ，其中 $A$ 是 $n$ 阶实对称矩阵，必存在正交变换 $x=Qy$  ( $Q$ 是正交矩阵)，使得 $x^TAx$ 化为标准形 $\lambda_1y_1^2+\lambda_2y_2^2+\cdots+\lambda_ny_n^2$</p><p><strong>定理3</strong></p><p>任一 $n$ 阶是对称矩阵 $A$ ，总可以合同于一个对角矩阵，即 $C^TAC=\begin{bmatrix}d_1 &amp; 0 &amp; \cdots &amp; 0\ 0 &amp; d_2 &amp; \cdots &amp; 0\ \vdots &amp; \vdots &amp; \vdots &amp; \vdots\ 0 &amp; 0 &amp; 0 &amp; d_n\end{bmatrix}$</p><p><strong>定理4</strong>​</p><p>$n$ 元二次型 $x^TAx$ 正定的充分必要条件:</p><ol><li>$A$ 的正惯性指数是 $n$</li><li>$A$ 与 $E$ 合同，且存在可逆矩阵 $C$ ，使得 $C^TAC=E$</li><li>$A$ 的所有特征值均为正数</li><li>$A$ 的各阶顺序主子式均大于零</li></ol>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译C/C++为dll供Java调用</title>
    <link href="/2019/03/10/eclipse%E7%BC%96%E8%AF%91C-C++%E4%B8%BAdll%E4%BE%9BJava%E8%B0%83%E7%94%A8/"/>
    <url>/2019/03/10/eclipse%E7%BC%96%E8%AF%91C-C++%E4%B8%BAdll%E4%BE%9BJava%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="开发环境准备"><a href="#开发环境准备" class="headerlink" title="开发环境准备"></a>开发环境准备</h1><ul><li>下载 Eclipse IDE for C/C++<br>地址:<a href="https://www.eclipse.org/downloads/packages/" target="_blank" rel="noopener">https://www.eclipse.org/downloads/packages/</a><br><img src="/images/2019/3/10/1.jpg" srcset="/img/loading.gif" alt=""></li><li>安装mingw64<br>地址:<a href="http://www.mingw-w64.org/doku.php/download" target="_blank" rel="noopener">http://www.mingw-w64.org/doku.php/download</a><br><img src="/images/2019/3/10/2.jpg" srcset="/img/loading.gif" alt=""><br>1）配置mingw64环境变量<br>C_INCLUDE_PATH : mingw64安装目录\include<br>LIBRARY_PATH :mingw64安装目录\lib<br><img src="/images/2019/3/10/3.jpg" srcset="/img/loading.gif" alt=""><br>2）系统变量的path变量中添加 mingw64安装目录\bin<br>注意:以防万一,本文也将include和lib目录也加入了path变量中<br><img src="/images/2019/3/10/4.jpg" srcset="/img/loading.gif" alt=""><br>3）测试 cmd里执行如下命令<pre><code class="lang-bash">gcc -v</code></pre>输出版本信息则安装成功<br><img src="/images/2019/3/10/5.jpg" srcset="/img/loading.gif" alt=""></li></ul><h1 id="编译C-C-为dll"><a href="#编译C-C-为dll" class="headerlink" title="编译C/C++为dll"></a>编译C/C++为dll</h1><p><strong>eclipse环境下</strong></p><ul><li>eclipse新建项目<br><img src="/images/2019/3/10/6.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/2019/3/10/7.jpg" srcset="/img/loading.gif" alt=""></li><li>新建源代码文件<br><img src="/images/2019/3/10/8.jpg" srcset="/img/loading.gif" alt=""></li><li>编写方法<br><img src="/images/2019/3/10/9.jpg" srcset="/img/loading.gif" alt=""></li><li>右键项目 properties 配置<br>1）Tool Chain Editor的配置<br><img src="/images/2019/3/10/10.jpg" srcset="/img/loading.gif" alt=""><br>2）settings的配置<br><img src="/images/2019/3/10/11.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/2019/3/10/12.jpg" srcset="/img/loading.gif" alt=""><pre><code class="lang-bash">-Wl,--add-stdcall-alias -static-libgcc -static-libstdc++ -shared</code></pre><img src="/images/2019/3/10/13.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/2019/3/10/14.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/2019/3/10/15.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/2019/3/10/16.jpg" srcset="/img/loading.gif" alt=""></li><li>右键项目 build project 执行编译<br><img src="/images/2019/3/10/17.jpg" srcset="/img/loading.gif" alt=""><br>编译成功<br><img src="/images/2019/3/10/18.jpg" srcset="/img/loading.gif" alt=""><br>在eclipse的工作目录 test项目下的debug目录可以找到编译好的dll文件<br><img src="/images/2019/3/10/19.jpg" srcset="/img/loading.gif" alt=""></li></ul><p><strong>visual studio 2015环境下</strong></p><ul><li>新建win32项目<br><img src="/images/2019/3/10/22.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/2019/3/10/23.jpg" srcset="/img/loading.gif" alt=""></li><li>新建头文件<pre><code class="lang-cpp">#pragma once#ifdef DLL_IMP#define DLL_API __declspec(dllexport) //导出函数#endif // DLL_APIextern &quot;C&quot; {  DLL_API char*   say();}</code></pre><img src="/images/2019/3/10/24.jpg" srcset="/img/loading.gif" alt=""></li><li>新建源文件<pre><code class="lang-cpp">#define DLL_IMP#include &quot;say.h&quot;#include&lt;stdio.h&gt;char*  say(){  printf(&quot;hello&quot;);  return &quot;ok&quot;;}</code></pre><img src="/images/2019/3/10/25.jpg" srcset="/img/loading.gif" alt=""></li><li>设置属性 编译为dll<br><img src="/images/2019/3/10/26.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/2019/3/10/27.jpg" srcset="/img/loading.gif" alt=""><h1 id="Java调用dll"><a href="#Java调用dll" class="headerlink" title="Java调用dll"></a>Java调用dll</h1></li><li>下载JNA jna.jar 地址:<a href="https://mvnrepository.com/artifact/com.sun.jna/jna/3.0.9" target="_blank" rel="noopener">https://mvnrepository.com/artifact/com.sun.jna/jna/3.0.9</a></li><li>新建Java项目 引入jna.jar 并将dll拷贝到项目根路径下(否则需要填写dll的绝对路径)<br><img src="/images/2019/3/10/20.jpg" srcset="/img/loading.gif" alt=""></li><li>编写调用接口类</li></ul><pre><code class="lang-java">import com.sun.jna.Library;import com.sun.jna.Native;public interface Clibrary extends Library{    //使用eclipse环境下生成的dll    Clibrary instance = (Clibrary) Native.loadLibrary(&quot;libtest&quot;, Clibrary.class);    //dll中的方法 声明需一致    void sayHello();     //使用vs 2015生成的dll    //Clibrary instance = (Clibrary) Native.loadLibrary(&quot;yolo-dll&quot;, Clibrary.class);    //String say();}</code></pre><ul><li>编写Main类 调用方法执行</li></ul><pre><code class="lang-java">public class Main {    public static void main(String[] args) {        Clibrary.instance.sayHello();    }}</code></pre><p>执行结果 如图<br><img src="/images/2019/3/10/21.jpg" srcset="/img/loading.gif" alt=""></p><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JNA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo搭建GitHub博客</title>
    <link href="/2019/03/10/hexo%E6%90%AD%E5%BB%BAGitHub%E5%8D%9A%E5%AE%A2/"/>
    <url>/2019/03/10/hexo%E6%90%AD%E5%BB%BAGitHub%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>前提环境:Node.js、Git已安装</p><h1 id="通过github创建repository-格式-博客名称-github-io"><a href="#通过github创建repository-格式-博客名称-github-io" class="headerlink" title="通过github创建repository 格式:博客名称.github.io"></a>通过github创建repository 格式:博客名称.github.io</h1><p><img src="/images/github/1.jpg" srcset="/img/loading.gif" alt=""></p><h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><ul><li>新建blog文件夹,并打开git bash<br><img src="/images/github/2.jpg" srcset="/img/loading.gif" alt=""></li><li><p>执行命令</p><pre><code class="lang-bash">npm install hexo -g #安装hexo命令hexo -v #检查是否安装成功</code></pre><p><img src="/images/github/3.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>初始化hexo</p><pre><code class="lang-bash">hexo init #初始化blog文件夹npm install #安装必要组件#执行如下命令 开启本地体验hexo ghexo s  #访问http://localhost:4000 即可看到默认博客页面</code></pre></li></ul><h1 id="关联hexo-github"><a href="#关联hexo-github" class="headerlink" title="关联hexo - github"></a>关联hexo - github</h1><ul><li>设置git的username和email<pre><code class="lang-bash">git config --global user.name &#39;jiaopan&#39; #设置用户名git config --global user.email &#39;807854982@qq.com&#39; #设置邮箱</code></pre></li><li>生成公钥<pre><code class="lang-bash">ssh-keygen -t rsa -C “807854982@qq.com”#连续按三次回车键</code></pre>红框处为密钥保存的路径<br><img src="/images/github/4.jpg" srcset="/img/loading.gif" alt=""><pre><code class="lang-bash">cd ~/.ssh #cd到密钥目录#添加密钥到ssh-agenteval &quot;$(ssh-agent -s)&quot;ssh-add ~/.ssh/id_rsa</code></pre></li><li>配置github SSH<br>登录github,在settings里添加SSH<br><img src="/images/github/5.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/github/6.jpg" srcset="/img/loading.gif" alt=""><br>将生成的id_rsa.pub内容复制到SSH key里 点击add SSH 即可<br><img src="/images/github/7.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/github/8.jpg" srcset="/img/loading.gif" alt=""><br>测试是否可连 出现用户名则成功<pre><code class="lang-bash">ssh -T git@github.com</code></pre><img src="/images/github/9.jpg" srcset="/img/loading.gif" alt=""></li><li>配置_config.yml<br><img src="/images/github/10.jpg" srcset="/img/loading.gif" alt=""><br>更改如下配置:<pre><code class="lang-bash">url:  https://jiaopaner.github.io #  repository deploy:type: gitrepo: git@github.com:JiaoPaner/jiaopaner.github.io.gitbranch: master</code></pre></li></ul><h1 id="文章发布"><a href="#文章发布" class="headerlink" title="文章发布"></a>文章发布</h1><ul><li>安装扩展<pre><code class="lang-bash">npm install hexo-deployer-git --save</code></pre></li><li>创建文章<pre><code class="lang-bash">hexo new post &#39;文章名&#39; #在blog/source/post</code></pre>在blog目录下的 source/_posts将会生成对应的MD文件.打开MD文件进行文章编辑即可<br><img src="/images/github/11.jpg" srcset="/img/loading.gif" alt=""></li><li>发布文章<pre><code class="lang-bash">hexo d -g</code></pre>成功后,访问博客地址 <a href="https://jiaopaner.github.io">https://jiaopaner.github.io</a> 即可看到</li></ul><h1 id="博客主题"><a href="#博客主题" class="headerlink" title="博客主题"></a>博客主题</h1><ul><li>通过<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a> 主题目录下载主题 </li><li>主题内有下载地址和安装方法,一般为github地址,下载其压缩包或git clone到本地</li><li>复制到blog目录下的themes内(本博客为next主题)<br><img src="/images/github/12.jpg" srcset="/img/loading.gif" alt=""></li><li><p>修改_config.yml  theme值为themes下主题目录名<br><img src="/images/github/13.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>更新即可</p><pre><code class="lang-bash">hexo d -g</code></pre></li></ul><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux下mysql的安装</title>
    <link href="/2019/03/06/linux%E4%B8%8Bmysql%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <url>/2019/03/06/linux%E4%B8%8Bmysql%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="linux下mysql安装步骤"><a href="#linux下mysql安装步骤" class="headerlink" title="linux下mysql安装步骤"></a>linux下mysql安装步骤</h1><p>1.ubuntu系统<br>1) 输入如下命令</p><pre><code class="lang-bash">sudo apt-get updatesudo apt-get install mysql-server</code></pre><blockquote><p>安装好软件包后,会弹出设置root账户密码的提示</p></blockquote><p>2) 测试是否安装成功(mysql 的socket处于 listen 状态则表示安装成功)</p><pre><code class="lang-bash">sudo netstat -tap | grep mysql</code></pre><p><img src="/images/note/6.jpg" srcset="/img/loading.gif" alt=""></p><p>3) 登陆mysql</p><pre><code class="lang-bash">sudo mysql -uroot -p #执行命令后再输入密码</code></pre><p><img src="/images/note/7.jpg" srcset="/img/loading.gif" alt=""></p><blockquote><p>登陆成功</p></blockquote><p><img src="/images/note/8.jpg" srcset="/img/loading.gif" alt=""></p><p>4) 设置mysql可远程连接</p><blockquote><p>修改配置文件</p></blockquote><pre><code class="lang-bash">sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</code></pre><blockquote><p>注释bind-address</p></blockquote><p><img src="/images/note/9.jpg" srcset="/img/loading.gif" alt=""></p><pre><code class="lang-bash">sudo mysql -uroot -p #登陆mysqlmysql&gt; show databases #查看已有的数据库mysql&gt; use mysql; #跳转到名为mysql的数据库mysql&gt; update user set host=&#39;%&#39; where user=&#39;root&#39;;# %:任意主机#给予root账户在任意主机下可访问数据库的权限mysql&gt; grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;设置的密码&#39; with grant option;mysql&gt; flush privileges;mysql&gt;exit;</code></pre><p><img src="/images/note/10.jpg" srcset="/img/loading.gif" alt=""></p><blockquote><p>重启mysql</p></blockquote><pre><code class="lang-bash">sudo service mysql</code></pre><p>2.Centos7(待更新)</p><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux下jdk安装</title>
    <link href="/2019/03/06/linux%E4%B8%8Bjdk%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <url>/2019/03/06/linux%E4%B8%8Bjdk%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="linux下JDK安装步骤"><a href="#linux下JDK安装步骤" class="headerlink" title="linux下JDK安装步骤"></a>linux下JDK安装步骤</h1><p>1.检查是否已安装JDK</p><pre><code class="lang-bash">[root@localhost ~] java -version</code></pre><p><img src="/images/note/1.jpg" srcset="/img/loading.gif" alt=""></p><blockquote><p>若默认已安装openjdk，将其卸载</p></blockquote><pre><code class="lang-bash">[root@localhost ~] yum remove *openjdk*</code></pre><p><img src="/images/note/2.jpg" srcset="/img/loading.gif" alt=""></p><p>2.安装oracle JDK1.8</p><pre><code class="lang-bash">[root@localhost ~]# cd /usr/local #跳转到local目录[root@localhost local]# mkdir jdk8 #创建jdk8目录</code></pre><blockquote><p>复制下载好的linux版JDK1.8到 /usr/local/jdk8目录</p></blockquote><p><img src="/images/note/3.jpg" srcset="/img/loading.gif" alt=""></p><blockquote><p>解压</p></blockquote><pre><code class="lang-bash">[root@localhost local]# cd jdk8[root@master jdk8]# tar -zxvf jdk-8u151-linux-x64.tar.gz</code></pre><blockquote><p>配置jdk环境变量</p></blockquote><pre><code class="lang-bash">[root@master jdk8]# vim /etc/profileexport JAVA_HOME=/usr/local/jdk8/jdk1.8.0_151export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/libexport PATH=$PATH:$JAVA_HOME/bin</code></pre><p><img src="/images/note/4.jpg" srcset="/img/loading.gif" alt=""></p><blockquote><p>环境变量生效</p></blockquote><pre><code class="lang-bash">[root@master jdk8]# source /etc/profile</code></pre><blockquote><p>检查是否安装成功</p></blockquote><pre><code class="lang-bash">[root@master jdk8]# java -version</code></pre><p><img src="/images/note/5.jpg" srcset="/img/loading.gif" alt=""></p><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jdk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode(11) ReverseWordsInAStringIII</title>
    <link href="/2018/07/26/leetcode(11)%20ReverseWordsInAStringIII/"/>
    <url>/2018/07/26/leetcode(11)%20ReverseWordsInAStringIII/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字图像处理(2) 灰度变换与空间滤波</title>
    <link href="/2018/07/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86(2)%20%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2/"/>
    <url>/2018/07/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86(2)%20%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2/</url>
    
    <content type="html"><![CDATA[<p>空间域,即包含图像像素的平面,空间域技术直接在图像像素上操作,空间域处理可由下式表示:<br>g(x,y) = T[f(x,y)]<br>其中f(x,y)为输入图像,g(x,y)为处理后的图像,T是在点(x,y)的邻域上定义的关于f的一种算子</p><h3 id="灰度变换"><a href="#灰度变换" class="headerlink" title="灰度变换"></a>灰度变换</h3><p>s = T(r)<br>s和r分别表示g和f在任意点(x,y)处的灰度</p><h4 id="灰度变换函数"><a href="#灰度变换函数" class="headerlink" title="灰度变换函数"></a>灰度变换函数</h4><ul><li>图像反转  (图像灰度级范围[0,L-1])<br>s = L - 1 -r<br>该式反转一幅图像的灰度级,可得到等效的照片底片,适用于增强嵌入在图像暗区域中的白色或灰色细节<br><img src="/images/cv/34.jpg" srcset="/img/loading.gif" alt=""></li><li>对数变换<br>s = clog(1+r) (c为常数)<br>该式将范围较窄的低灰度值映射为范围较宽的灰度值，适用于增强图像中的暗像素值<br><img src="/images/cv/35.jpg" srcset="/img/loading.gif" alt=""></li><li>幂律(伽马)变换<br>s = cr^γ (c和γ为正常数)<br>γ &lt; 1 提高灰度级，在正比函数上方，使图像变亮<br>γ &gt; 1 降低灰度级，在正比函数下方，使图像变暗<br><img src="/images/cv/36.png" srcset="/img/loading.gif" alt=""><br>γ = 0.6,0.4,0.3 | c = 1<br><img src="/images/cv/37.jpg" srcset="/img/loading.gif" alt=""><br>γ = 3,4,5 | c = 1<br><img src="/images/cv/38.jpg" srcset="/img/loading.gif" alt=""></li></ul><h4 id="分段线性变换函数"><a href="#分段线性变换函数" class="headerlink" title="分段线性变换函数"></a>分段线性变换函数</h4><ul><li><p>对比度拉伸 扩展低对比度图像灰度级动态范围<br>点(s1,r1)和点(s2,r2)的位置控制变换函数的形状<br>若r1=s1,r2=s2,则变换为线性函数,将产生无变化的灰度级<br>若r1=r2,s1=0,s2=L-1,则变换为阈值处理函数,将产生一幅二值图像<br>(s1,r1)和点(s2,r2)的中间值产生不同程度的灰度级扩展<br><img src="/images/cv/39.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>灰度级分层 突出图像中指定灰度范围的亮度<br>将感兴趣范围内的所有灰度值显示为一个值(如白色),而其他值显示为另一个值(如黑色)<br><img src="/images/cv/40.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/cv/41.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>比特平面分层<br>像素由比特组成的数字,在256级灰度图像中,每个像素由8比特组成,通过突出特定比特来增强图像<br><img src="/images/cv/42.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/cv/43.jpg" srcset="/img/loading.gif" alt=""><br>存储4个高阶比特平面允许以接受的细节重建图像<br><img src="/images/cv/44.jpg" srcset="/img/loading.gif" alt=""></p></li></ul><h3 id="直方图处理"><a href="#直方图处理" class="headerlink" title="直方图处理"></a>直方图处理</h3><p>灰度级范围为[0，L-1]数字图像直方图是离散函数h(r_k) = n_k，其中r_k是第k个灰度级(灰度值),n_k是图像中灰度级为r_k的像素个数,归一化的直方图为p(r_k) = n_k / (MN)<br><img src="/images/cv/45.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/cv/46.jpg" srcset="/img/loading.gif" alt=""><br>暗图像的直方图的分量集中在灰度级的低端,亮图像的直方图分量则倾向于灰度级的高端<br>高对比度图像直方图分量覆盖很宽的灰度级范围,且像素分布均匀,反之,低对比度图像直方图的分量覆盖较窄的灰度级范围,且像素分布不均匀<br>结论:若一幅图像倾向于占据整个可能的灰度级且分布均匀,则图像具有高对比度且灰色调具有较大变化</p><h4 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h4><p>作用:使得图像的像素占有全部可能的灰度级且分布均匀,能够具有高对比度<br>方法:灰度级变换  s = T(r)<br>T(r)满足下列两个条件：<br>（1）T(r)在区间0 ≤ r ≤ L-1中为单值且单调递增<br>（2）当 0 ≤ r ≤ L-1时,0 ≤ T(r)  ≤  L-1<br>条件(1)保证原图各灰度级在变换后仍保持从黑到白(或从白到黑)的排列次序<br>条件(2)保证变换前后灰度值动态范围的一致性<br><img src="/images/cv/51.jpg" srcset="/img/loading.gif" alt=""><br>图像的灰度级可看成是区间[0,L-1]内的随机变量,随机变量的基本描绘是其概率密度函数<br>令p_r(r)为r的概率密度函数,p_s(s)是s的概率密度函数,p_r(r)和T(r)已知,在感兴趣的值域上T(r)是连续可微的,则<br><img src="/images/cv/50.jpg" srcset="/img/loading.gif" alt=""><br>有如下变换函数T(r)<br><img src="/images/cv/47.jpg" srcset="/img/loading.gif" alt=""><br>莱布尼茨准则可得<br><img src="/images/cv/48.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/cv/49.jpg" srcset="/img/loading.gif" alt=""><br>p_s(s)为均匀概率密度函数，即证明经上述灰度变换函数T(r),得到随机变量s由均匀概率密度函数表征<br><img src="/images/cv/52.jpg" srcset="/img/loading.gif" alt=""><br>对于离散值,处理其概率(直方图值)与求和代替处理概率密度函数与积分<br>一幅数字图像中灰度级r_k出现的概率近视为<br><img src="/images/cv/53.jpg" srcset="/img/loading.gif" alt=""><br>变换函数为<br><img src="/images/cv/54.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>例子</strong><br><img src="/images/cv/55.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/cv/56.jpg" srcset="/img/loading.gif" alt=""><br>均衡后的图像中有790个像素取s0=1值,同理有1023个像素取s1=3值,….<br><img src="/images/cv/57.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="直方图规定化"><a href="#直方图规定化" class="headerlink" title="直方图规定化"></a>直方图规定化</h4><p>直方图规定化是指经过处理后的图像具有规定的直方图形状<br>令p_r(r)为输入图像估计,p_z(z)为图像所具有的指定概率密度函数<br>有如下变换函数T(r)<br><img src="/images/cv/47.jpg" srcset="/img/loading.gif" alt=""><br>定义有如下特性的随机变量z<br><img src="/images/cv/58.jpg" srcset="/img/loading.gif" alt=""><br>由G(z) = T(r)，z必须满足如下条件<br><img src="/images/cv/59.jpg" srcset="/img/loading.gif" alt=""><br>由一幅给定图像得到一幅其灰度级具有指定概率密度函数图像的步骤:<br>1.有输入图像得到p_r(r)，并由T(r)求得s值<br>2.由指定的PDF求得G(z)<br>3.求得G(z)的反函数z = G^{-1}(s)<br>4.利用T(r)对输入图像进行均衡得到输出图像,对均衡后的图像中具有s值的每个像素<br>   执行反函数z = G^{-1}(s)<br>对于离散值:<br><img src="/images/cv/54.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/cv/60.jpg" srcset="/img/loading.gif" alt=""><br>对一个q值:<br><img src="/images/cv/61.jpg" srcset="/img/loading.gif" alt=""><br>反函数为:<br><img src="/images/cv/62.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>例子</strong><br><img src="/images/cv/55.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/cv/63.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/cv/64.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/cv/65.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/cv/66.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/cv/67.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="空间滤波"><a href="#空间滤波" class="headerlink" title="空间滤波"></a>空间滤波</h3><p>空间滤波器由一个邻域(较小的矩形)和对该邻域包围的图像像素执行预定义操作组成,滤波产生一个新像素,新像素的坐标等于邻域中心的坐标,像素值是滤波操作的结果.滤波器在图像上执行的是线性操作则称为线性空间滤波器,否则称为非线性空间滤波器.<br>例如,如下3 x 3领域的线性空间滤波器的处理机理，在图像中任意一点(x,y),滤波器的响应g(x,y)是滤波器系数与该滤波器包围的图像像素的乘积之和:<br><img src="/images/cv/68.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/cv/69.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="空间相关与卷积"><a href="#空间相关与卷积" class="headerlink" title="空间相关与卷积"></a>空间相关与卷积</h4><p>相关是滤波器模板移过图像并计算每个位置乘积之和的处理,卷积的机理类似,但其滤波器首先要旋转180°<br>如下,显示了一个一维图像函数和一个一维滤波器,执行操作时,存在未覆盖的的部分函数,若滤波器的尺寸为m，则在需要在f的一侧补m-1个0<br><img src="/images/cv/70.jpg" srcset="/img/loading.gif" alt=""><br>二维图像函数和二维滤波器<br><img src="/images/cv/71.jpg" srcset="/img/loading.gif" alt=""><br><strong>总结</strong><br>大小为m x n的滤波器和一幅图像f(x,y)做相关操作,可表示为:<br>a = (m-1)/2,b = (n-1)/2 ，为表示方便,假设m和n是奇整数<br><img src="/images/cv/72.jpg" srcset="/img/loading.gif" alt=""><br>类似地，卷积表示为:<br><img src="/images/cv/73.jpg" srcset="/img/loading.gif" alt=""></p><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>数字图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode(10) Binary Gap</title>
    <link href="/2018/07/18/leetcode(10)%20Binary%20Gap/"/>
    <url>/2018/07/18/leetcode(10)%20Binary%20Gap/</url>
    
    <content type="html"><![CDATA[<p>difficult：easy #868<br>Given a positive integer N, find and return the longest distance between two consecutive 1’s in the binary representation of N.<br>If there aren’t two consecutive 1’s, return 0.</p><p>Example 1:</p><pre><code class="lang-cpp">Input: 22Output: 2</code></pre><p>Explanation:<br>22 in binary is 0b10110.<br>In the binary representation of 22, there are three ones, and two consecutive pairs of 1’s.<br>The first consecutive pair of 1’s have distance 2.<br>The second consecutive pair of 1’s have distance 1.<br>The answer is the largest of these two distances, which is 2.</p><p>Example 2:</p><pre><code class="lang-cpp">Input: 5Output: 2</code></pre><p>Explanation:<br>5 in binary is 0b101.</p><p>Example 3:</p><pre><code class="lang-cpp">Input: 6Output: 1</code></pre><p>Explanation:<br>6 in binary is 0b110.</p><p>Example 4:</p><pre><code class="lang-cpp">Input: 8Output: 0</code></pre><p>Explanation:<br>8 in binary is 0b1000.<br>There aren’t any consecutive pairs of 1’s in the binary representation of 8, so we return 0.<br>Note:1 &lt;= N &lt;= 10^9</p><p><strong>解法一:</strong></p><pre><code class="lang-cpp">#include&lt;vector&gt;int binaryGap(int N) {    int distance = 0;    std::vector&lt;int&gt; index;    for (int i = 1; N != 0;i++) {        if (N % 2 != 0)            index.push_back(i);        N = N &gt;&gt; 1;    }    for(int i = 0;i &lt; index.size()-1;i++){        int max = index[i + 1] - index[i];        if (max &gt; distance)            distance = max;    }    return distance;}</code></pre><p><strong>解法二:</strong></p><pre><code class="lang-cpp">int binaryGap(int N) {    int last = -1,distance = 0;    for (int i = 1; N != 0; i++) {        if (N % 2 != 0) {            if (last &gt; 0)                distance = (i - last) &gt; distance ? (i - last) : distance;            last = i;        }        N = N &gt;&gt; 1;    }    return distance;}</code></pre><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode(9) Array Partition I</title>
    <link href="/2018/07/18/leetcode(9)%20Array%20Partition%20I/"/>
    <url>/2018/07/18/leetcode(9)%20Array%20Partition%20I/</url>
    
    <content type="html"><![CDATA[<p>difficult：easy #561<br>Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.</p><p>Example 1:<br>Input: [1,4,3,2]</p><p>Output: 4<br>Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).<br>Note:<br>n is a positive integer, which is in the range of [1, 10000].<br>All the integers in the array will be in the range of [-10000, 10000].</p><p><strong>解法:</strong></p><pre><code class="lang-cpp">#include&lt;vector&gt;void quicksort(std::vector&lt;int&gt; &amp; array, int left, int right);int arrayPairSum(std::vector&lt;int&gt;&amp; nums) {    int result = 0;    quicksort(nums, 0, nums.size() - 1);    for (int i = 0; i &lt; nums.size(); i += 2) {        result += nums[i];    }    return result;}void quicksort(std::vector&lt;int&gt; &amp; array, int left, int right){    int i, j, t, temp;    if (left &gt; right)        return;    temp = array[left];    i = left;    j = right;    while (i != j){        while (array[j] &gt;= temp &amp;&amp; i &lt; j)            j--;        while (array[i] &lt;= temp &amp;&amp; i &lt; j)            i++;        if (i&lt;j) {            t = array[i];            array[i] = array[j];            array[j] = t;        }    }    array[left] = array[i];    array[i] = temp;    quicksort(array, left, i - 1);    quicksort(array, i + 1, right);}</code></pre><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode(8) SelfDividingNumbers</title>
    <link href="/2018/07/16/leetcode(8)%20SelfDividingNumbers/"/>
    <url>/2018/07/16/leetcode(8)%20SelfDividingNumbers/</url>
    
    <content type="html"><![CDATA[<p>difficult：easy #728<br>A self-dividing number is a number that is divisible by every digit it contains.<br>For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.<br>Also, a self-dividing number is not allowed to contain the digit zero.<br>Given a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.</p><p>Example :</p><pre><code class="lang-cpp">Input: left = 1, right = 22Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]</code></pre><p>Note:<br>The boundaries of each input argument are 1 &lt;= left &lt;= right &lt;= 10000</p><p><strong>解法一：</strong></p><pre><code class="lang-cpp">#include&lt;vector&gt;std::vector&lt;int&gt; selfDividingNumbers(int left, int right) {    std::vector&lt;int&gt; result;    while (left &lt;= right){        int x = left;        bool flag = true;        while (x != 0 &amp;&amp; flag){            int pos = x % 10;            if (pos == 0){                flag = false;                break;            }            if (left % pos != 0) {                flag = false;            }            x = x / 10;        }        if (flag)            result.push_back(left);        left++;    }    return result;}</code></pre><p><strong>解法二:</strong></p><pre><code class="lang-cpp">#include&lt;vector&gt;#include&lt;sstream&gt;#include &lt;string&gt;std::vector&lt;int&gt; selfDividingNumbers(int left, int right) {    std::vector&lt;int&gt; result;    while (left &lt;= right) {        std::string str;        std::stringstream buf;        buf &lt;&lt; left;        buf &gt;&gt; str;        bool flag = true;        for(char c : str){            if (c == &#39;0&#39; || left % (c - &#39;0&#39;) &gt; 0){                flag = false;                break;            }        }        if (flag){            result.push_back(left);        }        left++;    }    return result;}</code></pre><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字图像处理(1) 图像基础</title>
    <link href="/2018/07/13/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86(1)%20%E5%9B%BE%E5%83%8F%E5%9F%BA%E7%A1%80/"/>
    <url>/2018/07/13/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86(1)%20%E5%9B%BE%E5%83%8F%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="图像采样和量化"><a href="#图像采样和量化" class="headerlink" title="图像采样和量化"></a>图像采样和量化</h3><p><img src="/images/cv/6.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="图像采样"><a href="#图像采样" class="headerlink" title="图像采样"></a>图像采样</h4><p>数字化坐标值称为采样,对二维空间中连续的图像在水平和垂直方向上等间距地分割成矩形网状结构，所形成的微小方格称为像素点,小方格中的值由灰度值(方格区域亮度的平均值)表示,采样的实质就是用多少个像素点来描述一幅图像.<br>采样时，若横向的像素数(列数)为M,纵向的像素数(行数)为N,则图像总像素数为M*N个像素；</p><p>采样间隔越大，即行列数少,则图像像素数越少，空间分辨率低，质量差，严重时出现马赛克效应；<br>采样间隔越小，即行列数大,则图像像素数越多，空间分辨率高，图像质量好，数据量大；<br>如下图,上述采样点分别为a:1024x1024 , b:512x512 , c:256x256 , d:128x128 , e:64x64, f:32x32<br><img src="/images/cv/1.png" srcset="/img/loading.gif" alt=""></p><p>采样过程:<br><img src="/images/cv/2.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/cv/4.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="图像量化"><a href="#图像量化" class="headerlink" title="图像量化"></a>图像量化</h4><p>采样后所得各像素的灰度模拟量到离散量的转换为图像灰度量化<br>像素灰度级/灰度值/灰度:表示像素明暗程度的整数<br>灰度级数:数字图像中不同灰度值的个数(G）<br>若连续的灰度值用<script type="math/tex">z</script>表示,则满足于z<em>{i} &lt; z &lt; z</em>{i+1} 的z值都量化为整数值z<em>{i}，z</em>{i}称为像素灰度值<br>量化后的的灰度值用比特位数(g:存储图像灰度值所需的比特位数)表示,即$G=2^{g}$,如黑-灰-白的连续变化灰度值,用8位比特量化则为0~255个灰度值,代表相应的浓淡程度<br><img src="/images/cv/5.jpg" srcset="/img/loading.gif" alt=""><br>图像的数据量 = M x N x G bit</p><p>数字图像根据灰度级数的差异可分为黑白图像、灰度图像、彩色图像</p><ul><li>黑白图像<br>图像的每个灰度值/像素只能是黑或白,无中间值的过渡,故称二值图,灰度级数为2,灰度值为0或1<br><img src="/images/cv/7.jpg" srcset="/img/loading.gif" alt=""></li><li>灰度图像<br>图像的灰度级数大于2,但不包含彩色信息<br><img src="/images/cv/8.jpg" srcset="/img/loading.gif" alt=""></li><li>彩色图像<br>每个灰度值由R、G、B分量构成,其中R、G、B由不同的灰度值来描述<br><img src="/images/cv/9.jpg" srcset="/img/loading.gif" alt=""></li></ul><p>量化等级越高,图像层次越丰富图像质量越好,反之图像质量差,如下图,量化等级依次递减所得的图像<br><img src="/images/cv/11.jpg" srcset="/img/loading.gif" alt=""></p><hr><h3 id="数字图像表示"><a href="#数字图像表示" class="headerlink" title="数字图像表示"></a>数字图像表示</h3><p>一幅M×N的图像可以表示为矩阵,矩阵中的每个元素为图像的灰度值(像素值)<br><img src="/images/cv/10.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="空间和灰度分辨率"><a href="#空间和灰度分辨率" class="headerlink" title="空间和灰度分辨率"></a>空间和灰度分辨率</h3><p>空间分辨率是图像中可辨别最小细节的度量,其中每单位距离线对数和每单位距离点数(像素数)是最通用的度量 —— 采样程度<br>灰度分辨率是指在灰度级中可分辨的最小变化 —— 量化程度</p><h3 id="图像内插"><a href="#图像内插" class="headerlink" title="图像内插"></a>图像内插</h3><p>图像内插是在诸如放大、收缩、旋转和几何校正等任务中广泛应用的工具<br>从根本上看,内插是用已知数据来估计未知位置数值的处理<br>源图像大小为M * N,目标图像为A * B,则两幅图像的边长比分别为:M/A和N/B,目标图像(i,j)像素可通过边长比对应回源图像,其对应坐标为(i * M / A,j * N / B)，显然,对应的坐标一般不是整数，而非整数的坐标无法在图像上使用.</p><h4 id="最近邻内插法"><a href="#最近邻内插法" class="headerlink" title="最近邻内插法"></a>最近邻内插法</h4><p>假设一幅500x500的图像放大1.5倍到750x750，创建一个750x750的网格,其与原图有相同的间隔,然后将其收缩,使它准确地与原图匹配,显然收缩后的750x750网格的像素间隔小于原图的像素间隔,为了覆盖的每一个点赋以灰度值,因此在原图中寻找最接近的像素,并把该像素的灰度值赋给750x750网格中的新像素,完成像素的赋值后,再将图像扩展到规定的大小.<br>蓝色为原图网格,红色为放大后的网格<br><img src="/images/cv/12.jpg" srcset="/img/loading.gif" alt=""><br>取最近的像素灰度值赋值给新像素<br><img src="/images/cv/13.jpg" srcset="/img/loading.gif" alt=""></p><p>C++代码实现</p><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;opencv2\opencv.hpp&gt;using namespace cv;int main() {    Mat src = imread(&quot;D:/learn/jiaopan/source/images/opencv3/blob.jpg&quot;);//原图    imshow(&quot;src&quot;, src);    std::cout &lt;&lt; src.rows;    //创建网格矩阵    Mat dst = Mat::zeros(Size(750, 750), CV_8UC3);    //放大比例    double fRows = 750 / (float)src.rows;    double fCols = 750 / (float)src.cols;    int primaryX = 0, primaryY = 0;    //最近邻内插法    for (int i = 0; i != dst.rows; i++) {        for (int j = 0; j != dst.cols; j++){            primaryX = cvRound(i / (double)fRows);            primaryY = cvRound(j / (double)fCols);            if (primaryX &lt; src.rows &amp;&amp; primaryX &gt;= 0 &amp;&amp; primaryY &gt;= 0 &amp;&amp; primaryY &lt; src.cols){                dst.at&lt;cv::Vec3b&gt;(i, j)[0] = src.at&lt;cv::Vec3b&gt;(primaryX, primaryY)[0];                dst.at&lt;cv::Vec3b&gt;(i, j)[1] = src.at&lt;cv::Vec3b&gt;(primaryX, primaryY)[1];                dst.at&lt;cv::Vec3b&gt;(i, j)[2] = src.at&lt;cv::Vec3b&gt;(primaryX, primaryY)[2];            }        }    }    imshow(&quot;dst&quot;, dst);    waitKey(0);    return 0;}</code></pre><p><img src="/images/cv/14.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="双线性插值"><a href="#双线性插值" class="headerlink" title="双线性插值"></a>双线性插值</h4><p>双线性插值通过寻找距离对应坐标最近的四个像素点计算该点灰度值或者RGB值,如对应坐标是(2.5,4.5)，则最近的四个像素为 (2,4) , (2,5) , (3,4) , (3,5).<br>如图，已知Q11  (x1, y1), Q12  (x1, y2), Q21 (x2, y1),  Q22  (x2, y2)，插值的点为P点<br><img src="/images/cv/15.png" srcset="/img/loading.gif" alt=""><br>X方向<br><img src="/images/cv/16.svg" srcset="/img/loading.gif" alt=""><br>Y方向<br><img src="/images/cv/18.svg" srcset="/img/loading.gif" alt=""><br>先在 x 方向插值，再在 y 方向插值，其结果与按照上述顺序双线性插值的结果一致<br>若四个已知点坐标分别为 (0, 0)、(0, 1)、(1, 0) 和 (1, 1)，插值公式可化简为<br><img src="/images/cv/19.svg" srcset="/img/loading.gif" alt=""><br>其矩阵运算公式为<br><img src="/images/cv/20.svg" srcset="/img/loading.gif" alt=""></p><p>双线性插值的结果不是线性的，它是两个线性函数的积，在单位正方形上，双线性插值可以记作<br><img src="/images/cv/22.svg" srcset="/img/loading.gif" alt=""><br><img src="/images/cv/23.jpg" srcset="/img/loading.gif" alt=""><br>一般情况:<br><img src="/images/cv/21.png" srcset="/img/loading.gif" alt=""></p><p>代码实现</p><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;opencv2\opencv.hpp&gt;using namespace cv;int main() {    Mat src = imread(&quot;D:/learn/jiaopan/source/images/opencv3/blob.jpg&quot;);//原图    imshow(&quot;src&quot;, src);    //创建网格矩阵    Mat dst = Mat::zeros(Size(750, 750), CV_8UC3);    //放大比例    double fRows = 750 / (float)src.rows;    double fCols = 750 / (float)src.cols;    int primaryX = 0, primaryY = 0;    //双线性插值    float m = 0;    float n = 0;    CvScalar a, b, c, d;    for (int i = 0; i != dst.rows; i++) {        for (int j = 0; j != dst.rows; j++) {            m = cvRound(i / (double)fRows);            n = cvRound(j / (double)fCols);            double ux = m - (int)m;            double uy = n - (int)n;            if (m &gt;= 0 &amp;&amp; m &lt;= src.rows - 1 &amp;&amp; n &gt;= 0 &amp;&amp; n &lt;= src.cols - 1) {                a = src.at&lt;cv::Vec3b&gt;((int)m, (int)n);                b = src.at&lt;cv::Vec3b&gt;((int)m, (int)n + 1) - src.at&lt;cv::Vec3b&gt;((int)m, (int)n);                c = src.at&lt;cv::Vec3b&gt;((int)m + 1, (int)n) - src.at&lt;cv::Vec3b&gt;((int)m, (int)n);                d = src.at&lt;cv::Vec3b&gt;((int)m + 1, (int)n + 1) - src.at&lt;cv::Vec3b&gt;((int)m + 1, (int)n) - src.at&lt;cv::Vec3b&gt;((int)m, (int)n + 1) + src.at&lt;cv::Vec3b&gt;((int)m, (int)n);                b.val[0] = b.val[0] * uy;                b.val[1] = b.val[1] * uy;                b.val[2] = b.val[2] * uy;                c.val[0] = c.val[0] * ux;                c.val[1] = c.val[1] * ux;                c.val[2] = c.val[2] * ux;                d.val[0] = d.val[0] * ux*uy;                d.val[1] = d.val[1] * ux*uy;                d.val[2] = d.val[2] * ux*uy;            }            dst.at&lt;cv::Vec3b&gt;(i, j)[0] = (int)(a.val[0] + b.val[0] + c.val[0] + d.val[0]);            dst.at&lt;cv::Vec3b&gt;(i, j)[1] = (int)(a.val[1] + b.val[1] + c.val[1] + d.val[1]);            dst.at&lt;cv::Vec3b&gt;(i, j)[2] = (int)(a.val[2] + b.val[2] + c.val[2] + d.val[2]);        }    }    imshow(&quot;dst&quot;, dst);    waitKey(0);    return 0;}</code></pre><p><img src="/images/cv/24.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="双三次内插"><a href="#双三次内插" class="headerlink" title="双三次内插"></a>双三次内插</h4><p>双三次内插包括16个最近邻点,在保持细节方面比双线性内插更好<br><img src="/images/cv/27.png" srcset="/img/loading.gif" alt=""><br><a href="https://en.wikipedia.org/wiki/Bicubic_interpolation" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bicubic_interpolation</a></p><h3 id="像素间的基本关系"><a href="#像素间的基本关系" class="headerlink" title="像素间的基本关系"></a>像素间的基本关系</h3><h4 id="相邻像素"><a href="#相邻像素" class="headerlink" title="相邻像素"></a>相邻像素</h4><p>位于坐标(x,y)处的像素p有4个水平和垂直的相邻像素(4邻域 N4(p)),其坐标公式如下</p><pre><code class="lang-cpp">(x+1,y),(x-1,y),(x,y+1),(x,y-1)</code></pre><p>p的4个对角相邻像素(对角邻域)的坐标公式如下:</p><pre><code class="lang-cpp">(x+1,y+1),(x+1,y-1),(x-1,y+1),(x-1,y-1)</code></pre><h4 id="邻接性"><a href="#邻接性" class="headerlink" title="邻接性"></a>邻接性</h4><p>令V是用于定义邻接性的灰度值集合,在二值图像中,把具有1值的像素归为邻接像素,则V = {1}<br><img src="/images/cv/28.png" srcset="/img/loading.gif" alt=""><br>4邻接:若q在集合N4(p)中，则具有V中数值(1)的两个像素p和q是4邻接<br>8邻接:若q在集合N8(p)中，则具有V中数值(1)的两个像素p和q是8邻接(8邻域=4邻域+对角邻域）<br>m邻接:若q在N4(p)中，或者在ND(p)中，且集合N4(p) ∩ N4(q) 没有V中数值(1)的像素，则具有V中数值的两个像素p和q是m邻接的</p><h4 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a>距离度量</h4><p>对于像素p、q和z，分别具有坐标(x,y)，(s,t)和(u,v)，若<br>(1) D(p,q) ≥ 0 (D(p,q)=0，当且仅当p =q)<br>(2) D(p,q) = D(q,p)<br>(3) D(p,z) ≤ D(p,q) + D(q,z)<br>则称D是距离函数或度量</p><h5 id="欧式距离"><a href="#欧式距离" class="headerlink" title="欧式距离"></a>欧式距离</h5><p><img src="/images/cv/29.jpg" srcset="/img/loading.gif" alt=""><br>距离点(x,y)的距离小于或等于某个值r的像素点是在圆心为(x,y)且半径为r的圆平面内</p><h5 id="城市距离"><a href="#城市距离" class="headerlink" title="城市距离"></a>城市距离</h5><p><img src="/images/cv/30.jpg" srcset="/img/loading.gif" alt=""><br>距离点(x,y)的距离小于或等于某个值r的像素点形成一个中心为(x,y)的菱形<br>如图,与点(x,y)的距离小于或等于2的像素<br><img src="/images/cv/31.jpg" srcset="/img/loading.gif" alt=""></p><h5 id="棋盘距离"><a href="#棋盘距离" class="headerlink" title="棋盘距离"></a>棋盘距离</h5><p><img src="/images/cv/32.jpg" srcset="/img/loading.gif" alt=""><br>距离点(x,y)的距离小于或等于某个值r的像素点形成一个中心为(x,y)的方形<br>如图,与点(x,y)的距离小于或等于2的像素<br><img src="/images/cv/33.jpg" srcset="/img/loading.gif" alt=""></p><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>数字图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>blob detect</title>
    <link href="/2018/07/12/blob%20detect/"/>
    <url>/2018/07/12/blob%20detect/</url>
    
    <content type="html"><![CDATA[<h3 id="斑点检测"><a href="#斑点检测" class="headerlink" title="斑点检测"></a>斑点检测</h3><p>斑点:与周围区域存在颜色差异或灰度差异的区域<br>斑点检测的主要思路是检测出图像中比周围像素灰度大或者比周围区域灰度值小的区域<br>　　1.基于求导的微分方法<br>　　2.基于局部极值的分水岭算法,基于此OPENCV中提供simpleBlobDetector特征检测器</p><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;opencv2\opencv.hpp&gt;using namespace cv;int main() {    Mat im = imread(&quot;D:/learn/jiaopan/source/images/opencv3/blob.jpg&quot;,IMREAD_GRAYSCALE);    imshow(&quot;im&quot;, im);    Ptr&lt;SimpleBlobDetector&gt; detector = SimpleBlobDetector::create();    std::vector&lt;KeyPoint&gt; keypoints;    detector-&gt;detect(im, keypoints);    Mat im_with_keypoints;    drawKeypoints(im, keypoints, im_with_keypoints, Scalar(0, 255, 0), DrawMatchesFlags::DRAW_RICH_KEYPOINTS);    imshow(&quot;keypoints&quot;, im_with_keypoints);    waitKey(0);    return 0;}</code></pre><p>原图<br><img src="/images/opencv3/blob.jpg" srcset="/img/loading.gif" alt=""><br>灰度图<br><img src="/images/opencv3/blob2.jpg" srcset="/img/loading.gif" alt=""><br>斑点检测图<br><img src="/images/opencv3/blob3.jpg" srcset="/img/loading.gif" alt=""></p><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>opencv3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>opencv samples</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode(7) PeakIndexInMountainArray</title>
    <link href="/2018/07/12/leetcode(7)%20PeakIndexInMountainArray/"/>
    <url>/2018/07/12/leetcode(7)%20PeakIndexInMountainArray/</url>
    
    <content type="html"><![CDATA[<p>difficult：easy #852<br>Let’s call an array A a mountain if the following properties hold:</p><ul><li>A.length &gt;= 3</li><li>There exists some 0 &lt; i &lt; A.length - 1 such that A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]<br>Given an array that is definitely a mountain, return any i such that A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1].</li></ul><pre><code class="lang-cpp">Example 1:Input: [0,1,0]Output: 1Example 2:Input: [0,2,1,0]Output: 1</code></pre><p>Note:<br>3 &lt;= A.length &lt;= 10000<br>0 &lt;= A[i] &lt;= 10^6<br>A is a mountain, as defined above.</p><p><strong>解法一:</strong></p><pre><code class="lang-cpp">#include&lt;vector&gt;int peakIndexInMountainArray(std::vector&lt;int&gt;&amp; A) {    int start = (A.size() - 1) / 2;    while (start != 0 || start != A.size() - 1) {        if (A[start - 1] &lt; A[start] &amp;&amp; A[start] &lt; A[start + 1])            start++;        else if (A[start - 1] &gt; A[start] &amp;&amp; A[start] &gt; A[start + 1])            start--;        else if (A[start - 1] &lt;= A[start] &amp;&amp; A[start] &gt;= A[start + 1])            return start;    }}</code></pre><p><strong>解法二(二分查找):</strong></p><pre><code class="lang-cpp">int peakIndexInMountainArray(std::vector&lt;int&gt;&amp; A) {    int start = 0, end = A.size() - 1;    while (start &lt; end){        int mid = start +(end-start) / 2;        if (A[mid] &lt; A[mid + 1])            start = mid + 1;        else            end = mid;    }    return start;}</code></pre><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode(6)  JudgeRouteCircle</title>
    <link href="/2018/07/11/leetcode(6)%20%20JudgeRouteCircle/"/>
    <url>/2018/07/11/leetcode(6)%20%20JudgeRouteCircle/</url>
    
    <content type="html"><![CDATA[<p>difficult：easy #657<br>Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place.</p><p>The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle.</p><p>Example 1:</p><pre><code class="lang-cpp">Input: &quot;UD&quot;Output: true</code></pre><p>Example 2:</p><pre><code class="lang-cpp">Input: &quot;LL&quot;Output: false</code></pre><p><strong>解法一：</strong></p><pre><code class="lang-cpp">#include&lt;string&gt;#include&lt;map&gt;bool judgeCircle(std::string moves) {    std::map&lt;char, int&gt; action = { {&#39;R&#39;,0},{&#39;L&#39;,0},{&#39;U&#39;,0},{&#39;D&#39;,0} };    for (int i = 0; i &lt; moves.size(); i++) {        action[moves[i]]++;    }    return action[&#39;R&#39;] == action[&#39;L&#39;] &amp;&amp; action[&#39;U&#39;] == action[&#39;D&#39;];}</code></pre><p><strong>解法二：</strong></p><pre><code class="lang-cpp">#include&lt;string&gt;#include&lt;map&gt;bool judgeCircle(std::string moves) {    int x = 0, y = 0;    for (char move:moves) {        if (move == &#39;U&#39;) y--;        else if (move == &#39;D&#39;) y++;        else if (move == &#39;R&#39;) x--;        else if (move == &#39;L&#39;) x++;    }    return x == 0 &amp;&amp; y == 0;}</code></pre><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>opencv3(3) opencv数据类型</title>
    <link href="/2018/07/10/opencv3(3)%20opencv%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2018/07/10/opencv3(3)%20opencv%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><ul><li>Point 坐标类<br>Point有两种,2维Point和3维Point，Point可以转换为其他数据类型,比如vector或者matrix<br><img src="/images/opencv3/22.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"></li><li>Scala<br>Scalar继承于vector<br>Scalar(b, g, r) ：b-&gt;蓝色分量 g-&gt;绿色分量 r-&gt;红色分量<br>Scalar(0, 0, 255) -&gt; 红色像素点<br><img src="/images/opencv3/23.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"></li><li>Size 大小类<br>Size和Point类似,两者可以互相转换,不同之处在于Point的数据成员名为x和y,Size的数据成员名为width和height<br><img src="/images/opencv3/24.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"></li><li>Rect 矩形类<br>Rect成员包含Point类型的x,y和Size类型的width,height<br><img src="/images/opencv3/25.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"></li><li>RotatedRect 旋转矩形类<br>RotatedRect包含中心点(Point),大小(Size),旋转角度<br><img src="/images/opencv3/26.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"></li><li>InputArray OutputArray<br>InputArray和OutputArray区别在于 InputArray为只读,上述基础数据类型都可转换为 InputArray或OutputArray,以此保持函数的简洁性<h3 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h3><img src="/images/opencv3/27.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"><br><img src="/images/opencv3/28.jpg" srcset="/img/loading.gif" alt="&quot;opencv&quot;"></li><li>cv::alignPtr() 指针对齐<pre><code class="lang-cpp">// Return aligned pointer of type T*template&lt;T&gt; T* cv::alignPtr( T* ptr, // pointer, unaligned                                               int n = sizeof(T)); // align to block size, a power of 2</code></pre></li><li>cv::allocate() 分配具有T类型的对象数组(C风格）<pre><code class="lang-cpp">// Return pointer to allocated buffertemplate&lt;T&gt; T* cv::allocate( size_t sz); // buffer size, multiples of sizeof(T)</code></pre></li><li>cv::fastAtan2() 计算向量方向 x(向量的x坐标) y(向量的y坐标)<pre><code class="lang-cpp">float cv::fastAtan2(float y, float x );</code></pre></li><li>cvCeil() 返回不小于x的最小整数值<pre><code class="lang-cpp">int cvCeil(float x);</code></pre></li><li>cvRound() 返回与x最接近的整数值<pre><code class="lang-cpp">int cvRound( double x );</code></pre></li><li>cvFloor() 返回不大于x的最大整数值<pre><code class="lang-cpp">int cvFloor( float x};</code></pre></li><li>cv::cubeRoot() 计算x的立方根<pre><code class="lang-cpp">float cv::cubeRoot( float x);</code></pre></li><li>cv::format() 格式化输出<pre><code class="lang-cpp">string cv::format(const char* fmt, ... );</code></pre></li></ul><hr><h3 id="帮助类"><a href="#帮助类" class="headerlink" title="帮助类"></a>帮助类</h3><ul><li>TermCriteria 算法终止条件类<br>TermCriteria( int type, int maxCount, double epsilon) 类型 迭代次数 超参数</li><li>Range 整数序列<br>Range(0,4) —-&gt; 0,1,2,3</li></ul><hr><h3 id="Mat-N维稠密矩阵"><a href="#Mat-N维稠密矩阵" class="headerlink" title="Mat N维稠密矩阵"></a>Mat N维稠密矩阵</h3><h4 id="构造矩阵"><a href="#构造矩阵" class="headerlink" title="构造矩阵"></a>构造矩阵</h4><pre><code class="lang-cpp">Mat();Mat(int rows, int cols, int type);Mat(Size size, int type);Mat(int rows, int cols, int type, const Scalar&amp; s);Mat(Size size, int type, const Scalar&amp; s);Mat(int ndims, const int* sizes, int type);Mat(int ndims, const int* sizes, int type, const Scalar&amp; s);Mat(const Mat&amp; m);Mat(const Mat&amp; m, const Rect&amp; roi);Mat(const Mat&amp; m, const Range* ranges);</code></pre><p>int rows, int cols:二维矩阵的行列数 -&gt;图像分辨率<br>int type：存储元素的数据类型和通道数 CV_[位数][是否带符号][类型前缀]C[通道数]<br>const Scalar&amp; s:矩阵每个元素以s向量(颜色)填充 向量维度由通道数决定</p><pre><code class="lang-cpp">Mat matrix(2, 2, CV_8UC3, Scalar(0, 0, 255));Mat matrix(2, 2, CV_8UC2, Scalar(1,2));</code></pre><p>matrix = [  0,   0, 255,   0,   0, 255 ;  0,   0, 255,   0,   0, 255]<br>matrix = [  1,   2,   1,   2 ; 1,   2,   1,   2]</p><pre><code class="lang-cpp">Mat m；m.create(3,10,CV_32FC3)m.setTo(Scalar(1.0f,1.0f,1.0f));//设置第一个通道的值</code></pre><pre><code class="lang-cpp">Mat matrix = Mat::eye(4, 4, CV_64F);Mat matrix = Mat::ones(4, 4, CV_32F);Mat matrix = Mat::zeros(3, 3, CV_8SC1);</code></pre><p>[1, 0, 0, 0;<br> 0, 1, 0, 0;<br> 0, 0, 1, 0;<br> 0, 0, 0, 1]<br>[1, 1, 1, 1;<br> 1, 1, 1, 1;<br> 1, 1, 1, 1;<br> 1, 1, 1, 1]<br>[  0,   0,   0;<br>0,   0,   0;<br>0,   0,   0]</p><pre><code class="lang-cpp">Mat matrix = (Mat_&lt;double&gt;(3, 3) &lt;&lt; 1, 2, 3, 4, 5, 6, 7, 8, 9);</code></pre><p>[1, 2, 3;<br> 4, 5, 6;<br> 7, 8, 9]</p><p>利用clone() 或者 copyTo()</p><pre><code class="lang-cpp">Mat RowClone = matrix.row(1).clone();cout &lt;&lt; &quot;RowClone = &quot; &lt;&lt; endl &lt;&lt; &quot; &quot; &lt;&lt; RowClone &lt;&lt; endl &lt;&lt; endl;</code></pre><h4 id="获取矩阵元素"><a href="#获取矩阵元素" class="headerlink" title="获取矩阵元素"></a>获取矩阵元素</h4><p><img src="/images/opencv3/29.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/opencv3/30.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h4><p><img src="/images/opencv3/31.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="矩阵操作"><a href="#矩阵操作" class="headerlink" title="矩阵操作"></a>矩阵操作</h4><p><img src="/images/opencv3/32.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/opencv3/33.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="打印矩阵"><a href="#打印矩阵" class="headerlink" title="打印矩阵"></a>打印矩阵</h4><pre><code class="lang-cpp">Mat matrix(2,2, CV_8UC3, Scalar(0,0,255));</code></pre><p>默认风格</p><pre><code class="lang-cpp">std::cout &lt;&lt; matrix &lt;&lt; std::endl;</code></pre><p>[  0,   0, 255,   0,   0, 255;<br>   0,   0, 255,   0,   0, 255]</p><p>Python风格</p><pre><code class="lang-cpp">std::cout &lt;&lt; format(matrix,Formatter::FMT_PYTHON) &lt;&lt; std::endl;</code></pre><p>[[[  0,   0, 255],<br>  [  0,   0, 255]],<br> [[  0,   0, 255],<br>  [  0,   0, 255]]]</p><p>Numpy风格</p><pre><code class="lang-cpp">std::cout &lt;&lt; format(matrix, Formatter::FMT_NUMPY) &lt;&lt; std::endl;</code></pre><p>array([[[  0,   0, 255], [  0,   0, 255], [  0,   0, 255]],<br>       [[  0,   0, 255], [  0,   0, 255], [  0,   0, 255]],<br>       [[  0,   0, 255], [  0,   0, 255], [  0,   0, 255]]], dtype=’uint8’)</p><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>opencv3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>opencv3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode(5)  HammingDistance</title>
    <link href="/2018/07/10/leetcode(5)%20%20HammingDistance/"/>
    <url>/2018/07/10/leetcode(5)%20%20HammingDistance/</url>
    
    <content type="html"><![CDATA[<p>difficult：easy #461</p><p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p><p>Given two integers x and y, calculate the Hamming distance.</p><p>Example:</p><pre><code class="lang-cpp">Input: x = 1, y = 4Output: 2Explanation:1   (0 0 0 1)4   (0 1 0 0)       ↑    ↑</code></pre><p>The above arrows point to positions where the corresponding bits are different.<br><strong>解法一</strong></p><pre><code class="lang-cpp">int hammingDistance(int x, int y) {    int res = 0, exc = x ^ y;    while (exc){        ++res;        exc &amp;= (exc - 1);    }    return res;}</code></pre><p><strong>解法二</strong></p><pre><code class="lang-cpp">//递归法int hammingDistance(int x, int y) {    if ((x ^ y) == 0) return 0;    return (x ^ y) % 2 + hammingDistance(x / 2, y / 2);}</code></pre><p><strong>解法三</strong></p><pre><code class="lang-cpp">int hammingDistance(int x, int y) {    int result = x ^ y;    int binary = 0;    while (result) {        binary += result % 2;        result = result / 2;    }    return binary;}</code></pre><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode(4)  uniqueMorseCodeWords</title>
    <link href="/2018/07/10/leetcode(4)%20%20uniqueMorseCodeWords/"/>
    <url>/2018/07/10/leetcode(4)%20%20uniqueMorseCodeWords/</url>
    
    <content type="html"><![CDATA[<p>difficult：easy #804</p><p>International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: “a” maps to “.-“, “b” maps to “-…”, “c” maps to “-.-.”, and so on.</p><p>For convenience, the full table for the 26 letters of the English alphabet is given below:</p><pre><code class="lang-cpp">[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;]</code></pre><p>Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, “cab” can be written as “-.-.-….-“, (which is the concatenation “-.-.” + “-…” + “.-“). We’ll call such a concatenation, the transformation of a word.</p><p>Return the number of different transformations among all words we have.<br><strong>Example:</strong></p><pre><code class="lang-cpp">Input: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]Output: 2Explanation: The transformation of each word is:&quot;gin&quot; -&gt; &quot;--...-.&quot;&quot;zen&quot; -&gt; &quot;--...-.&quot;&quot;gig&quot; -&gt; &quot;--...--.&quot;&quot;msg&quot; -&gt; &quot;--...--.&quot;</code></pre><p>There are 2 different transformations, “—…-.” and “—…—.”.<br><strong>Note:</strong></p><pre><code class="lang-cpp">The length of words will be at most 100.Each words[i] will have length in range [1, 12].words[i] will only consist of lowercase letters.</code></pre><p><strong>解法1:</strong></p><pre><code class="lang-cpp">#include&lt;string&gt;#include&lt;vector&gt;#include&lt;set&gt;int uniqueMorseRepresentations(std::vector&lt;std::string&gt;&amp; words) {    std::vector&lt;std::string&gt; morse = { &quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot; };    std::set&lt;std::string&gt; seen;    for(std::string word:words){        std::string code;        for(char c : word){            code.append(morse[c - &#39;a&#39;]);//&#39;a&#39;-&gt;97        }        seen.insert(code);    }    return seen.size();}</code></pre><p><strong>解法2：</strong></p><pre><code class="lang-cpp">#include&lt;map&gt;#include&lt;string&gt;#include&lt;vector&gt;int uniqueMorseRepresentations(std::vector&lt;std::string&gt;&amp; words) {    std::string alpha = &quot;abcdefghijklmnopqrstuvwxyz&quot;;    std::vector&lt;std::string&gt; morse = { &quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot; };    std::map&lt;char, std::string&gt; alpha_code;    int index = 0;    for (auto i = alpha.begin(); i &lt; alpha.end(); i++) {        alpha_code[*i] = morse[index++];    }    std::set&lt;std::string&gt; seen;    for (std::string str : words) {        std::string str_code;        for (char c : str) {            str_code += alpha_code[c];        }        seen.insert(str_code);    }    return seen.size();}</code></pre><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode(3) Jewels and Stones</title>
    <link href="/2018/07/08/leetcode(3)%20Jewels%20and%20Stones/"/>
    <url>/2018/07/08/leetcode(3)%20Jewels%20and%20Stones/</url>
    
    <content type="html"><![CDATA[<p>difficult：easy #771</p><p>You’re given strings J representing the types of stones that are jewels, and S representing the stones you have.  Each character in S is a type of stone you have.  You want to know how many of the stones you have are also jewels.</p><p>The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so “a” is considered a different type of stone from “A”.<br>Example 1:</p><pre><code class="lang-cpp">Input: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;Output: 3</code></pre><p>Example 2:</p><pre><code class="lang-cpp">Input: J = &quot;z&quot;, S = &quot;ZZ&quot;Output: 0</code></pre><p>Note:<br>S and J will consist of letters and have length at most 50.<br>The characters in J are distinct.</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><pre><code class="lang-cpp">#include&lt;string&gt;int numJewelsInStones(std::string J, std::string S) {    int num = 0;    for (auto i = S.begin(); i &lt; S.end(); i++) {        if (J.find(*i) != std::string::npos)            num++;    }    return num;}</code></pre><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode(2) Reverse Integer</title>
    <link href="/2018/07/06/leetcode(2)%20Reverse%20Integer/"/>
    <url>/2018/07/06/leetcode(2)%20Reverse%20Integer/</url>
    
    <content type="html"><![CDATA[<p>difficult：easy #728<br>Given a 32-bit signed integer, reverse digits of an integer.<br>Example 1:</p><pre><code class="lang-cpp">Input: 123Output: 321</code></pre><p>Example 2:</p><pre><code class="lang-cpp">Input: -123Output: -321</code></pre><p>Example 3:</p><pre><code class="lang-cpp">Input: 120Output: 21</code></pre><p>Note:<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−$2^{31}$ , $2^{31}$ − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><pre><code class="lang-cpp">int reverse(int x) {    int result = 0;    while (x != 0 ) {        int num = x % 10;        if (result &gt; INT_MAX / 10 || (result == INT_MAX / 10 &amp;&amp; num &gt; 7)) return 0;        if (result &lt; INT_MIN / 10 || (result == INT_MIN / 10 &amp;&amp; num &lt; -8)) return 0;        x = x / 10;        result = result * 10 + num;    }    return result;}</code></pre><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode(1) Two-Sum</title>
    <link href="/2018/07/06/leetcode(1)%20Two-Sum/"/>
    <url>/2018/07/06/leetcode(1)%20Two-Sum/</url>
    
    <content type="html"><![CDATA[<p>difficult：easy #1<br>Given an array of integers, return indices of the two numbers such that they add up to a specific target.<br>You may assume that each input would have exactly one solution, and you may not use the same element twice.<br>Example:</p><pre><code class="lang-cpp">Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].</code></pre><h3 id="解法1-暴力法"><a href="#解法1-暴力法" class="headerlink" title="解法1 暴力法"></a>解法1 暴力法</h3><p>时间复杂度 O(<script type="math/tex">n^2</script>)</p><pre><code class="lang-cpp">std::vector&lt;int&gt; sum::twoSum(std::vector&lt;int&gt;&amp; nums, int target){    std::vector&lt;int&gt; result;    for (int i = 0; i &lt; nums.size(); i++) {      for (int j = i + 1; j &lt; nums.size(); j++) {        int sum = nums[i] + nums[j];        if (sum == target) {          result.push_back(i);          result.push_back(j);        }      }    }    return result;}</code></pre><h3 id="解法2-HashMap"><a href="#解法2-HashMap" class="headerlink" title="解法2 HashMap"></a>解法2 HashMap</h3><p>时间复杂度 O(<script type="math/tex">n</script>)</p><pre><code class="lang-cpp">vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {    std::map&lt;int,int&gt; nums_map;    std::vector&lt;int&gt; result;    for (int i = 0; i &lt; nums.size(); i++){        nums_map[nums[i]] = i;    }    for (int i = 0; i &lt; nums.size(); i++){        int value = target - nums[i];        if (nums_map.find(value) != nums_map.end() &amp;&amp; nums_map[value] != i) {            result.push_back(i);            result.push_back(nums_map[value]);            return result;        }    }}</code></pre><p>版权声明：原创,转载请注明来源,否则律师函警告</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker指南</title>
    <link href="/2018/06/13/Docker%E6%8C%87%E5%8D%97/"/>
    <url>/2018/06/13/Docker%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/docker.jpg" srcset="/img/loading.gif" alt="&quot;docker&quot;">  </p><h3 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h3><p>问题引入:当我们在本机开发好应用程序以后需要发布到服务器，但是服务器并非和我们本机系统有着一样的运行环境，如缺少数据库、缺少各种依赖包、依赖软件版本过低等等问题，需要花很长时间重新在服务器配置好运行环境，得不偿失.那么有没有方法能够将我们开发程序时本机上所有的运行环境打包，直接部署到服务器上程序就能运行的机制呢?</p><p>Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，Docker是一个开源的应用容器引擎，基于Go语言，并遵从Apache2.0协议开源.容器是完全使用沙箱机制，相互之间不会有任何接口(类似iPhone的 app)，更重要的是容器性能开销极低.[来源网络]</p><p>通过上述定义可以知道，Docker似乎类似于虚拟机，可以在Docker中打包安装任何应用并运行，比如tomcat、Java、mysql等.但它并不等同于虚拟机，为了区分Docker和虚拟机，我们先来了解虚拟机的运行机制，如下图所示：</p><p><img src="/images/docker3.png" srcset="/img/loading.gif" alt="virtualbox"></p><blockquote><p>基础设施（Infrastructure):个人电脑，数据中心的服务器，或者是云主机</p><p>操作系统（Host Operating System）：MacOS，Windows或者Linux发行版</p><p>虚拟机管理系统（Hypervisor)：virtualBox,VMWare</p><p>从操作系统（Guest Operating System）:运行在virtualBox,VMWare中的虚拟机</p><p>依赖(bins/libs)：安装python，mysql等需要的依赖项</p><p>应用(APP)：Web 应用、后台应用、数据库应用等</p></blockquote><p>可以看出若隔离不同的应用，需要安装并启动不同的虚拟机，虚拟机的启动速度慢而且开销极大.Docker容器运行的应用不仅处于隔离状态，而且启动速度极快(毫秒级)，而且开销极小.下图为Docker的运行机制:</p><p><img src="/images/docker1.png" srcset="/img/loading.gif" alt="docker"></p><blockquote><p>基础设施（Infrastructure):个人电脑，数据中心的服务器，或者是云主机</p><p>操作系统（Host Operating System）：Linux</p><p>Docker守护进程（Docker Daemon）：Docker守护进程取代了Hypervisor，运行在操作系统之上的后台进程，负责管理Docker容器,等同于virtualBox,VMWare</p><p>依赖(bins/libs)：应用的所有依赖都打包在Docker镜像中，Docker容器是基于Docker镜像创建的</p><p>应用(APP)：应用的源代码及其依赖都打包在Docker镜像中，不同的应用需要不同的Docker镜像.不同的应用运行在不同的Docker容器中，它们是相互隔离的</p></blockquote><p>Docker守护进程可以直接与主操作系统进行通信，为各个Docker容器分配资源,它还可以将容器与主操作系统隔离，并将各个容器互相隔离。<br>虚拟机启动需要数分钟，而Docker容器可以在数毫秒内启动,由于没有臃肿的从操作系统,Docker可以节省大量的磁盘空间以及其他系统资源。</p><hr><h3 id="Docker安装-基于Ubuntu"><a href="#Docker安装-基于Ubuntu" class="headerlink" title="Docker安装(基于Ubuntu)"></a>Docker安装(基于Ubuntu)</h3><p>在创建Docker容器前需要先安装Docker容器引擎，类似于虚拟机的virtualBox或VMWare.</p><pre><code class="lang-bash">#查看内核版本 docker安装需要大于3.1$ uname -r4.13.0-36-generic#更新软件源$ sudo apt-get update$ sudo apt-get install \    apt-transport-https \    ca-certificates \    curl \    gnupg-agent \    software-properties-common$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -$ sudo apt-key fingerprint 0EBFCD88$ sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;#安装docker$ sudo apt-get update$ sudo apt-get install docker-ce docker-ce-cli containerd.io#查看安装的docker版本(无错则安装成功)$ docker --versionDocker version 19.03.13, build 4484c46d9d#运行hello-wolrd实例(该命令运行时会从镜像仓库中拉取docker镜像)$ sudo docker run hello-worldlatest: Pulling from library/hello-world9bb5a5d4561a: Pull complete Digest: sha256:f5233545e43561214ca4891fd1157e1c3c563316ed8e237750d59bde73361e77Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.....#查看已有的镜像$ sudo docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEhello-world         latest              e38bc07ac18e        2 months ago        1.85 kB#hello-world即从镜像仓库中拉取的镜像 docker run hello-world:latest 启动容器#更新国内镜像$ sudo vim /etc/docker/daemon.json{  &quot;registry-mirrors&quot;: [    &quot;http://hub-mirror.c.163.com&quot;  ]}$ sudo systemctl daemon-reload$ sudo systemctl restart docker</code></pre><blockquote><p><a href="https://docs.docker.com/engine/install/ubuntu/" target="_blank" rel="noopener">https://docs.docker.com/engine/install/ubuntu/</a></p></blockquote><h3 id="容器和镜像"><a href="#容器和镜像" class="headerlink" title="容器和镜像"></a>容器和镜像</h3><p>如下图所示，容器是由镜像实例化而来，类似于面向对象的概念，镜像看作类，容器则为类实例化后的对象.一个Docker镜像可以构建于另一个Docker镜像之上,好比类的继承机制.<br><img src="/images/docker4.png" srcset="/img/loading.gif" alt="images"></p><p>docker的镜像概念类似虚拟机的镜像,是一个只读的模板,一个独立的文件系统,包括运行容器所需的数据，且可以用来创建新的容器(docker create <image -id >)，为指定的镜像添加一个可读写层.例如：一个镜像可以包含一个完整的ubuntu操作系统环境,类似于虚拟机的.iso文件.<br>docker利用容器来运行应用,docker容器是由docker镜像创建的运行实例,docker容器类似利用.iso文件安装后的虚拟机，可以执行各种读写操作,每个容器间是相互隔离的，容器中会运行特定的运用，包含特定应用的代码及所需的依赖文件,可以把容器看作一个简易版的linux环境.可以用同一个镜像启动多个Docker容器.</p><blockquote><p><a href="https://docs.docker.com/engine/reference/commandline/docker/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/docker/</a></p></blockquote><h3 id="docker命令"><a href="#docker命令" class="headerlink" title="docker命令"></a>docker命令</h3><pre><code class="lang-bash">#查看已有的镜像$ sudo docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEhello-world         latest              e38bc07ac18e        2 months ago        1.85 kB--all , -a        Show all images (default hides intermediate images)--digests        Show digests--filter , -f        Filter output based on conditions provided--format        Pretty-print images using a Go template--no-trunc        Don’t truncate output--quiet , -q        Only show numeric IDs#搜索镜像$ sudo docker search mysqlNAME                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATEDmysql                             MySQL is a widely used, open-source relation…   10202               [OK]                mariadb                           MariaDB is a community-developed fork of MyS…   3753                [OK]                mysql/mysql-server                Optimized MySQL Server Docker images. Create…   744                                     [OK]#拉取镜像$ sudo docker pull mysqlUsing default tag: latestlatest: Pulling from library/mysql852e50cd189d: Pull complete 29969ddb0ffb: Pull complete a43f41a44c48: Pull complete 5cdd802543a3: Pull complete b79b040de953: Pull complete 938c64119969: Pull complete 7689ec51a0d9: Pull complete a880ba7c411f: Pull complete 984f656ec6ca: Pull complete 9f497bce458a: Pull complete b9940f97694b: Pull complete 2f069358dc96: Pull complete Digest: sha256:4bb2e81a40e9d0d59bd8e3dc2ba5e1f2197696f6de39a91e90798dd27299b093Status: Downloaded newer image for mysql:latestdocker.io/library/mysql:latest#删除镜像$ sudo docker rmi 容器IDUntagged: hello-world:latestUntagged: hello-world@sha256:e7c70bb24b462baa86c102610182e3efcb12a04854e8c582838d92970a09f323Deleted: sha256:bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6bDeleted: sha256:9c27e219663c25e0f28493790cc0b88bc973ba3b1686355f221c38a36978ac63#--------------------------------------------------------------#$ docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]--name string                    指定容器名字-it                              交互方式启动-p, --publish list               端口映射，-p 主机端口:容器端口; -p 容器端口(主机端口随机)-P, --publish-all                端口随机#启动容器 $ docker run hello-world #run 创建基于该镜像的容器并启动#启动指定版本容器$ docker run hello-world:latest#查看已启动的容器$ docker ps  #查看存在的容器$ docker ps -a #启动已存在的容器$ docker start 容器ID#启动容器(守护方式/后台启动)$ docker run -d 容器ID$ docker start -d 容器ID#重新进入当前容器$ docker attach 容器ID#运行的容器中启动新进程$ docker exec -i -t 容器ID /bin/bash#停止守护容器$ docker stop 容器ID #等待容器停止$ docker kill 容器ID #立即停止容器#删除容器$ docker rm 容器ID#容器端口映射docker -P / docker --publish-all=true|false #映射所有端口$ docker run -P -i -t ubuntu #宿主机端口随机docker -p #映射指定端口$ docker run -p 80 -i -t ubuntu  #宿主机端口随机$ docker run -p 8080:80 -i -t ubuntu  #宿主机端口:容器端口$ docker run -p 0.0.0.0:80 -i -t ubuntu  #宿主机ip:容器端口$ docker run -p 0.0.0.0:8080:80 -i -t ubuntu  #宿主机ip:宿主机端口:容器端口#--------------------------------------------------------------##查看容器详细信息$ sudo docker inspect [OPTIONS] NAME|ID [NAME|ID...]#--------------------------------------------------------------##查看容器日志$ sudo docker logs [OPTIONS] CONTAINER--details        Show extra details provided to logs--follow , -f        Follow log output--since        Show logs since timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes)--tail    all    Number of lines to show from the end of the logs--timestamps , -t        Show timestamps#--------------------------------------------------------------##查看容器进程信息$ sudo docker top CONTAINER [ps OPTIONS]#--------------------------------------------------------------##容器/主机文件拷贝$ sudodocker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-$ sudodocker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH#--------------------------------------------------------------##可视化图形工具:Portainer,https://www.portainer.io/installation/#--------------------------------------------------------------##根据当前容器状态 创建新的镜像docker commit -m=&#39;ssh install&#39; -a=&#39;jiaopan&#39; cb57c338f1c9 kyleson/jpos#-m 说明文字#-a 作者#cb57c338f1c9 容器ID#kyleson/jpos 镜像名称#-p 提交时暂停容器#上传镜像到docker hub$ sudo docker login$ sudo docker push kyleson/jpos</code></pre><p><img src="/images/docker-command.jpeg" srcset="/img/loading.gif" alt="docker"></p><h3 id="docker容器数据卷"><a href="#docker容器数据卷" class="headerlink" title="docker容器数据卷"></a>docker容器数据卷</h3><pre><code class="lang-bash">$ sudo docker  run  -v /home/test:/home -it  centos /bin/bash--volume , -v        Bind mount a volume # -v 宿主机目录:容器目录#目录绑定成功信息$ sudo docker inspect 容器id&quot;Mounts&quot;: [    {        &quot;Type&quot;: &quot;bind&quot;,        &quot;Source&quot;: &quot;/home/test&quot;,        &quot;Destination&quot;: &quot;/home&quot;,        &quot;Mode&quot;: &quot;&quot;,        &quot;RW&quot;: true,        &quot;Propagation&quot;: &quot;rprivate&quot;    }]#note:主机/home/test和容器内的/home目录数据双向同步#容器间的数据共享--volumes-from        Mount volumes from the specified container(s)$ sudo docker run --volumes-from 777f7dc92da7 -i -t ubuntu pwd</code></pre><h3 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h3><blockquote><p><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/</a></p></blockquote><p><img src="/images/docker5.jpg" srcset="/img/loading.gif" alt="images"></p><pre><code class="lang-shell">FROM centosMAINTAINER jiaopaner&lt;jiaopaner@qq.com&gt;ENV PATH /homeWORKDIR $PATHRUN yum install vimRUN yum install net-toolsEXPOSE 80CMD echo $PATHCMD echo &quot;----------end---------&quot;CMD /bin/bash</code></pre><pre><code class="lang-bash">$ sudo docker build -f dockerfile -t jp-centos .Sending build context to Docker daemon  2.048kBStep 1/8 : FROM centos ---&gt; 0d120b6ccaa8Step 2/8 : MAINTAINER jiaopaner&lt;jiaopaner@qq.com&gt; ---&gt; Running in 0f054a284458Removing intermediate container 0f054a284458 ---&gt; 350dafb870cfStep 3/8 : ENV PATH /home ---&gt; Running in 86e71faf7d39Removing intermediate container 86e71faf7d39 ---&gt; ce30199ce12bStep 4/8 : WORKDIR $PATH ---&gt; Running in 68ee5a3cc62aRemoving intermediate container 68ee5a3cc62a ---&gt; 9142ba699de8Step 5/8 : EXPOSE 80 ---&gt; Running in 7b1d81ba8276Removing intermediate container 7b1d81ba8276 ---&gt; 2c1c922e9eecStep 6/8 : CMD echo $PATH ---&gt; Running in 9137d52fbda2Removing intermediate container 9137d52fbda2 ---&gt; ffce4c2caec7Step 7/8 : CMD echo &quot;----------end---------&quot; ---&gt; Running in 61d1d5af663cRemoving intermediate container 61d1d5af663c ---&gt; 6eeb9214b922Step 8/8 : CMD /bin/bash ---&gt; Running in 48b3775713e7Removing intermediate container 48b3775713e7 ---&gt; 1536cb9c9daaSuccessfully built 1536cb9c9daaSuccessfully tagged jp-centos:latest$ sudo docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED              SIZEjp-centos           latest              1536cb9c9daa        About a minute ago   215MB</code></pre><pre><code class="lang-bash">#jdk8FROM centosMAINTAINER jiaopanerADD jdk-8u191-linux-x64.tar.gz /usr/local/ENV JAVA_HOME /usr/local/jdk1.8.0_191/ENV PATH $JAVA_HOME/bin:$PATHENTRYPOINT [&quot;java&quot;,&quot;-version&quot;]</code></pre><h3 id="docker网络"><a href="#docker网络" class="headerlink" title="docker网络"></a>docker网络</h3><pre><code class="lang-bash">$ ip addr3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default     link/ether 02:42:12:01:fd:bc brd ff:ff:ff:ff:ff:ff    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0       valid_lft forever preferred_lft forever#查看容器内部ip地址$ sudo docker exec -it 容器id ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever4: eth0@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default     link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0       valid_lft forever preferred_lft forever#查看docker网络$ sudo docker network lsNETWORK ID          NAME                DRIVER              SCOPE3b234a9aa88b        bridge              bridge              locald07463d88601        host                host                local5c0b56f3d183        none                null                local#自定义网络$ sudo docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet$ sudo docker network lsNETWORK ID          NAME                DRIVER              SCOPE3b234a9aa88b        bridge              bridge              local0217c6ae906e        mynet               bridge              local$ sudo docker run -it -d --name mynet-os --net mynet  centos$ sudo docker exec -it d9d07c8f46cf  ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever7: eth0@if8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default     link/ether 02:42:c0:a8:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet 192.168.0.2/16 brd 192.168.255.255 scope global eth0       valid_lft forever preferred_lft forever#自定义网络可通过容器名ping通网络$ sudo docker run -it -d --name mynet-os02 --net mynet  centossudo docker exec -it mynet-os  ping mynet-os02PING mynet-os02 (192.168.0.3) 56(84) bytes of data.64 bytes from mynet-os02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.064 ms64 bytes from mynet-os02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.072 ms64 bytes from mynet-os02.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.072 ms64 bytes from mynet-os02.mynet (192.168.0.3): icmp_seq=4 ttl=64 time=0.072 ms#容器连到其它子网docker network connect [OPTIONS] NETWORK CONTAINER--alias        Add network-scoped alias for the container--driver-opt        driver options for the network--ip        IPv4 address (e.g., 172.30.100.104)--ip6        IPv6 address (e.g., 2001:db8::33)--link        Add link to another container--link-local-ip        Add a link-local address for the container$ sudo docker ps -aCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES518839a304cc        centos              &quot;/bin/bash&quot;         9 minutes ago       Up 9 minutes                            mynet-os02d9d07c8f46cf        centos              &quot;/bin/bash&quot;         11 minutes ago      Up 11 minutes                           mynet-osd32dd57bf19e        centos              &quot;/bin/bash&quot;         47 minutes ago      Up 47 minutes                           interesting_davinci$ sudo docker network connect mynet interesting_davinci$ sudo docker exec -it mynet-os  ping interesting_davinci1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever4: eth0@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default     link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0       valid_lft forever preferred_lft forever11: eth1@if12: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default     link/ether 02:42:c0:a8:00:04 brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet 192.168.0.4/16 brd 192.168.255.255 scope global eth1       valid_lft forever preferred_lft forever</code></pre><h3 id="redis集群部署"><a href="#redis集群部署" class="headerlink" title="redis集群部署"></a>redis集群部署</h3><pre><code class="lang-bash">#redis网络创建$ sudo docker network create redis-net --subnet 192.160.0.0/16</code></pre><p>redis配置脚本</p><pre><code class="lang-bash">for port in $(seq 1 6);domkdir -p /home/jiaopan/test/redis/node-${port}/conftouch /home/jiaopan/test/redis/node-${port}/conf/redis.confcat &lt;&lt; EOF &gt;/home/jiaopan/test/redis/node-${port}/conf/redis.confport 6379bind 0.0.0.0cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000Cluster-announce-ip 192.160.0.1${port}Cluster-announce-port 6379Cluster-announce-bus-port 16379appendonly yesEOFdone</code></pre><p>启动redis容器脚本</p><pre><code class="lang-bash">for port in $(seq 1 6);dosudo docker run -p 637${port}:6379 -p 1637${port}:16379 --name redis-0${port} -v /home/jiaopan/test/redis/node-${port}/data:/data -v /home/jiaopan/test/redis/node-${port}/conf/redis.conf:/etc/redis/redis.conf -d --net redis-net --ip 192.160.0.1${port} redis redis-server /etc/redis/redis.confdone</code></pre><pre><code>$ bash redis-start.sh Unable to find image &#39;redis:latest&#39; locallylatest: Pulling from library/redis852e50cd189d: Pull complete 76190fa64fb8: Pull complete 9cbb1b61e01b: Pull complete d048021f2aae: Pull complete 6f4b2af24926: Pull complete 1cf1d6922fba: Pull complete Digest: sha256:5b98e32b58cdbf9f6b6f77072c4915d5ebec43912114031f37fa5fa25b032489Status: Downloaded newer image for redis:latest5be42fac290d85699ded763bb7fd9b03fe30285648b083916565fd2ecc140306b6beb0cb73c7e6bfc9438153fa2acf6001ac9093e5a182bf9e8ba7ef92fd9c1d3c7fec0bc0ac5cc699258c359f6d6252bfbf5a5967f7a6cd9e7e4d2f6ad572aa160b55fd9a9dfc3daaf337c7d4b1e5c094e879ebc1a339198a9c565a45fae12445028522de12e7d3aa072322da0d6f2e5b4fda8552fe5977a8439dbfd83aae6e99a37fe7e370cd262be8d411b38032ac5b12c470931aa4cbaa47d60532fa82fc$ sudo docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                              NAMES99a37fe7e370        redis               &quot;docker-entrypoint.s…&quot;   43 seconds ago      Up 41 seconds       0.0.0.0:6376-&gt;6379/tcp, 0.0.0.0:16376-&gt;16379/tcp   redis-0645028522de12        redis               &quot;docker-entrypoint.s…&quot;   43 seconds ago      Up 42 seconds       0.0.0.0:6375-&gt;6379/tcp, 0.0.0.0:16375-&gt;16379/tcp   redis-05160b55fd9a9d        redis               &quot;docker-entrypoint.s…&quot;   44 seconds ago      Up 42 seconds       0.0.0.0:6374-&gt;6379/tcp, 0.0.0.0:16374-&gt;16379/tcp   redis-043c7fec0bc0ac        redis               &quot;docker-entrypoint.s…&quot;   44 seconds ago      Up 43 seconds       0.0.0.0:6373-&gt;6379/tcp, 0.0.0.0:16373-&gt;16379/tcp   redis-03b6beb0cb73c7        redis               &quot;docker-entrypoint.s…&quot;   45 seconds ago      Up 43 seconds       0.0.0.0:6372-&gt;6379/tcp, 0.0.0.0:16372-&gt;16379/tcp   redis-025be42fac290d        redis               &quot;docker-entrypoint.s…&quot;   46 seconds ago      Up 44 seconds       0.0.0.0:6371-&gt;6379/tcp, 0.0.0.0:16371-&gt;16379/tcp   redis-01$ sudo docker exec -it redis-01 /bin/sh# lsappendonly.aof    nodes.conf#创建集群# redis-cli --cluster create 192.160.0.11:6379 192.160.0.12:6379 192.160.0.13:6379 192.160.0.14:6379 192.160.0.15:6379 192.160.0.16:6379 --cluster-replicas 1&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...Master[0] -&gt; Slots 0 - 5460Master[1] -&gt; Slots 5461 - 10922Master[2] -&gt; Slots 10923 - 16383Adding replica 192.160.0.15:6379 to 192.160.0.11:6379Adding replica 192.160.0.16:6379 to 192.160.0.12:6379Adding replica 192.160.0.14:6379 to 192.160.0.13:6379M: 2511c99b36e7332e780e1a99d3800b5118cda204 192.160.0.11:6379   slots:[0-5460] (5461 slots) masterM: ff3d43f7a35176117f1cf87b8e7bb4293d36cdea 192.160.0.12:6379   slots:[5461-10922] (5462 slots) masterM: 24b37dae575d40028c7e11b9f2d9d36ba8615ac2 192.160.0.13:6379   slots:[10923-16383] (5461 slots) masterS: 612a061d020c6cfce795e0caee85f8ada13a1951 192.160.0.14:6379   replicates 24b37dae575d40028c7e11b9f2d9d36ba8615ac2S: a45877d8533abda256dacd947333b857311e015a 192.160.0.15:6379   replicates 2511c99b36e7332e780e1a99d3800b5118cda204S: c4b5e4b5bd9bdac83340686aab4caf80412d9adf 192.160.0.16:6379   replicates ff3d43f7a35176117f1cf87b8e7bb4293d36cdeaCan I set the above configuration? (type &#39;yes&#39; to accept): yes&gt;&gt;&gt; Nodes configuration updated&gt;&gt;&gt; Assign a different config epoch to each node&gt;&gt;&gt; Sending CLUSTER MEET messages to join the clusterWaiting for the cluster to join&gt;&gt;&gt; Performing Cluster Check (using node 192.160.0.11:6379)M: 2511c99b36e7332e780e1a99d3800b5118cda204 192.160.0.11:6379   slots:[0-5460] (5461 slots) master   1 additional replica(s)S: c4b5e4b5bd9bdac83340686aab4caf80412d9adf 192.160.0.16:6379   slots: (0 slots) slave   replicates ff3d43f7a35176117f1cf87b8e7bb4293d36cdeaS: 612a061d020c6cfce795e0caee85f8ada13a1951 192.160.0.14:6379   slots: (0 slots) slave   replicates 24b37dae575d40028c7e11b9f2d9d36ba8615ac2M: ff3d43f7a35176117f1cf87b8e7bb4293d36cdea 192.160.0.12:6379   slots:[5461-10922] (5462 slots) master   1 additional replica(s)M: 24b37dae575d40028c7e11b9f2d9d36ba8615ac2 192.160.0.13:6379   slots:[10923-16383] (5461 slots) master   1 additional replica(s)S: a45877d8533abda256dacd947333b857311e015a 192.160.0.15:6379   slots: (0 slots) slave   replicates 2511c99b36e7332e780e1a99d3800b5118cda204[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered.#容器信息# redis-cli -c127.0.0.1:6379&gt; cluster infocluster_state:okcluster_slots_assigned:16384cluster_slots_ok:16384cluster_slots_pfail:0cluster_slots_fail:0cluster_known_nodes:6cluster_size:3cluster_current_epoch:6cluster_my_epoch:1cluster_stats_messages_ping_sent:201cluster_stats_messages_pong_sent:202cluster_stats_messages_sent:403cluster_stats_messages_ping_received:197cluster_stats_messages_pong_received:201cluster_stats_messages_meet_received:5cluster_stats_messages_received:403127.0.0.1:6379&gt; cluster nodesc4b5e4b5bd9bdac83340686aab4caf80412d9adf 192.160.0.16:6379@16379 slave ff3d43f7a35176117f1cf87b8e7bb4293d36cdea 0 1606361107161 2 connected612a061d020c6cfce795e0caee85f8ada13a1951 192.160.0.14:6379@16379 slave 24b37dae575d40028c7e11b9f2d9d36ba8615ac2 0 1606361109184 3 connectedff3d43f7a35176117f1cf87b8e7bb4293d36cdea 192.160.0.12:6379@16379 master - 0 1606361109000 2 connected 5461-1092224b37dae575d40028c7e11b9f2d9d36ba8615ac2 192.160.0.13:6379@16379 master - 0 1606361108000 3 connected 10923-163832511c99b36e7332e780e1a99d3800b5118cda204 192.160.0.11:6379@16379 myself,master - 0 1606361108000 1 connected 0-5460a45877d8533abda256dacd947333b857311e015a 192.160.0.15:6379@16379 slave 2511c99b36e7332e780e1a99d3800b5118cda204 0 1606361108676 1 connected127.0.0.1:6379&gt; set name jiaopaner-&gt; Redirected to slot [5798] located at 192.160.0.12:6379OK192.160.0.12:6379&gt; get name&quot;jiaopaner&quot;</code></pre><h3 id="springboot-docker部署"><a href="#springboot-docker部署" class="headerlink" title="springboot docker部署"></a>springboot docker部署</h3><pre><code class="lang-bash">#DockerfileFROM java:8COPY *.jar /app.jarCMD [&quot;--server.port=8080&quot;]EXPOSE 8080ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]</code></pre><h3 id="Compose（编排服务）"><a href="#Compose（编排服务）" class="headerlink" title="Compose（编排服务）"></a>Compose（编排服务）</h3><blockquote><p>Compose is a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application’s services. Then, with a single command, you create and start all the services from your configuration.</p><p>Using Compose is basically a three-step process:<br><br>1.Define your app’s environment with a Dockerfile so it can be reproduced anywhere.<br><br>2.Define the services that make up your app in docker-compose.yml so they can be run together in an isolated environment.<br><br>3.Run docker-compose up and Compose starts and runs your entire app</p></blockquote><p>A docker-compose.yml looks like this:</p><pre><code class="lang-yaml">version: &quot;3.8&quot;services:  web:    build: .    ports:      - &quot;5000:5000&quot;    volumes:      - .:/code      - logvolume01:/var/log    links:      - redis  redis:    image: redisvolumes:  logvolume01: {}</code></pre><p><strong>Compose安装</strong></p><pre><code class="lang-bash">$ sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.27.4/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose$ sudo chmod +x /usr/local/bin/docker-compose$ sudo docker-compose --versiondocker-compose version 1.27.4, build 40524192docker-py version: 4.3.1CPython version: 3.7.7OpenSSL version: OpenSSL 1.1.0l  10 Sep 2019</code></pre><p><strong>demo</strong></p><p>1.create workdir</p><pre><code class="lang-bash">$ mkdir composetest$ cd composetest</code></pre><p>2.create a file called app.py</p><pre><code class="lang-python">import timeimport redisfrom flask import Flaskapp = Flask(__name__)cache = redis.Redis(host=&#39;redis&#39;, port=6379)def get_hit_count():    retries = 5    while True:        try:            return cache.incr(&#39;hits&#39;)        except redis.exceptions.ConnectionError as exc:            if retries == 0:                raise exc            retries -= 1            time.sleep(0.5)@app.route(&#39;/&#39;)def hello():    count = get_hit_count()    return &#39;Hello World! I have been seen {} times.\n&#39;.format(count)</code></pre><p>3.add requirements.txt file</p><pre><code class="lang-text">flaskredis</code></pre><p>4.add Dockerfile file</p><pre><code class="lang-bash">FROM python:3.7-alpineWORKDIR /codeENV FLASK_APP=app.pyENV FLASK_RUN_HOST=0.0.0.0RUN apk add --no-cache gcc musl-dev linux-headersCOPY requirements.txt requirements.txtRUN pip install -r requirements.txtEXPOSE 5000COPY . .CMD [&quot;flask&quot;, &quot;run&quot;]</code></pre><p>5.add docker-compose.yml file</p><blockquote><p><a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">https://docs.docker.com/compose/compose-file/</a></p></blockquote><pre><code class="lang-yaml">version: &quot;3.8&quot;services:  web:    build: .    ports:      - &quot;5000:5000&quot;  redis:    image: &quot;redis:alpine&quot;</code></pre><pre><code class="lang-bash">$ lsapp.py  docker-compose.yml  Dockerfile  requirements.txt</code></pre><pre><code class="lang-bash">#集群部署:docker stack deploy example --compose-file=docker-compose.yml  #执行 (单机部署) $ sudo docker-compose upCreating network &quot;composeset_default&quot; with the default driverBuilding webStep 1/10 : FROM python:3.7-alpine ---&gt; f4bd0adb4b78Step 2/10 : WORKDIR /code ---&gt; Using cache ---&gt; 6dcde8d2643dStep 3/10 : ENV FLASK_APP=app.py ---&gt; Using cache ---&gt; f183c013c9c2Step 4/10 : ENV FLASK_RUN_HOST=0.0.0.0 ---&gt; Using cache ---&gt; 00c9ae84df9dStep 5/10 : RUN apk add --no-cache gcc musl-dev linux-headers ---&gt; Running in 61171d666007fetch http://dl-cdn.alpinelinux.org/alpine/v3.12/main/x86_64/APKINDEX.tar.gzfetch http://dl-cdn.alpinelinux.org/alpine/v3.12/community/x86_64/APKINDEX.tar.gz(1/13) Installing libgcc (9.3.0-r2)(2/13) Installing libstdc++ (9.3.0-r2)(3/13) Installing binutils (2.34-r1)(4/13) Installing gmp (6.2.0-r0)(5/13) Installing isl (0.18-r0)(6/13) Installing libgomp (9.3.0-r2)(7/13) Installing libatomic (9.3.0-r2)(8/13) Installing libgphobos (9.3.0-r2)(9/13) Installing mpfr4 (4.0.2-r4)(10/13) Installing mpc1 (1.1.0-r1)(11/13) Installing gcc (9.3.0-r2)(12/13) Installing linux-headers (5.4.5-r1)(13/13) Installing musl-dev (1.1.24-r10)Executing busybox-1.31.1-r19.triggerOK: 153 MiB in 48 packagesRemoving intermediate container 61171d666007 ---&gt; 2a158f7989b5Step 6/10 : COPY requirements.txt requirements.txt ---&gt; af6bcc03a33eStep 7/10 : RUN pip install -r requirements.txt ---&gt; Running in 71fc3d541f23Collecting flask  Downloading Flask-1.1.2-py2.py3-none-any.whl (94 kB)Collecting redis  Downloading redis-3.5.3-py2.py3-none-any.whl (72 kB)Collecting click&gt;=5.1  Downloading click-7.1.2-py2.py3-none-any.whl (82 kB)Collecting Jinja2&gt;=2.10.1  Downloading Jinja2-2.11.2-py2.py3-none-any.whl (125 kB)Collecting Werkzeug&gt;=0.15  Downloading Werkzeug-1.0.1-py2.py3-none-any.whl (298 kB)Collecting itsdangerous&gt;=0.24  Downloading itsdangerous-1.1.0-py2.py3-none-any.whl (16 kB)Collecting MarkupSafe&gt;=0.23  Downloading MarkupSafe-1.1.1.tar.gz (19 kB)Building wheels for collected packages: MarkupSafe  Building wheel for MarkupSafe (setup.py): started  Building wheel for MarkupSafe (setup.py): finished with status &#39;done&#39;  Created wheel for MarkupSafe: filename=MarkupSafe-1.1.1-cp37-cp37m-linux_x86_64.whl size=16913 sha256=05c83f7a4d528469e3601243e13c426f1611ea0634ba8ea024568984d74d1a28  Stored in directory: /root/.cache/pip/wheels/b9/d9/ae/63bf9056b0a22b13ade9f6b9e08187c1bb71c47ef21a8c9924Successfully built MarkupSafeInstalling collected packages: click, MarkupSafe, Jinja2, Werkzeug, itsdangerous, flask, redisSuccessfully installed Jinja2-2.11.2 MarkupSafe-1.1.1 Werkzeug-1.0.1 click-7.1.2 flask-1.1.2 itsdangerous-1.1.0 redis-3.5.3Removing intermediate container 71fc3d541f23 ---&gt; ebd64d838db7Step 8/10 : EXPOSE 5000 ---&gt; Running in a47a4ed55632Removing intermediate container a47a4ed55632 ---&gt; 880f46f3f44cStep 9/10 : COPY . . ---&gt; 553eb65d995fStep 10/10 : CMD [&quot;flask&quot;, &quot;run&quot;] ---&gt; Running in 1712a24b595cRemoving intermediate container 1712a24b595c ---&gt; 83683540551fSuccessfully built 83683540551fSuccessfully tagged composeset_web:latestWARNING: Image for service web was built because it did not already exist. To rebuild this image you must use `docker-compose build` or `docker-compose up --build`.Pulling redis (redis:alpine)...alpine: Pulling from library/redis188c0c94c7c5: Already existsfb6015f7c791: Pull completef8890a096979: Pull completecd6e0c12d5bc: Pull complete67b3665cee45: Pull complete0705890dd1f7: Pull completeDigest: sha256:b0e84b6b92149194d99953e44f7d1fa1f470a769529bb05b4164eae60d8aea6cStatus: Downloaded newer image for redis:alpineCreating composeset_web_1   ... doneCreating composeset_redis_1 ... doneAttaching to composeset_redis_1, composeset_web_1redis_1  | 1:C 27 Nov 2020 02:56:41.453 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Ooredis_1  | 1:C 27 Nov 2020 02:56:41.453 # Redis version=6.0.9, bits=64, commit=00000000, modified=0, pid=1, just startedredis_1  | 1:C 27 Nov 2020 02:56:41.453 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.confredis_1  | 1:M 27 Nov 2020 02:56:41.454 * Running mode=standalone, port=6379.redis_1  | 1:M 27 Nov 2020 02:56:41.454 # Server initializedredis_1  | 1:M 27 Nov 2020 02:56:41.454 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &#39;vm.overcommit_memory = 1&#39; to /etc/sysctl.conf and then reboot or run the command &#39;sysctl vm.overcommit_memory=1&#39; for this to take effect.redis_1  | 1:M 27 Nov 2020 02:56:41.455 * Ready to accept connectionsweb_1    |  * Serving Flask app &quot;app.py&quot;web_1    |  * Environment: productionweb_1    |    WARNING: This is a development server. Do not use it in a production deployment.web_1    |    Use a production WSGI server instead.web_1    |  * Debug mode: offweb_1    |  * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)$ curl localhost:5000Hello World! I have been seen 1 times.</code></pre><h3 id="Swarm集群"><a href="#Swarm集群" class="headerlink" title="Swarm集群"></a>Swarm集群</h3><pre><code class="lang-bash">$ sudo docker swarm --helpUsage:    docker swarm COMMANDManage SwarmCommands:  ca          Display and rotate the root CA  init        Initialize a swarm  join        Join a swarm as a node and/or manager  join-token  Manage join tokens  leave       Leave the swarm  unlock      Unlock swarm  unlock-key  Manage the unlock key  update      Update the swarm#192.168.144.140：服务器ip地址  $ sudo docker swarm init --advertise-addr 192.168.144.140Swarm initialized: current node (27zm7bkz3lwi3o5zkpb3o3yyd) is now a manager.To add a worker to this swarm, run the following command:#工作节点服务器执行如下命令    docker swarm join --token SWMTKN-1-1zw8g50ugwjyxprtvvlyhw3o3orj2zg2s717e3lc0n5ha80kjg-d6ovnit23xotl9ak27e3dnbgm 192.168.144.140:2377#管理节点服务器则执行如下命令To add a manager to this swarm, run &#39;docker swarm join-token manager&#39; and follow the instructions.</code></pre><p><strong>Nginx集群</strong></p><pre><code class="lang-bash">$ sudo docker service create -p 8888:80 --name nginx-cluster nginx #添加副本$ sudo docker service update replicas 3 nginx-cluster $ sudo docker service scale nginx-cluster=3</code></pre>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>opencv3(1-2) linux配置opencv3开发环境</title>
    <link href="/2018/03/11/opencv3(1-2)%20linux%E9%85%8D%E7%BD%AEopencv3%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <url>/2018/03/11/opencv3(1-2)%20linux%E9%85%8D%E7%BD%AEopencv3%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p><strong>环境</strong><br>ubuntu<br>cmake<br>cmake-gui<br>opencv-3.3.1 下载地址:<a href="https://opencv.org/releases.html" target="_blank" rel="noopener">https://opencv.org/releases.html</a><br>opencv_contrib-3.3.1 下载地址:<a href="https://github.com/opencv/opencv_contrib/releases" target="_blank" rel="noopener">https://github.com/opencv/opencv_contrib/releases</a></p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul><li>更新系统<pre><code class="lang-bash">sudo apt-get updatesudo apt-get upgrade</code></pre></li><li>安装cmake及必要依赖<pre><code class="lang-bash">sudo apt-get install build-essentialsudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-devsudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev</code></pre></li><li>安装cmake-gui<pre><code class="lang-bash">sudo apt-get install cmake-qt-gui</code></pre></li><li>解压opencv以及opecv_contrib至同一目录<br><img src="/images/opencv3/2-1.png" srcset="/img/loading.gif" alt=""></li><li>opencv目录内新建build目录<br><img src="/images/opencv3/2-2.png" srcset="/img/loading.gif" alt=""><br>build目录内打开终端运行cmake-gui<pre><code class="lang-bash">cmake-gui</code></pre></li></ul><h1 id="编译-安装"><a href="#编译-安装" class="headerlink" title="编译 / 安装"></a>编译 / 安装</h1><ul><li><p>配置源码目录以及编译目录<br><img src="/images/opencv3/2-3.png" srcset="/img/loading.gif" alt=""></p></li><li><p>执行Configure<br>Unix Makefiles - &gt; Use default native compilers(默认) - &gt; Finish<br><img src="/images/opencv3/2-4.png" srcset="/img/loading.gif" alt=""></p></li><li><p>配置编译属性<br>CMAKE_BUILD_TYPE：RELEASE<br>CMAKE_INSTALL_PREFIX：/home/jiaopan/app/opencv #配置安装目录 可默认<br><img src="/images/opencv3/2-5.png" srcset="/img/loading.gif" alt=""><br>OPENCV_EXTRA_MODULES_PATH：/home/jiaopan/app/opencv3/opencv_contrib-3.3.1/modules #opencv_contrib的modules目录<br><img src="/images/opencv3/2-6.png" srcset="/img/loading.gif" alt=""></p></li><li><p>执行Generate 生成配置文件</p></li><li><p>build目录内打开终端 执行make命令开始编译 ，100%时编译成功<br><img src="/images/opencv3/2-7.png" srcset="/img/loading.gif" alt=""></p></li><li><p>编译成功，执行make install 命令进行安装</p></li><li><p>编译时问题</p><pre><code class="lang-bash">#1.问题1collect2: error: ld returned 1 exit statusmodules/core/CMakeFiles/opencv_perf_core.dir/build.make:882: recipe for target &#39;bin/opencv_perf_core&#39; failedmake[2]: *** [bin/opencv_perf_core] Error 1CMakeFiles/Makefile2:2627: recipe for target &#39;modules/core/CMakeFiles/opencv_perf_core.dir/all&#39; failedmake[1]: *** [modules/core/CMakeFiles/opencv_perf_core.dir/all] Error 2Makefile:160: recipe for target &#39;all&#39; failedmake: *** [all] Error 2#解决：缺少ffmpeg#安装ffmpegsudo add-apt-repository ppa:djcj/hybrid  sudo apt-get update  sudo apt-get install ffmpeg</code></pre></li><li><p>命令编译和安装</p></li></ul><pre><code class="lang-bash">cd buildsudo cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local ..sudo make -j8sudo make install</code></pre><h1 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h1><pre><code class="lang-bash">sudo vim /etc/ld.so.conf.d/opencv.conf #添加 /home/jiaopan/app/opencv/lib内容 ，即opencv安装目录下的lib目录路径sudo ldconfig #更新动态链接库sudo vim /etc/bash.bashrc #末尾添加如下内容PKG_CONFIG_PATH=$PKG_CONFIG_PATH:opencv安装目录/lib/pkgconfig export PKG_CONFIG_PATH#-----------------------------------------source /etc/profile #更新环境变量 pkg-config --cflags --libs opencv #测试是否安装成功</code></pre><p>安装成功:<br><img src="/images/opencv3/2-8.png" srcset="/img/loading.gif" alt=""></p><h1 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h1><ul><li>cmake 配置</li></ul><pre><code class="lang-bash">cmake_minimum_required(VERSION 3.15)project(test)set(CMAKE_CXX_STANDARD 14)find_package(OpenCV REQUIRED)include_directories(include ${OpenCV_INCLUDE_DIRS})add_executable(test main.cpp)target_link_libraries(test ${OpenCV_LIBS})</code></pre><pre><code class="lang-cpp">#include&lt;iostream&gt;#include &lt;opencv2/opencv.hpp&gt;int main(){    // 读入一张图片    cv::Mat image=cv::imread(&quot;dog.jpg&quot;);    // 在窗口中显示    cv::imshow(&quot;test&quot;,image);    // 等待6000 ms后窗口自动关闭    cv::waitKey(6000);    return 0;}</code></pre><p><img src="/images/opencv3/2-12.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>opencv3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>opencv3</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
