<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>今天的风儿甚是喧嚣 JiaoPan</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="今天的风儿甚是喧嚣 JiaoPan">
<meta property="og:url" content="https://jiaopaner.github.io/page/3/index.html">
<meta property="og:site_name" content="今天的风儿甚是喧嚣 JiaoPan">
<meta property="article:author" content="JiaoPan">
<meta property="article:tag" content="deep learning|computer vision">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="今天的风儿甚是喧嚣 JiaoPan" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">今天的风儿甚是喧嚣 JiaoPan</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://jiaopaner.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-数据结构(4) 树与二叉树" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(4)%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/" class="article-date">
  <time datetime="2019-06-17T07:11:45.000Z" itemprop="datePublished">2019-06-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(4)%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/">数据结构(4) 树与二叉树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>树的定义:树是$N(N\geqslant 0)$个结点的有限集合。特别的，当$N=0$时，称为空树。</p>
<p>任意非空树满足的条件：</p>
<ul>
<li>有且仅有一个特定的称为<strong>根</strong>的结点</li>
<li>当$N&gt;1$时，其余结点可分为$m$个互不相交的有限集合$T_1,T_2,\dots,T_m$,其中每个集合本身又是一棵树，并且称为根结点的子树</li>
</ul>
<p>树是一种递归的数据结构</p>
<ul>
<li>根结点无前驱结点，除根结点外的其余所有结点有且仅有一个前驱结点</li>
<li>树中所有结点可以有零个或多个后继结点</li>
</ul>
<p><strong>基本术语</strong></p>
<p><img src="%5Cimages%5CdataStructure%5C2.jpg" alt=""></p>
<ol>
<li>结点$K$,结点$A,B,E$为到结点$K$的唯一路径上的结点，$A,B$为$K$的<strong>祖先结点</strong>，$K$为$A,B$的子孙结点；$E$为$K$的<strong>双亲结点</strong>，$K$为$E$的<strong>孩子结点</strong>，有相同双亲的结点为<strong>兄弟结点</strong>，如$K$和$L$互为兄弟节点；</li>
<li>树中一个子结点的个数称为该结点的度，树中结点的最大度数称为树的度；</li>
<li>度大于$0$的结点称为分支结点,如$B,C,D$,度为$0$的结点称为叶子结点，如$K,L,M$；</li>
<li>树的深度为树中结点的最大层数，如图的树形结构深度为4</li>
<li>两个结点之间的路径为两个结点之间所经过的结点序列，路径长度为路径上经过的边的个数，如$A$到$K$的路径长度为3；</li>
<li>森林是$m$课互不相交的树的集合；</li>
</ol>
<h1 id="二叉树概念"><a href="#二叉树概念" class="headerlink" title="二叉树概念"></a>二叉树概念</h1><p>定义:每个结点至多只有两颗子树的树形结构，即二叉树中不存在度大于2的结点，二叉树有左右之分，次序不可颠倒。</p>
<p><strong>二叉树的形态</strong>：</p>
<p><img src="%5Cimages%5CdataStructure%5C3.jpg" alt=""></p>
<p><strong>满二叉树：</strong>一颗高度为$h$，并且含有$2^h-1$个结点的二叉树</p>
<p>对于编号$i$结点，如果有双亲，其双亲为[$i/2$]，如果孩子结点，左孩子为$2i$,右孩子为$2i+1$</p>
<p><img src="%5Cimages%5CdataStructure%5C4.jpg" alt=""></p>
<p><strong>完全二叉树</strong>：设深度为$h$，有$n$个结点的二叉树，当且仅当其每一个结点都与深度为$h$的满二叉树中编号为$1\sim n$的结点<strong>一一对应</strong>，称为完全二叉树。</p>
<p>特点：</p>
<ol>
<li>若$i\leqslant[n/2] $,则结点$i$为分支节点，否则为叶子节点；</li>
<li>如果有度为1的结点，只可能有一个，且该结点只有左孩子无右孩子；</li>
</ol>
<p><strong>平衡二叉树</strong>：树上<strong>任一结点</strong>的左子树和右子树的深度差不超过1</p>
<p><strong>二叉树的性质：</strong></p>
<ol>
<li>非空二叉树上叶子结点数等于度为2的结点数加1，即$N_0=N_2+1$</li>
<li>非空二叉树上第$K$层至多有$2^{k-1}个结点(K\geqslant 1)$</li>
<li>深度为$h$的二叉树至多有$2^{h}-1$个结点</li>
<li>对于具有$1 \sim n$编号的完全二叉树，具有如下关系<ul>
<li>当$i&gt;1$时，结点$i$的双亲结点编号为$[i/2]$,当$i$为偶数时其为双亲结点的左孩子，当$i$为奇数时其为双亲结点的右孩子</li>
<li>当$2i\leqslant n $时，结点$i$的左孩子编号为$2i$，否则无左孩子</li>
<li>当$2i+1\leqslant n $时，结点$i$的左孩子编号为$2i +1$，否则无右孩子</li>
<li>结点$i$所在深度为$[\log _2{i}+1]$</li>
</ul>
</li>
<li>具有$n$个结点的完全二叉树的深度为$[\log _2{(n+1)}]$或$[\log _2{n}]+1$</li>
</ol>
<p><strong>二叉树的顺序存储</strong></p>
<p>将完全二叉树上编号为$i$的结点元素存储在某个数组下标为$i-1$的分量中。</p>
<p>对于一般的二叉树，使用0表示不存在的空结点，下标从1开始。</p>
<p><img src="%5Cimages%5CdataStructure%5C5.jpg" alt=""></p>
<p><strong>二叉树的链式存储</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">biTreeNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">biTreeNode</span> *<span class="title">left</span>,*<span class="title">right</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">&#125;biTreeNode,*biTree;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h1><ol>
<li><p>先序遍历</p>
<p>访问根结点$\rightarrow$先序遍历左子树$\rightarrow $先序遍历右子树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BiTree tree)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != null)&#123;</span><br><span class="line">        visit(tree);</span><br><span class="line">        preOrder(tree-&gt;left);</span><br><span class="line">        preOrder(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序遍历</p>
<p>中序遍历左子树$\rightarrow$访问根结点$\rightarrow $中序遍历右子树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BiTree tree)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != null)&#123;</span><br><span class="line">        inOrder(tree-&gt;left);</span><br><span class="line">        visit(tree);</span><br><span class="line">        inOrder(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后序遍历</p>
<p>后序遍历左子树$\rightarrow$后序遍历右子树$\rightarrow $访问根结点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(BiTree tree)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != null)&#123;</span><br><span class="line">        postOrder(tree-&gt;left);</span><br><span class="line">        postOrder(tree-&gt;right);</span><br><span class="line">        visit(tree);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="%5Cimages%5CdataStructure%5C6.jpg" alt=""></p>
<ul>
<li>先序遍历：1 2 4 6 3 5 </li>
<li>中序遍历：2 6 4 1 3 5</li>
<li>后序遍历：6 4 2 5 3 1</li>
</ul>
</li>
<li><p>非递归遍历算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历非递归算法</span></span><br><span class="line"><span class="keyword">void</span> inOrder*(BiTree tree)&#123;</span><br><span class="line">    initStack(<span class="built_in">stack</span>);<span class="comment">//初始化栈</span></span><br><span class="line">    BiTree p = tree;<span class="comment">//遍历指针</span></span><br><span class="line">    <span class="keyword">while</span>(p || !isEmpty(<span class="built_in">stack</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            push(<span class="built_in">stack</span>,p);</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pop(<span class="built_in">stack</span>,p);</span><br><span class="line">            visit(p);</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>层次遍历</p>
<p>按图中箭头的顺序进行遍历，先访问第一层，再访问第二层,$\dots$</p>
<p><img src="%5Cimages%5CdataStructure%5C7.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(BiTree tree)</span></span>&#123;</span><br><span class="line">	initQueue(<span class="built_in">queue</span>);</span><br><span class="line">    biTree p;</span><br><span class="line">    enQueue(<span class="built_in">queue</span>,tree);<span class="comment">//根节点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(<span class="built_in">queue</span>))&#123;</span><br><span class="line">        deQueue(<span class="built_in">queue</span>,p);<span class="comment">//队头元素出队</span></span><br><span class="line">        visit(p);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;left != null)</span><br><span class="line">            enQueue(<span class="built_in">queue</span>,p-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;right != null)</span><br><span class="line">            enQueue(<span class="built_in">queue</span>,p-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据遍历序列构造二叉树</p>
<ul>
<li>二叉树的先序序列和中序序列可以唯一确定一颗二叉树。先序序列中，第一结点为根节点，在中序序列中，根结点将其分为两个子序列，根据该子序列在先序序列中找到对应的左子序列和右子序列，其先序序列中，左子序列第一个结点为左子树的根节点，右子序列的第一个结点为右子树的根结点，如此递归。</li>
<li>二叉树的后序序列和中序序列可以唯一确定一颗二叉树。后序序列的最后一个结点为根节点。</li>
<li>层次遍历序列和中序序列可以唯一确定一颗二叉树。</li>
</ul>
<p>求先序序列$ABCDEFGHI$和中序遍历$BCAEDGHFI$所确定的二叉树</p>
<p><img src="%5Cimages%5CdataStructure%5C8.jpg" alt=""></p>
</li>
</ol>
<h1 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h1><p>二叉树线索化时通常规定，若无左子树，令leftChild指向其前驱结点，leftTag = 1；若无右子树，令right-child指向其后继结点,rightTag = 1。</p>
<p><strong>线索二叉树的存储结构</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">threadNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">threadNode</span> *<span class="title">leftChild</span>,<span class="title">rightChild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> leftTag,rightTag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线索二叉树的构造</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历-二叉树线索化</span></span><br><span class="line"><span class="comment">//指针pre指向中序遍历时上一个刚刚访问过的结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inThreadNode</span><span class="params">(threadNode &amp;p,threadNode &amp;pre)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != null)&#123;</span><br><span class="line">        inThreadNode(p-&gt;leftChild,pre);<span class="comment">//递归线索化左子树</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;leftChild == null)&#123; <span class="comment">//建立前驱线索</span></span><br><span class="line">            p-&gt;leftChild = pre;</span><br><span class="line">            p-&gt;leftTag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre != null &amp;&amp; pre-&gt;rightCihld == null)&#123;<span class="comment">//建立后继线索</span></span><br><span class="line">            pre-&gt;rightChild = p;</span><br><span class="line">            pre-&gt;rightTag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">        inthreadNode(p-&gt;rightChild,pre);<span class="comment">//递归线索化右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createInThreadNode</span><span class="params">(threadNode T)</span></span>&#123;</span><br><span class="line">    threadNode pre = null;</span><br><span class="line">    <span class="keyword">if</span>(T != null)&#123;</span><br><span class="line">        inThreadNode(T,pre);</span><br><span class="line">        pre-&gt;rightChild = null;<span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">        pre-&gt;rightTag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="%5Cimages%5CdataStructure%5C9.jpg" alt=""></p>
<p><strong>线索二叉树的遍历</strong></p>
<ul>
<li><p>求中序线索二叉树中中序序列的第一个结点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">threadNode * <span class="title">firstNode</span><span class="params">(threadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;leftTag == <span class="number">0</span>)</span><br><span class="line">        p = p-&gt;leftChild;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求中序线索二叉树中结点p在中序序列下的后继结点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">threadNode * <span class="title">nextNode</span><span class="params">(threadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rightTag == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> firstNode(p-&gt;rightChild);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p-&gt;rightChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">inThreadNode</span><span class="params">(threadNode *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(threadNode *p = firstNode(T);p != <span class="literal">NULL</span>;p = nextNode(p))</span><br><span class="line">        visit(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h1><ol>
<li><p>双亲表示法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	ElemType data;<span class="comment">//数据</span></span><br><span class="line">	<span class="keyword">int</span> parent;<span class="comment">//双亲位置域</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Node nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">int</span> n;<span class="comment">//结点数</span></span><br><span class="line">&#125;Tree;</span><br></pre></td></tr></table></figure>

<p><img src="%5Cimages%5CdataStructure%5C10.jpg" alt=""></p>
</li>
<li><p>孩子表示法</p>
<p>将每个结点的孩子结点都用单链表链接起来形成一个线性结构</p>
<p><img src="%5Cimages%5CdataStructure%5C11.jpg" alt=""></p>
</li>
<li><p>孩子兄弟表示法</p>
<p>以二叉链表作为树的存储结构，每个结点包括：结点值、指向结点第一个孩子的指针、指向结点下一个兄弟结点的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	ElemType data;<span class="comment">//数据</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">firstChild</span>,*<span class="title">nextSibling</span>;</span><span class="comment">//第一个孩子和兄弟指针</span></span><br><span class="line">&#125;Node,*Node;</span><br></pre></td></tr></table></figure>

<p><img src="%5Cimages%5CdataStructure%5C12.jpg" alt=""></p>
</li>
</ol>
<p><strong>树、森林与二叉树的转换</strong></p>
<p>树转换为二叉树的规则：每个结点的左指针指向它的第一个孩子结点，右指针指向它在树中的相邻兄弟结点，由于根结点没有兄弟，因此由树转换而来的二叉树没有右子树。</p>
<p><img src="%5Cimages%5CdataStructure%5C13.jpg" alt=""></p>
<h1 id="树与二叉树的应用"><a href="#树与二叉树的应用" class="headerlink" title="树与二叉树的应用"></a>树与二叉树的应用</h1><ol>
<li><p>并查集</p>
</li>
<li><p>二叉排序树</p>
<p><strong>定义</strong>：</p>
<ul>
<li>若左子树非空，则左子树上所有结点关键值均小于根节点的关键值</li>
<li>若右子树非空，则右子树上所有结点关键值均大于根节点的关键值</li>
<li>左右子树本身也为一颗二叉排序树</li>
</ul>
<p><img src="%5Cimages%5CdataStructure%5C14.jpg" alt=""></p>
<p><strong>二叉排序树的查找</strong></p>
<p>从根节点开始，若给定值与根结点关键值相等则查找成功；若根结点大于给定值则在左子树中查找；若根结点小于给定值则在右子树中查找</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找函数返回指向关键值为key的结点指针p</span></span><br><span class="line"><span class="function">biTreeNode * <span class="title">biTreeNodeSearch</span><span class="params">(biTree tree,ElemType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(tree != <span class="literal">NULL</span> &amp;&amp; key != tree-&gt;data)&#123;</span><br><span class="line">        <span class="keyword">if</span>(key &lt; tree-&gt;data)</span><br><span class="line">            tree = tree-&gt;leftChild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tree = tree-&gt;rightChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二叉排序树的插入</strong></p>
<p>若原二叉树为空，则直接插入结点；若根结点大于给定值则插入到左子树中；若根结点小于给定值则插入到右子树中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">![<span class="number">15</span>](F:\jiaopaner\source\images\dataStructure\<span class="number">15.</span>jpg)<span class="function"><span class="keyword">bool</span> <span class="title">biTreeNodeInsert</span><span class="params">(biTree tree,ElemType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree == null)&#123;</span><br><span class="line">        tree = (biTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(biTreeNode));</span><br><span class="line">        tree-&gt;data = key;</span><br><span class="line">        tree-&gt;leftChild=  tree-rightChild = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key == tree-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; tree-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> biTreeNodeInsert(tree-&gt;lefgChild,key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; tree-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> biTreeNodeInsert(tree-&gt;rightChild,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二叉排序树的删除</strong></p>
<ul>
<li><p>删除的结点为叶结点，则直接删除，不会破坏二叉树的排序性质</p>
</li>
<li><p>若删除结点$z$只有一颗左子树(或右子树)，则让$z$的左子树(或右子树)成为$z$结点的父结点的子树，即代替$z$的位置</p>
<p><img src="%5Cimages%5CdataStructure%5C15.jpg" alt=""></p>
<p><img src="%5Cimages%5CdataStructure%5C16.jpg" alt=""></p>
</li>
<li><p>若删除结点$z$有左、右子树，则令$z$的右子树中中序第一个子女代替$z$，并转换相应的位置</p>
<p><img src="%5Cimages%5CdataStructure%5C17.jpg" alt=""></p>
</li>
</ul>
</li>
<li><p>平衡二叉树</p>
<p>定义：任意结点的左右子树高度差不超过1的二叉排序树</p>
<p><strong>平衡二叉树的插入</strong></p>
<p>平衡二叉树插入新结点会破坏平衡性，因此插入新结点后需要做调整，以重新达到平衡性</p>
<p><img src="%5Cimages%5CdataStructure%5C18.jpg" alt=""></p>
<p>平衡性调整策略</p>
<ul>
<li><p>LL平衡旋转(右单旋转)</p>
<p>在根结点$A$的左孩子(L)结点$B$的左子树(L)结点$BL$上插入了结点,破坏了平衡性的调整策略，$B$结点右上旋转代替$A$成为根结点，$A$结点成为$B$的右子树根结点，且$B$的右子树作为$A$结点的左子树</p>
<p><img src="%5Cimages%5CdataStructure%5C19.jpg" alt=""></p>
</li>
<li><p>RR平衡旋转(左单旋转)</p>
<p>在根结点$A$的右孩子(R)结点$C$的右子树(R)结点$CR$上插入了结点,破坏了平衡性的调整策略，$C$结点左上旋转代替$A$成为根结点，$A$结点成为$C$的左子树根结点，且$C$的左子树作为$A$结点的右子树</p>
<p><img src="%5Cimages%5CdataStructure%5C20.jpg" alt=""></p>
</li>
<li><p>LR平衡旋转(先左后右双旋转)</p>
<p>在根结点$A$的左孩子(L)结点$B$的右子树(R)结点$BR$上插入了结点,破坏了平衡性的调整策略</p>
<p><img src="%5Cimages%5CdataStructure%5C21.jpg" alt=""></p>
</li>
<li><p>RL平衡旋转(先右后左双旋转)</p>
<p>在根结点$A$的右孩子(R)结点$C$的左子树(L)结点$CR$上插入了结点,破坏了平衡性的调整策略</p>
<p><img src="%5Cimages%5CdataStructure%5C22.jpg" alt=""></p>
</li>
</ul>
</li>
<li><p><strong>哈夫曼树和哈夫曼编码</strong></p>
<p>树结点赋予权值，从根结点到任意结点的路径长度(经过的边数)与该结点权值的乘积称为该结点的带权路径长度，树中所有<strong>叶结点</strong>的带权路径长度之和称为该树的带权路径长度$WPL$。<br>$$<br>WPL=\sum_{i=1}^{n}w_i\times l_i<br>$$<br>其中$w_i$为第$i$个叶结点的权值，$l_i$为根结点到第$i$个叶结点的路径长度</p>
<p>在含有$n$个带权叶子结点的二叉树中，其中$WPL$最小的二叉树称为哈夫曼树(最优二叉树)</p>
<p><img src="%5Cimages%5CdataStructure%5C23.jpg" alt=""></p>
<p>$WPL(a)=7\times2+5\times2+2\times2+4\times2=36$</p>
<p>$WPL(b)=7\times3+5\times3+1\times2+4\times2=46$</p>
<p>$WPL(c)=7\times1+5\times2+2\times3+4\times3=35$</p>
<p>$c$树为哈夫曼树</p>
<p><strong>哈夫曼树的构造</strong></p>
<ul>
<li>将$n$个带权结点作为$n$课仅含一个结点的二叉树，构成森林$F$</li>
<li>构造一个新结点$P$，并从$F$中选取两棵权值最小的树作为新结点的左、右子树，将新结点的权值置为左、右子树权值之和</li>
<li>从$F$中删除上述选取的两棵树，同时将新结点$P$加入$F$中</li>
<li>重复2、3步骤，直至$F$中只剩下一棵树</li>
</ul>
<p><img src="%5Cimages%5CdataStructure%5C24.jpg" alt=""></p>
<p><strong>哈夫曼编码</strong></p>
<p>对频率高的字符赋予短编码，对频率低的字符赋予长编码，从而使字符平均编码长度减短</p>
<p>哈夫曼编码：对每个字符当作一个独立的结点，其权值为字符出现的次数，构造哈夫曼树</p>
<p><img src="%5Cimages%5CdataStructure%5C25.jpg" alt=""></p>
</li>
</ol>
<p>版权声明：原创,转载请注明来源,否则律师函警告</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jiaopaner.github.io/2019/06/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(4)%20%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/" data-id="ck4mhjkdb003kw6zw9k327t62" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构(3) 栈和队列" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(3)%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" class="article-date">
  <time datetime="2019-06-10T06:28:59.000Z" itemprop="datePublished">2019-06-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(3)%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/">数据结构(3) 栈和队列</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p><strong>栈</strong>：只允许在一端进行插入或删除操作的线性表。</p>
<p>栈顶：允许插入和删除的一端。栈底：固定的，不允许插入和删除的一端。</p>
<p>特性：先进后出。</p>
<h2 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];<span class="comment">//存放栈中元素</span></span><br><span class="line">    <span class="keyword">int</span> top;<span class="comment">//栈顶指针 空栈 top=-1</span></span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line">#初始化</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initStack</span><span class="params">(Stack &amp;s)</span></span>&#123;</span><br><span class="line">    s.top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">#判断栈空</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">stackEmpty</span><span class="params">(Stack &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">#进栈</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(Stack &amp;s,ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top == MaxSize<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s.data[++s.top] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">#出栈</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(Stack &amp;s,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = s.data[s.top--];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">#读取栈顶元素</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getTop</span><span class="params">(Stack &amp;s,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = s.data[s.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈的链式存储"><a href="#栈的链式存储" class="headerlink" title="栈的链式存储"></a>栈的链式存储</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *LinkStack;</span><br></pre></td></tr></table></figure>

<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p><strong>队列</strong>：只允许在表的一端进行插入，在表的另一端进行删除。</p>
<p>队头：允许删除的一端。队尾：允许插入的一端。</p>
<p>特性：先进先出</p>
<h2 id="队列的顺序存储结构"><a href="#队列的顺序存储结构" class="headerlink" title="队列的顺序存储结构"></a>队列的顺序存储结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];<span class="comment">//存放队列元素</span></span><br><span class="line">    <span class="keyword">int</span> front,rear;<span class="comment">//队头指针、队尾指针</span></span><br><span class="line">&#125;Queue;</span><br></pre></td></tr></table></figure>

<p><strong>循环队列</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#初始化</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(Queue &amp;<span class="built_in">queue</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>.rear = <span class="built_in">queue</span>.front = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">#判断队列空</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(Queue <span class="built_in">queue</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span>.rear == <span class="built_in">queue</span>.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">#入队</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">enQueue</span><span class="params">(Queue &amp;<span class="built_in">queue</span>,ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">queue</span>.rear+<span class="number">1</span>)%MaxSize == <span class="built_in">queue</span>.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//队列满</span></span><br><span class="line">    <span class="built_in">queue</span>.data[<span class="built_in">queue</span>.rear] = x;</span><br><span class="line">    <span class="built_in">queue</span>.rear = (<span class="built_in">queue</span>.rear+<span class="number">1</span>) % MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">#出队</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">(Queue &amp;<span class="built_in">queue</span>,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span>.rear+<span class="number">1</span> == <span class="built_in">queue</span>.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//队列空</span></span><br><span class="line">    x = <span class="built_in">queue</span>.data[<span class="built_in">queue</span>.font];</span><br><span class="line">    <span class="built_in">queue</span>.front = (<span class="built_in">queue</span>.front+<span class="number">1</span>) % MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列的链式存储结构"><a href="#队列的链式存储结构" class="headerlink" title="队列的链式存储结构"></a>队列的链式存储结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span></span></span><br><span class="line"><span class="class">&#125;<span class="title">LinkNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    LinkNode *front,*rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line">#初始化</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;<span class="built_in">queue</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>.front = <span class="built_in">queue</span>.rear=(LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    <span class="built_in">queue</span>.front.next = null;</span><br><span class="line">&#125;</span><br><span class="line">#判断队列空</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(LinkQueue <span class="built_in">queue</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span>.front == <span class="built_in">queue</span>.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">#入队</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(LinkQueue &amp;<span class="built_in">queue</span>,ElemType x)</span></span>&#123;</span><br><span class="line">    s = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = null;</span><br><span class="line">    <span class="built_in">queue</span>.rear-&gt;next = s;</span><br><span class="line">    <span class="built_in">queue</span>.rear = s;</span><br><span class="line">&#125;</span><br><span class="line">#出队</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">(LinkQueue &amp;<span class="built_in">queue</span>,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span>.front == <span class="built_in">queue</span>.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    p = <span class="built_in">queue</span>.front-&gt;next;</span><br><span class="line">    x = p-&gt;data;</span><br><span class="line">    <span class="built_in">queue</span>.front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span>.rear == p)</span><br><span class="line">        <span class="built_in">queue</span>.rear = <span class="built_in">queue</span>.front;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="栈和队列的应用"><a href="#栈和队列的应用" class="headerlink" title="栈和队列的应用"></a>栈和队列的应用</h1><p>版权声明：原创,转载请注明来源,否则律师函警告</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jiaopaner.github.io/2019/06/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(3)%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" data-id="ck4mhjkdh0042w6zwcrfk6cdz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-操作系统(2) 进程管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(2)%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" class="article-date">
  <time datetime="2019-06-07T12:50:53.000Z" itemprop="datePublished">2019-06-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(2)%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">操作系统(2) 进程管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h1><p>在多道程序环境下，允许多个程序并发执行，因此失去封闭性并具有间断性和不可再现性的特征，为此引入进程，更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性。</p>
<p><strong>进程控制块(PCB)</strong>：描述进程的基本情况和运行状态，进而控制和管理进程。</p>
<p>PCB是进程存在的唯一标志。创建进程实质是创建PCB，撤销进程实质是撤销PCB。</p>
<p><strong>进程映像</strong>：由程序段、相关数据段、PCB组成。</p>
<p><strong>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</strong></p>
<p><strong>特征</strong></p>
<ul>
<li>动态性：进程是程序的一次执行，具有生命周期。动态性是进程最基本的特征。</li>
<li>并发性、独立性、异步性、结构性</li>
</ul>
<p><strong>进程的状态与转换</strong></p>
<p><img src="%5Cimages%5Csystem%5C1.jpg" alt=""></p>
<p><strong>进程创建过程</strong></p>
<p>终端用户登录、作业调度、系统提供服务、用户程序的应用等请求都会引起进程的创建。</p>
<ol>
<li>为新进程分配唯一的进程标识号，申请空白的PCB；</li>
<li>为进程分配资源，分配进程的程序、数据和用户栈必要的内存空间；</li>
<li>初始化PCB，初始化标志信息、处理机状态信息、处理机控制信息、设置进程优先级；</li>
<li>将新进程插入到就绪队列等待调度；</li>
</ol>
<p><strong>进程终止过程</strong></p>
<p>正常结束、异常结束(存储区越界、保护错、非法指令、特权指令错、I/O故障)、外界干预等都会引起进程的终止。</p>
<ol>
<li>根据被终止进程标识符检索PCB，读取该进程的状态；</li>
<li>若被终止的进程处于执行状态则立即终止，将处理机资源分配给其他进程；</li>
<li>若有子进程，将其所有的子进程终止；</li>
<li>释放该进程的所有资源；</li>
<li>将PCB从所在队列中删除</li>
</ol>
<p>进程的创建、撤销以及要求系统设备完成的I/O操作都是利用系统调用而进入内核。</p>
<p><strong>进程的切换</strong></p>
<ol>
<li>保存处理机上下文，包括程序计数器和其他寄存器；</li>
<li>更新PCB信息；</li>
<li>进程的PCB移入相应的队列，如就绪、阻塞；</li>
<li>选择另一个进程，并更新其PCB；</li>
<li>更新内存管理的数据结构；</li>
<li>恢复处理机上下文；</li>
</ol>
<p><strong>进程的通信</strong></p>
<ul>
<li><p>共享存储</p>
<p>通过对共享空间进行读写操作实现进程间的信息交换</p>
</li>
<li><p>消息传递</p>
<p>进程间的数据交换以格式化的消息为单位</p>
</li>
<li><p>管道通信</p>
<p>消息传递的特殊方式，所谓管道是指连接一个读进程和一个写进程以实现进程之间通信的一个共享文件。</p>
<p>写进程以字符流的形式将大量的数据写入管道。</p>
</li>
</ul>
<p><strong>线程</strong></p>
<p>线程是基本的CPU执行单元，线程是进程中的一个实体，是被系统独立调度和分派的基本单位。线程不拥有系统资源，只拥有在运行中必不可少的资源，可与同属同一进程的其他线程共享进程所拥有的全部资源。同一进程中的多个线程可以并发执行。</p>
<p>在传统操作系统中，拥有资源和独立调度的基本单位都是进程，引入多线程的操作系统中，线程是独立调度的基本单位，进程是拥有资源的基本单位。</p>
<h1 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h1><p>处理及调度是对处理机进行分配，即从进程就绪队列中按照一定的算法选择进程并为其分配处理机，以实现进程并发执行。</p>
<p><strong>调度层次</strong></p>
<ul>
<li>作业调度：只调入/调出一次；</li>
<li>中级调度：内存调度，提高内存利用率和系统吞吐量，进程的挂起/就绪；</li>
<li>进程调度：按照某种算法调度进程执行； </li>
</ul>
<p>进程调度和切换程序是操作系统的内核程序。</p>
<p><strong>进程调度方式</strong></p>
<ul>
<li>非剥夺方式/非抢占方式：一旦将CPU分配给某个进程，只有当该进程执行完或转换到等待状态时才会进行进程的切换。实现简单、开销小，适用于大多数批处理系统，但不适用于实时和分时系统。</li>
<li>剥夺调度方式/抢占方式：若有某个更紧迫的进程需要调度，则立即暂定正在运行的进程，将处理机分配给更为紧迫的进程。剥夺原则：优先权、短进程优先、时间片原则。</li>
</ul>
<p><strong>调度的基本原则</strong></p>
<ol>
<li><p>CPU利用率</p>
</li>
<li><p>系统吞吐量：单位时间内CPU完成的作业数量；</p>
</li>
<li><p>周转时间：作业提交到作业完成的时间；</p>
<p>周转时间 = 作业完成时间 - 作业提交时间</p>
<p>带权周转时间 = $\frac{作业周转时间}{作业实际运行时间}$</p>
</li>
<li><p>等待时间</p>
</li>
<li><p>响应时间</p>
</li>
</ol>
<p><strong>调度算法</strong></p>
<ul>
<li><p>先来先服务(FCFS)调度算法：每次从就绪队列中选择最先进入该队列的进程进行执行，直到进程完成或因某种原因阻塞才释放处理机；算法简单、效率低，对长作业有利，利于CPU繁忙型作业、不利于I/O繁忙型作业。</p>
</li>
<li><p>短作业优先(SJF)调度算法：每次从就绪队列中选择一个估计运行时间最短的进程进行执行。对长作业不利、未考虑作业紧迫度，平均等待时间、平均周转时间最少。</p>
</li>
<li><p>优先级调度算法：每次从就绪队列中选择优先级最高的进程进行执行。</p>
</li>
<li><p>高响应比优先调度算法：同时考虑每个进程的等待时间和估计的运行时间，在进行进程调度前先计算就绪队列中每个进程的响应比，选择响应比最高的进程进行执行。</p>
<p>响应比$R_p=\frac{等待时间+要求服务的时间}{要求服务的时间}$</p>
</li>
<li><p>时间片轮转调度算法：总是选择就绪队列中第一个进程进行执行(先来先服务)，但仅能运行一个时间片，时间片用完即使进程并未完成运行，也必须释放处理机给下一个就绪进程。被剥夺的进程则重新排队，等待调度。</p>
</li>
<li><p>多级反馈队列调度算法：</p>
<ol>
<li>设置多个队列，赋予每个队列不同的优先级，第1级队列优先级最高，依次降低;</li>
<li>赋予每个队列不同的进程执行时间片，第1级队列时间片最短，依次递增；</li>
<li>新进程首先进入第1级队列末尾排队，按照先来先服务调度算法等待调度，若该进程能在第1级的时间片内完成，则撤离系统，否则转入下一级队列末尾排队，依次类推。</li>
<li>仅当第1级队列为空时才调度第2级队列的进程执行，依次类推。若处理正在执行第$i$级队列中的进程，当新进程进入优先级较高的$i-1$级别队列时，则新进程抢占处理机，当前第$i$级进程转入第$i$级末尾重新排队。</li>
</ol>
</li>
</ul>
<h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><p>协调进程之间互相制约的关系。</p>
<ol>
<li><p>临界资源：一次仅允许一个进程使用的资源称为临界资源。对临界资源的访问必须互斥进行。</p>
</li>
<li><p>同步：需要在某些位置上协调进程之间的<strong>工作次序</strong>而等待、传递信息所产生的制约关系。</p>
</li>
<li><p>互斥：当一个进程使用临界资源时，其他要求进入临界区的进程必须等待。</p>
<p><strong>准则</strong>：</p>
</li>
</ol>
<ul>
<li>空闲让进：临界区空闲时，允许一个请求进入临界区的进程立即进入临界区</li>
<li>忙则等待：当已有进程进入临界区，其他试图进入临界区的进程必须等待<ul>
<li>有限等待：对访问请求的进程，应保证在有限时间内进入临界区</li>
</ul>
</li>
<li>让权等待：当进程不能进入临界区时，应立即释放处理器，防止进程忙等待</li>
</ul>
<p><strong>互斥的基本方法</strong></p>
<p>1.软件实现方法</p>
<p><strong>单标志法</strong></p>
<p>设置公用整型变量turn,用于指示被允许进入临界区的进程编号，进程必须交替进入临界区，否则违背空闲让进</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P0进程</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">turn</span>!=<span class="number">0</span>); <span class="comment">//等待</span></span><br><span class="line">critical section;<span class="comment">//临界区</span></span><br><span class="line"><span class="built_in">turn</span> = <span class="number">1</span>;</span><br><span class="line">remainder section;</span><br><span class="line"><span class="comment">//P1进程</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">turn</span>!=<span class="number">1</span>); <span class="comment">//等待</span></span><br><span class="line">critical section;<span class="comment">//临界区</span></span><br><span class="line"><span class="built_in">turn</span> = <span class="number">0</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>

<p><strong>双标志法</strong></p>
<p>设置$flag[k]$,进入临界区前先检查进程$P_k$是否进入临界区,进程之间不需要交替进入，缺点为进程$p_i和p_j$可能同时进入临界区，违背忙等待</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Pi进程</span></span><br><span class="line"><span class="keyword">while</span>(flag[j] == <span class="literal">true</span>); <span class="comment">//等待</span></span><br><span class="line">flag[i] = <span class="literal">true</span>;</span><br><span class="line">critical section;<span class="comment">//临界区</span></span><br><span class="line">flag[i] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"><span class="comment">//Pj进程</span></span><br><span class="line"><span class="keyword">while</span>(flag[i] == <span class="literal">true</span>); <span class="comment">//等待</span></span><br><span class="line">flag[j] = <span class="literal">true</span>;</span><br><span class="line">critical section;<span class="comment">//临界区</span></span><br><span class="line">flag[j] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>

<p>设置$flag[k]$,进入临界区前先设置本身进程标志为true,再检查进程$P_k$是否进入临界区,缺点是由于进程互相“谦让”容易形成饥饿现象，即进程都无法进入临界区</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Pi进程</span></span><br><span class="line">flag[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[j] == <span class="literal">true</span>); <span class="comment">//等待</span></span><br><span class="line">critical section;<span class="comment">//临界区</span></span><br><span class="line">flag[i] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"><span class="comment">//Pj进程</span></span><br><span class="line">flag[j] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[i] == <span class="literal">true</span>); <span class="comment">//等待</span></span><br><span class="line">critical section;<span class="comment">//临界区</span></span><br><span class="line">flag[j] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>

<p><strong>Peterson 算法</strong></p>
<p>进入临界区前先设置本身进程标志为true,再设置turn标志，最后检查进程$P_k$是否进入临界区</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Pi进程</span></span><br><span class="line">flag[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">turn</span> = j;</span><br><span class="line"><span class="keyword">while</span>(flag[j] == <span class="literal">true</span> &amp;&amp; <span class="built_in">turn</span> == j); <span class="comment">//等待</span></span><br><span class="line">critical section;<span class="comment">//临界区</span></span><br><span class="line">flag[i] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"><span class="comment">//Pj进程</span></span><br><span class="line">flag[j] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">turn</span> = i;</span><br><span class="line"><span class="keyword">while</span>(flag[i] == <span class="literal">true</span> &amp;&amp; <span class="built_in">turn</span> == i); <span class="comment">//等待</span></span><br><span class="line">critical section;<span class="comment">//临界区</span></span><br><span class="line">flag[j] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>

<p>2.硬件实现方法</p>
<p><strong>中断屏蔽</strong></p>
<p>CPU只在发生中断时引起进程切换，屏蔽中断能够保证当前运行的进程将临界区的代码顺利执行完毕</p>
<p><strong>硬件指令</strong></p>
<p>TestAndSet指令(原子操作)，为每个临界资源设置共享布尔变量lock,true表示资源正被占用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TestAndSet</span><span class="params">(<span class="keyword">bool</span> *lock)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> old;</span><br><span class="line">    old = *lock;</span><br><span class="line">    *lock = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进程</span></span><br><span class="line"><span class="keyword">while</span>(TestAndSet(&amp;lock)) <span class="comment">//等待</span></span><br><span class="line">critical section;<span class="comment">//临界区</span></span><br><span class="line">lock = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>

<p><strong>Swap指令</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Swap(<span class="keyword">bool</span> *x,<span class="keyword">bool</span> *y)&#123;</span><br><span class="line">    <span class="keyword">bool</span> temp;</span><br><span class="line">    temp = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进程</span></span><br><span class="line">key = <span class="literal">true</span>;<span class="comment">//为每个进程设置局部布尔变量</span></span><br><span class="line"><span class="keyword">while</span>(key != <span class="literal">false</span>) <span class="comment">//等待</span></span><br><span class="line">    Swap(*lock,&amp;key)</span><br><span class="line">critical section;<span class="comment">//临界区</span></span><br><span class="line">lock = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>



<p><strong>信号量</strong></p>
<p>1.整型信号量：定义为表示资源数目的整型量$S$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//申请资源</span></span><br><span class="line">wait(S)&#123;</span><br><span class="line">    <span class="keyword">while</span>(S &lt;= <span class="number">0</span>);</span><br><span class="line">    S = S<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">signal(S)&#123;</span><br><span class="line">    S = S+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.记录型信号量：定义为表示资源数目的整型量$value$和进程链表$L$(用于链接等待该资源的进程)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span></span><br><span class="line">&#125;semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">//申请资源</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">    S.value--;</span><br><span class="line">    <span class="keyword">if</span>(S.value &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        add <span class="keyword">this</span> <span class="built_in">process</span> to S.L;</span><br><span class="line">        block(S.L);<span class="comment">//进程阻塞，放弃处理机</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">    S.value++;</span><br><span class="line">    <span class="keyword">if</span>(S.value &lt;= <span class="number">0</span>)&#123;<span class="comment">//仍有进程等待</span></span><br><span class="line">        <span class="built_in">remove</span> a <span class="built_in">process</span> P from S.L;</span><br><span class="line">        wakeup(P);<span class="comment">//唤醒进程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用信号量实现进程同步</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进程Py中的y语句需要使用进程Px中x语句的运行结果</span></span><br><span class="line">semaphore S = <span class="number">0</span>；</span><br><span class="line">Px()&#123;</span><br><span class="line">	...</span><br><span class="line">	x；</span><br><span class="line">	singal(S);<span class="comment">//通知进程Py,语句x已完成</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">Py()&#123;</span><br><span class="line">	...</span><br><span class="line">	wait(S);<span class="comment">//检查语句x是否已完成</span></span><br><span class="line">	y；</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用信号量实现进程互斥</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore S = <span class="number">1</span>;<span class="comment">//初始化信号量 资源数量</span></span><br><span class="line">Px()&#123;</span><br><span class="line">	...</span><br><span class="line">    wait(S);<span class="comment">//访问资源，加锁</span></span><br><span class="line">	x；<span class="comment">//临界区</span></span><br><span class="line">	singal(S);<span class="comment">//访问结束，解锁</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">Py()&#123;</span><br><span class="line">	...</span><br><span class="line">	wait(S);<span class="comment">//访问资源，加锁</span></span><br><span class="line">	y；<span class="comment">//临界区</span></span><br><span class="line">	singal(S);<span class="comment">//访问结束，解锁</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用信号量实现前驱关系</p>
<p><img src="%5Cimages%5Csystem%5C2.jpg" alt=""></p>
<p>$a:S1 \rightarrow S2,b:S1\rightarrow S3;c:S2 \rightarrow S4,d:S2\rightarrow S5;$</p>
<p>$e:S3 \rightarrow S6,f:S4\rightarrow S6,g:S5 \rightarrow S6$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">semaphore a=b=c=d=e=f=g=<span class="number">0</span>;<span class="comment">//</span></span><br><span class="line">S1()&#123;</span><br><span class="line">	...</span><br><span class="line">	singal(a);singal(b);<span class="comment">//S1完成</span></span><br><span class="line">&#125;</span><br><span class="line">S2()&#123;</span><br><span class="line">	...</span><br><span class="line">	wait(a);</span><br><span class="line">	...</span><br><span class="line">	singal(c);singal(d);<span class="comment">//S2完成</span></span><br><span class="line">&#125;</span><br><span class="line">S3()&#123;</span><br><span class="line">	...</span><br><span class="line">	wait(b);</span><br><span class="line">	...</span><br><span class="line">	singal(e);<span class="comment">//S3完成</span></span><br><span class="line">&#125;</span><br><span class="line">S4()&#123;</span><br><span class="line">	...</span><br><span class="line">	wait(c);</span><br><span class="line">	...</span><br><span class="line">	singal(f);<span class="comment">//S4完成</span></span><br><span class="line">&#125;</span><br><span class="line">S5()&#123;</span><br><span class="line">	...</span><br><span class="line">	wait(d);</span><br><span class="line">	...</span><br><span class="line">	singal(g);<span class="comment">//S5完成</span></span><br><span class="line">&#125;</span><br><span class="line">S6()&#123;</span><br><span class="line">	wait(e);</span><br><span class="line">    wait(f);</span><br><span class="line">    wait(g);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>经典同步问题</strong></p>
<ol>
<li><p>生产消费者问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//临界区互斥信号量</span></span><br><span class="line">semaphore empty = n;<span class="comment">//空闲缓冲区数</span></span><br><span class="line">semaphore full = <span class="number">0</span>;<span class="comment">//满缓冲区数</span></span><br><span class="line"><span class="comment">//生产者进程</span></span><br><span class="line">producer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        produce an item in nextp;</span><br><span class="line">        wait(empty);<span class="comment">//获取空缓冲区单元</span></span><br><span class="line">        wait(mutex);<span class="comment">//进入临界区</span></span><br><span class="line">        add nextp ti <span class="built_in">buffer</span>;<span class="comment">//将数据放入缓冲区</span></span><br><span class="line">        singal(mutex);</span><br><span class="line">        singal(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者进程</span></span><br><span class="line">consumer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        wait(full);</span><br><span class="line">        wait(mutex);</span><br><span class="line">        <span class="built_in">remove</span> an item from <span class="built_in">buffer</span>;</span><br><span class="line">        singal(mutex);</span><br><span class="line">        singal(empty);</span><br><span class="line">        consume the item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//empty和full的wait操作必须在mutex前</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>读者-写者问题</p>
<ul>
<li>允许多个读者同时对共享文件进行读操作</li>
<li>只允许一个写者向共享文件写数据</li>
<li>写者完成写操作之前不允许其他读者进行读操作</li>
<li>写者执行写操作之前，应让已有读者和写者全部退出</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读进程优先</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//当前读者数量</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//用于更新count时的互斥</span></span><br><span class="line">semaphore rw = <span class="number">1</span>;<span class="comment">//互斥访问共享文件</span></span><br><span class="line"><span class="comment">//写者进程</span></span><br><span class="line">writer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        wait(rw);</span><br><span class="line">        writing;</span><br><span class="line">        signal(rw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读者进程</span></span><br><span class="line">reader()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        wait(mutex);</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)<span class="comment">//第一个读者读取时</span></span><br><span class="line">            wait(rw);<span class="comment">//阻止写进程写操作</span></span><br><span class="line">        count++;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        reading;</span><br><span class="line">        wait(mutex);<span class="comment">//读取完毕</span></span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)<span class="comment">//当最后一个读进程读取完毕</span></span><br><span class="line">            signal(rw)</span><br><span class="line">        signal(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写进程优先</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//当前读者数量</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//用于更新count时的互斥</span></span><br><span class="line">semaphore rw = <span class="number">1</span>;<span class="comment">//互斥访问共享文件</span></span><br><span class="line">semaphore w = <span class="number">1</span>;<span class="comment">//用于实现写优先</span></span><br><span class="line"><span class="comment">//写者进程</span></span><br><span class="line">writer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        wait(w)</span><br><span class="line">        wait(rw);</span><br><span class="line">        writing;</span><br><span class="line">        signal(rw);</span><br><span class="line">        signal(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读者进程</span></span><br><span class="line">reader()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        wait(w);<span class="comment">//无写进程时进入</span></span><br><span class="line">        wait(mutex);</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)<span class="comment">//第一个读者读取时</span></span><br><span class="line">            wait(rw);<span class="comment">//阻止写进程写操作</span></span><br><span class="line">        count++;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(w);</span><br><span class="line">        reading;</span><br><span class="line">        wait(mutex);<span class="comment">//读取完毕</span></span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)<span class="comment">//当最后一个读进程读取完毕</span></span><br><span class="line">            signal(rw)</span><br><span class="line">        signal(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>哲学家进餐问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;<span class="comment">//五根筷子</span></span><br><span class="line">semaphore mutex =  <span class="number">1</span>;<span class="comment">//设置取筷子的信号量</span></span><br><span class="line"><span class="comment">//i号哲学家进程</span></span><br><span class="line">Pi()&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        wait(mutex);</span><br><span class="line">        wait(chopstick[i]);<span class="comment">//取左边筷子</span></span><br><span class="line">        wait(chopstick[(i+<span class="number">1</span>]%<span class="number">5</span>);<span class="comment">//取右边筷子</span></span><br><span class="line">        signal(mutex);</span><br><span class="line">        eat;</span><br><span class="line">        signal(chopstick[i]);</span><br><span class="line">        signal(chopstick[(i+<span class="number">1</span>]%<span class="number">5</span>);</span><br><span class="line">        think;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>吸烟者问题w</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">random</span>;</span><br><span class="line">semaphore offerTobaccoAndPaper;<span class="comment">//烟草和纸</span></span><br><span class="line">semaphore offerTobaccoAndGlue;<span class="comment">//烟草和胶水</span></span><br><span class="line">semaphore offerPaperAndGlue;<span class="comment">//纸和胶水</span></span><br><span class="line">semaphore finish = <span class="number">0</span>;<span class="comment">//记录抽烟完成</span></span><br><span class="line"><span class="comment">//供应者进程</span></span><br><span class="line">provider()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">random</span> = rand.<span class="built_in">random</span>(<span class="number">3</span>);<span class="comment">//1-3的整数随机数</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">random</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            signal(offerTobaccoAndPaper);<span class="comment">//提供烟草和纸</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">random</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            signal(offerTobaccoAndGlue);<span class="comment">//提供烟草和胶水</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            signal(offerPaperAndGlue);<span class="comment">//提供纸和胶水</span></span><br><span class="line">        &#125;</span><br><span class="line">        wait(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拥有烟草者进程</span></span><br><span class="line"><span class="built_in">process</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        wait(offerPaperAndGlue);</span><br><span class="line">        ...</span><br><span class="line">        signal(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拥有纸者进程</span></span><br><span class="line"><span class="built_in">process</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        wait(offerTobaccoAndGlue);</span><br><span class="line">        ...</span><br><span class="line">        signal(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拥有胶水者进程</span></span><br><span class="line"><span class="built_in">process</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        wait(offerTobaccoAndPaper);</span><br><span class="line">        ...</span><br><span class="line">        signal(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>定义：多个进程因竞争不可剥夺资源而造成的互相等待，若无外力作用，进程都将无法向前推进。</p>
<p>产生死锁的必要条件(同时满足)</p>
<ul>
<li>互斥条件：某资源仅由一个进程占有</li>
<li>不剥夺条件：进程所获得资源在未使用完毕前，不可直接剥夺</li>
<li>请求和保持条件：进程已获得资源A，同时提出对资源B的请求，单资源B被其他进程占有，此失请求进程被阻塞，但对其资源A保持不放</li>
<li>循环等待条件：$p_i$等待的资源被$p_{i+1}$占有,$\dots$,$p_n$等待的资源被$p_0$占有</li>
</ul>
<p>死锁处理策略</p>
<ol>
<li>预防死锁：设置限制条件，破环产生死锁的必要条件</li>
<li>避免死锁：资源动态分配中，用某种方法防止系统进入不安全状态</li>
<li>死锁检测及解除：允许死锁发生，通过系统检测及时地解除死锁</li>
</ol>
<p><strong>银行家算法</strong></p>
<p>可利用资源矢量Available：每类资源可用的数目</p>
<p>最大需求矩阵Max：每个进程对每类资源的最大需求</p>
<p>分配矩阵Allocation：每个进程已分配到每类资源数目</p>
<p>需求矩阵Need：每个进程尚需的每类资源数目 $Need = Max - Allocation$</p>
<p>假设系统中有5个进程$p_0,p_1,p_2,p_3,p_4$和三类资源${A,B,C}$,各类资源数目分别为$10、5、7$,在$t_0$时刻资源分配情况如下表，求资源分配安全序列。</p>
<p><img src="%5Cimages%5Csystem%5C3.jpg" alt=""></p>
<ol>
<li><p>求出Need矩阵<br>$$<br>\begin{bmatrix}<br>7 &amp; 5 &amp; 3\<br>3 &amp; 2 &amp; 2\<br>9 &amp; 0 &amp; 2\<br>2 &amp; 2 &amp; 2\<br>4 &amp; 3 &amp; 3</p>
<h2 id="end-bmatrix-MAX"><a href="#end-bmatrix-MAX" class="headerlink" title="\end{bmatrix}(MAX)"></a>\end{bmatrix}(MAX)</h2><p>\begin{bmatrix}<br>0 &amp; 1 &amp; 0\<br>2 &amp; 0 &amp; 0\<br>3 &amp; 0 &amp; 2\<br>2 &amp; 1 &amp; 1\<br>0 &amp; 0 &amp; 2</p>
<h1 id="end-bmatrix-Allocation"><a href="#end-bmatrix-Allocation" class="headerlink" title="\end{bmatrix}(Allocation)"></a>\end{bmatrix}(Allocation)</h1><p>\begin{bmatrix}<br>7 &amp; 4 &amp; 3\<br>1 &amp; 2 &amp; 2\<br>6 &amp; 0 &amp; 0\<br>0 &amp; 1 &amp; 1\<br>4 &amp; 3 &amp; 1<br>\end{bmatrix}(Need)<br>$$</p>
</li>
<li><p>Available向量与Need矩阵各行进行比较，找出比Available向量小的行，如$$<br>$$<br>p_1(1,2,2)&lt;(3,2,2)\p_3(0,1,1)&lt;(3,2,2)<br>$$<br>选择$p_1$(或$p_3$)加入安全序列</p>
</li>
<li><p>释放$p_1$所占有的资源，即把$p_1$的Allocation与Available向量相加,等到新的Available向量<br>$$<br>(2,0,0)+(3,3,2)=(5,3,2)=Available(new)<br>$$</p>
</li>
<li><p>再用更新后的Available向量和Need向量矩阵重复步骤2</p>
</li>
</ol>
<p>安全序列：$[p_1,p_3,p_4,p_2,p_0]$</p>
<p>版权声明：原创,转载请注明来源,否则律师函警告</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jiaopaner.github.io/2019/06/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(2)%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" data-id="ck4mhjkd4002vw6zw01nd682p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-操作系统(1) 概述" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1)%20%E6%A6%82%E8%BF%B0/" class="article-date">
  <time datetime="2019-06-06T06:05:23.000Z" itemprop="datePublished">2019-06-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1)%20%E6%A6%82%E8%BF%B0/">操作系统(1) 概述</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>操作系统是指控制和管理整个计算机系统的硬件和软件资源，并合理的组织调度计算机的工作和资源分配，以提供给用户和其他软件方便的接口和环境的程序集合。</p>
<h1 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h1><p><strong>并发</strong>：两个或多个事件在同一时间间隔内发生。</p>
<p><strong>共享</strong></p>
<ul>
<li>互斥共享：一段时间内只允许一个进程访问资源，其余进程必须等待；</li>
<li>同时访问：进程交替的对资源进行访问，即分时共享；</li>
</ul>
<p><strong>虚拟</strong>：物理上的若干个实体变为若干个逻辑上的对应物，如虚拟内存、虚拟处理器等。</p>
<p>虚拟技术：时分复用技术，如处理器的分时共享；空分复用技术，如虚拟存储器。</p>
<p><strong>异步</strong>：为允许多个程序并发执行，进程的执行并非一贯到底，而是走走停停，以不可预知的速度向前推进。</p>
<h1 id="目标和功能"><a href="#目标和功能" class="headerlink" title="目标和功能"></a>目标和功能</h1><p><strong>作为计算机系统的管理者</strong>:处理及管理、存储器管理、文件管理、设备管理。</p>
<p><strong>作为用户与计算机硬件件的接口</strong>：命令接口(联机命令接口、脱机命令接口)、程序接口(系统调用、广义指令)。</p>
<h1 id="操作系统发展分类"><a href="#操作系统发展分类" class="headerlink" title="操作系统发展分类"></a>操作系统发展分类</h1><ol>
<li><strong>手工操作阶段</strong>：用户独占全机、CPU等待手工操作</li>
<li><strong>批处理阶段</strong><ul>
<li>单道批处理系统：系统对作业的处理成批处理,内存中始终保留一道作业；</li>
<li>多道批处理系统：允许多个程序同时进入内存并在CPU上交替运行，由作业调度程序自动选择作业运行；</li>
<li>分时操作系统：共享主机、人机交互</li>
<li>实时操作系统：及时性和可靠性</li>
<li>网络操作系统和分布式操作系统</li>
<li>个人操作系统</li>
</ul>
</li>
</ol>
<h1 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h1><p>操作系统内核工作在核心态，用户程序工作在用户态，从用户态转为核心态的唯一途径是中断或异常。</p>
<p>访管指令在用户态执行，产生中断事件，转为核心态，但其不是特权指令，特权指令在和心态执行。</p>
<p><strong>时钟管理</strong>：实现进程的切换。</p>
<p><strong>中断机制</strong>：进程管理和调度、系统功能调用、设备驱动、文件访问。</p>
<ul>
<li>外中断：外设请求、人为干预</li>
<li>内中断(异常)：指令中断、硬件故障、软件中断</li>
</ul>
<p><strong>原语</strong>：底层公用小程序，处于操作系统最底层、程序的运行具有原子性、运行时间短。</p>
<p><strong>系统控制的数据结构和处理</strong>：作业控制块、进程控制块、设备控制块、链表、消息队列、缓冲区、内存分配表等。</p>
<p>系统调用需出发trap命令,进入中断处理的程序在核心态执行，属于操作系统程序。</p>
<p>版权声明：原创,转载请注明来源,否则律师函警告</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jiaopaner.github.io/2019/06/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1)%20%E6%A6%82%E8%BF%B0/" data-id="ck4mhjkd3002sw6zw8exk9fw6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构(2) 线性表" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(2)%20%E7%BA%BF%E6%80%A7%E8%A1%A8/" class="article-date">
  <time datetime="2019-05-30T07:16:30.000Z" itemprop="datePublished">2019-05-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(2)%20%E7%BA%BF%E6%80%A7%E8%A1%A8/">数据结构(2) 线性表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h3><p>线性表是具有相同数据类型的$n$个数据元素的有限序列<br>除第一个元素,每个元素有且仅有一个直接前驱,除最后一个元素,每个元素有且仅有一个后继 </p>
<h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>线性表的顺序存储称为顺序表,用一组地址连续的存储单元依次存储线性表中的数据元素，因此逻辑上相邻的两个元素在物理位置上也相邻</p>
<p><strong>顺序表描述</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType data[MaxSize];<span class="comment">//顺序表元素 静态分配</span></span><br><span class="line">	<span class="keyword">int</span> length;<span class="comment">//当前长度</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType *data;<span class="comment">//顺序表元素 动态分配数组的指针</span></span><br><span class="line">	<span class="keyword">int</span> MaxSize,length;<span class="comment">//数组最大容量和当前元素个数</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line">L.data = (ElemType *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType) * InitSize);<span class="comment">//c</span></span><br><span class="line">L.data = <span class="keyword">new</span> ElemType(InitSize);<span class="comment">//C++</span></span><br></pre></td></tr></table></figure>
<p>顺序表最主要的特点是随机访问,通过首地址和元素序号可在O(1)的时间复杂度内找到指定的元素</p>
<p><strong>插入操作</strong><br>在顺序表L的第i个位置插入新元素e</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (L.length &gt; = MaxSize)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> index = L.length; index &gt;= i; index--)</span><br><span class="line">		L.data[index] = L.data[index - <span class="number">1</span>];</span><br><span class="line">	L.data[i<span class="number">-1</span>] = e;</span><br><span class="line">	L.length++;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>删除操作</strong><br>删除顺序表L中第i个位置的元素,删除的元素用引用变量e返回</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	e = L.data[i - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> index = i; index &lt; L.length; index++)</span><br><span class="line">		L.data[index<span class="number">-1</span>] = L.data[index];</span><br><span class="line">	L.length--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>按值查找</strong><br>在顺序表L中查找一个元素值等于e的元素,并返回其位置(非索引)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span><span class="params">(SqList L,ElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> index;</span><br><span class="line">	<span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; L.length; index++)</span><br><span class="line">		<span class="keyword">if</span> (L.data[index] == e)</span><br><span class="line">			<span class="keyword">return</span> index + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.长度为$n$的顺序表$L$,编写一个时间复杂度为$$O(n)$$、空间复杂度为$$O(1)$$的算法，该算法删除线性表中所以值为x的数据元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delX</span><span class="params">(Sqlist &amp;L,ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; L.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L[i] != x)&#123;</span><br><span class="line">            L.data[k] = L.data[i];</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L.length = k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.从有序顺序表中删除所有其值重复的元素，使表中所有的值均不相同。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">delSame</span><span class="params">(Sqlist &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.length = <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>,j = <span class="number">1</span>;j &lt; L.length;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L.data[i] != L.data[j])</span><br><span class="line">            L.data[++i] = L.data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length = i;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.将两个有序顺序表合并成一个新的有序顺序表，并由函数返回其结果顺序表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">merge</span><span class="params">(Sqlist A,Sqlist B,Sqlist &amp;C)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.length + B.length &gt; C.maxSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>,k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; A.length &amp;&amp; j &lt; B.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.data[i] &lt;= B.data[j])</span><br><span class="line">            C.data[k++] = A.data[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            C.data[k++] = B.data[j++]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; A.length)&#123;</span><br><span class="line">        C.data[k++] = A.data[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &gt; B.length)&#123;</span><br><span class="line">        C.data[k++] = B.data[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    C.length = k+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.线性表$$(a_1,a_2,…,a_n)$$中的元素递增有序存储于计算机内，设计算法完成在最短的时间内在表中查找数值为x的元素，若存在则将其与后继元素交换，否则插入表中并使表中元素仍然递增有序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">searchExchangeInsert</span><span class="params">(Sqlist &amp;L,ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>,high = n <span class="number">-1</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(L.data[mid] == x)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L.data[mid] &lt; x)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(L.data[mid] == x &amp;&amp; mid != (n<span class="number">-1</span>))&#123;</span><br><span class="line">        ElemType temp = L.data[mid];</span><br><span class="line">        L.data[mid] = L.data[mid+<span class="number">1</span>];</span><br><span class="line">        L.[mid+<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low &gt; high)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n- <span class="number">1</span>;i &gt; high;i--)</span><br><span class="line">            L.data[i+<span class="number">1</span>] = L.data[i];</span><br><span class="line">        L.data[i+<span class="number">1</span>] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.设将$$n(n&gt;1)$$个整数存放到一维数组R中。设计一个高效的算法将R中保存的序列循环左移$$p(0&lt;p&lt;n)$$个位置，即将R中的数据由$$(x_0,x_1,…,x_{n-1})$$变换为$$(x_p,x_{p+1},…,x_{n-1},x_0,x_1,…,x_{p-1})$$</p>
<p>算法思想:</p>
<p>令$$A=(x_0,x_1,…,x_{p-1}),B=(x_p,x_{p+1},…,x_{n-1}),C=BA$$,$$A^{-1}=(x_{p-1},x_{p-2},…,x_1,x_0)$$</p>
<p>$$AB \rightarrow A^{-1}B\rightarrow A^{-1}B^{-1}\rightarrow (A^{-1}B^{-1})^{-1}\rightarrow BA$$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">int</span> R[],<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (to-from+<span class="number">1</span>)/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = R[from+i];</span><br><span class="line">        R[from+i] = R[to-i];</span><br><span class="line">        R[to-i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Converse</span><span class="params">(<span class="keyword">int</span> R[],<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    Reverse(R,<span class="number">0</span>,p<span class="number">-1</span>);</span><br><span class="line">    Reverse(R,p,n<span class="number">-1</span>);</span><br><span class="line">    Reverse(R,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.长度为L的升序序列S，处在第[L/2]个位置的输称为S的中位数，两个序列的中位数是含它们所有元素升序序列的中位数，现有两个等长的升序序列A和B，设计算法找出序列A和序列B的中位数。</p>
<p>算法思想：</p>
<p>设$$a$$为A的中位数，$$b$$为B的中位数</p>
<ol>
<li>若$$a=b$$，则$$a$$或$$b$$即为所求中位数；</li>
<li>若$$a&lt;b$$，舍弃序列A中较小的一半，同时舍弃序列B中较大的一半，两次舍弃的长度相等；</li>
<li>若$$a&gt;b$$，舍弃序列A中较大的一半，同时舍弃序列B中较小的一半，两次舍弃的长度相等；</li>
<li>在保留的两个升序序列中,重复1，2，3,直到两个序列只含有一个元素为止，较小者为所求中位数；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mediSearch</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> B[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sa=<span class="number">0</span>,da=n<span class="number">-1</span>,ma;</span><br><span class="line">    <span class="keyword">int</span> sb=<span class="number">0</span>,db=n<span class="number">-1</span>,mb;</span><br><span class="line">    <span class="keyword">while</span>(sa != da || sb != db)&#123;</span><br><span class="line">        ma = (sa+da)/<span class="number">2</span>;</span><br><span class="line">        mb = (sb+db)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(A[ma] == B[mb])&#123;</span><br><span class="line">            <span class="keyword">return</span> A[ma];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(A[ma] &lt; B[mb])&#123;</span><br><span class="line">            <span class="keyword">if</span>((sa+da)%<span class="number">2</span> == <span class="number">0</span>)&#123;<span class="comment">//元素个数为奇数</span></span><br><span class="line">                sa = ma;</span><br><span class="line">                db = mb;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sa = ma + <span class="number">1</span>;</span><br><span class="line">                db = mb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>((sb+db)%<span class="number">2</span> == <span class="number">0</span>)&#123;<span class="comment">//元素个数为奇数</span></span><br><span class="line">                da = ma;</span><br><span class="line">                sb = mb;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                da = ma;</span><br><span class="line">                sb = mb + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A[sa] &lt; B[sb]?A[sa]:B[sb];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.已知一个整数序列$$A=(a_0,a_1,…a_{n-1})$$，其中$$0\leqslant a_{i}\leqslant n$$,若存在$$a_{p1}=a_{p2}=…a_{pm}=x$$,且$$m&gt;n/2$$,则称$$x$$为A的主元素。例如$$A=(0,5,5,3,5,7,5,5)$$，5为A的主元素，$$B=(0,5,5,3,5,1,5,7)$$,则B中没有主元素。设计算法找出A的主元素并输出，否则输出-1；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majority</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,c,count = <span class="number">1</span>;<span class="comment">//c保存候选主元素</span></span><br><span class="line">    c = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] == c)</span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">0</span>)</span><br><span class="line">                count--;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                c = A[i];</span><br><span class="line">                count = <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span>(i = count = <span class="number">0</span>;i &lt; n; i++)&#123;<span class="comment">//统计候选主元素实际出现的次数</span></span><br><span class="line">            <span class="keyword">if</span>(A[i] == c)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &gt; (n/<span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> c；</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>由于顺序表的插入、删除操作需要移动大量元素,影响运行效率,由此引入线性表的链式存储,链式存储不需要使用地址连续的存储单元,即逻辑上相邻的元素不要求在物理位置上也相邻</p>
<p><strong>单链表</strong></p>
<p>通过一组任意的存储单元来存储线性表中的数据元素,每个链表节点除了存放元素本身,还需要存放指向后继的指针,其是非随机存取结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	ElemType data; <span class="comment">//XX</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span><span class="comment">//指针域</span></span><br><span class="line">&#125;Node,*LinkList;</span><br></pre></td></tr></table></figure>
<p>通常用头指针来标识一个单链表,在单链表第一个节点前附加一个节点称为头节点,头节点的数据域不设任何信息<br><img src="/images/dataStructure/1.jpg" alt=""><br>头指针和头节点：<br>1.不管带不带头节点,头指针始终指向链表的第一个节点<br>2.引入头节点,统一操作,统一空表和非空表的处理</p>
<p><strong>采用头插法建立单链表</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">createList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">	Node *node;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	L-&gt;next = null;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">	<span class="keyword">while</span>(x != <span class="number">10</span>)&#123;</span><br><span class="line">		node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">		node-&gt;data = x;</span><br><span class="line">		node-&gt;next = L-&gt;next;</span><br><span class="line">		L-&gt;next = node;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>采用尾插法建立单链表</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">createList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	Node *node,*tail = L;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">	<span class="keyword">while</span>(x != <span class="number">10</span>)&#123;</span><br><span class="line">		node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">		node-&gt;data = x;</span><br><span class="line">		tail-&gt;next = node;</span><br><span class="line">		tail = node;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,x);</span><br><span class="line">	&#125;</span><br><span class="line">	tail-&gt;next = null;</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>按序号查找节点值</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">getElem</span><span class="params">(LinkList L，<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">	Node *p= L-&gt;next;<span class="comment">//头节点</span></span><br><span class="line">	<span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> L;</span><br><span class="line">	<span class="keyword">if</span>(i &lt; <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> null;</span><br><span class="line">	<span class="keyword">while</span>(p &amp;&amp; j &lt; i)&#123; <span class="comment">//从第一个节点开始查找</span></span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		j++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>按值查找表节点</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">getElem</span><span class="params">(LinkList L，ElemType  e)</span></span>&#123;</span><br><span class="line">	Node *p= L-&gt;next;<span class="comment">//头节点</span></span><br><span class="line">	<span class="keyword">while</span>(p &amp;&amp; p-&gt;data != e)&#123; <span class="comment">//从第一个节点开始查找</span></span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>插入节点操作</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = getElem(L,i<span class="number">-1</span>);<span class="comment">//查找插入位置i的前驱节点</span></span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = s;</span><br></pre></td></tr></table></figure>
<p><strong>删除节点操作</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = getElem(L,i<span class="number">-1</span>);<span class="comment">//查找删除位置i的前驱节点</span></span><br><span class="line">q = p-next;</span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure>
<p><strong>双链表</strong></p>
<p>双链表通过prior和next，分别指向前驱节点和后继节点<br>双链表的按值查找和按位查找操作和单链表相同</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">prior</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node,*DoubleList;</span><br></pre></td></tr></table></figure>
<p><strong>插入节点操作</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p = getElem(L,i<span class="number">-1</span>);<span class="comment">//查找插入位置i的前驱节点</span></span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next-prior = s;</span><br><span class="line">s-&gt;prior = p;</span><br><span class="line">p-&gt;next = s;</span><br></pre></td></tr></table></figure>
<p><strong>删除节点操作</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p = getElem(L,i<span class="number">-1</span>);<span class="comment">//查找删除位置i的前驱节点</span></span><br><span class="line">q = p-next;</span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior = p;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure>
<h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>静态链表是由数组来描述线性表的链式存储结构,节点也有数据域data和指针域next</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">int</span> next ;<span class="comment">//下一个元素的数组下标</span></span><br><span class="line">&#125;StaticLinkList[MaxSize];</span><br></pre></td></tr></table></figure>

<ol>
<li><p>在带头结点的单链表L中，删除所有值为x的结点，并释放其空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteX</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    Node *p = L-&gt;next,*pre = L;*q;<span class="comment">//pre为p的前驱结点</span></span><br><span class="line">    <span class="keyword">while</span>(p != null)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data == x)&#123;</span><br><span class="line">            q = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            pre-&gt;next = p;</span><br><span class="line">            <span class="built_in">free</span>(q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设L为带头结点的单链表，编写算法实现从尾到头反向输出每个结点的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reversePrint</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next != nulll)&#123;</span><br><span class="line">        reversePrint(L-next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(L-&gt;data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//借助栈</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写在带头结点的单链表L中删除最小值结点的高效算法，假设最小值唯一。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">deleteMinNode</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    Node *p = L-&gt;next,*pre = L;<span class="comment">// pre为p的前驱结点</span></span><br><span class="line">    Node *minPre = pre,*<span class="built_in">min</span> = p;<span class="comment">//最小值的前驱和当前最小值</span></span><br><span class="line">    <span class="keyword">while</span>(p!= null)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data &lt; <span class="built_in">min</span>-&gt;data)&#123;</span><br><span class="line">            <span class="built_in">min</span> = p;</span><br><span class="line">            minPre = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    minPre-&gt;next = <span class="built_in">min</span>-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">min</span>);</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>试编写算法将带头结点的链表逆置，且空间复杂度为$O(1)$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">reverse</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    Node *p,*r;<span class="comment">//p为工作指针，r为后继指针</span></span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        r = p-&gt;next;</span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">        p = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>版权声明：原创,转载请注明来源,否则律师函警告</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jiaopaner.github.io/2019/05/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(2)%20%E7%BA%BF%E6%80%A7%E8%A1%A8/" data-id="ck4mhjkdd003qw6zwcw4jdgji" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构(1) 基本概念" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(1)%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" class="article-date">
  <time datetime="2019-05-29T11:25:01.000Z" itemprop="datePublished">2019-05-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(1)%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">数据结构(1) 基本概念</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>数据</strong></p>
<p>数据是信息的载体，是描述客观事物的数、字符以及所有能输入到计算机且能被计算机识别和处理的符号集合。</p>
<p><strong>数据元素</strong></p>
<p>数据的基本单位，数据元素由数据项组成。如一条学生记录就是一个数据元素，它由姓名、学号、性别等数据项组成。</p>
<p><strong>数据对象</strong></p>
<p>具有相同性质的的数据元素集合，是数据的子集。</p>
<p><strong>抽象数据类型</strong></p>
<p>一个数学模型且定义在该模型上的一组操作，通常用数据对象、数据关系、基本操作集表示。</p>
<p><strong>数据结构</strong></p>
<p>数据结构包括逻辑结构、存储结构和数据的运算，算法的设计取决于选定的逻辑结构，算法的实现依赖于采用的存储结构。</p>
<blockquote>
<p>逻辑结构</p>
</blockquote>
<p>线性结构：结构中的数据元素只存在一对一的关系(线性表、栈和队列、串、数组、广义表)</p>
<p>非线性结构：结构中数据元素存在一对多的关系(树)、多对多的关系(图)</p>
<p>存储结构：顺序存储、链式存储、索引存储、散列存储</p>
<p>版权声明：原创,转载请注明来源,否则律师函警告</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jiaopaner.github.io/2019/05/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(1)%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" data-id="ck4mhjkd80039w6zw11wtbfmb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-线性代数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/26/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" class="article-date">
  <time datetime="2019-04-26T01:17:54.000Z" itemprop="datePublished">2019-04-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E5%AD%A6/">数学</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/26/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/">线性代数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><p><strong>概念：行列式是一个数，是取自不同行不同列的n个元素的乘积的代数和</strong></p>
<p>二阶行列式：$\begin{vmatrix}<br>a &amp; b\<br>c &amp; d<br>\end{vmatrix}=ad-bc$</p>
<p>三阶行列式：$\begin{vmatrix}<br>a_{1} &amp; a_{2} &amp; a_{3}\<br>b_{1} &amp; b_{2} &amp; b_{3}\<br>c_{1} &amp; c_{2} &amp; c_{3}<br>\end{vmatrix}=a_{1}b_{2}c_{3}+a_{2}b_{3}c_{1}+a_{3}b_{1}c_{2}-a_{3}b_{2}c_{1}-a_{2}b_{1}c_{3}-a_{1}b_{3}c_{2}$(对角线法则)</p>
<p>n阶乘行列式：$\begin{vmatrix}<br>a_{11} &amp; a_{12} &amp; … &amp; a_{1n}\<br>a_{21} &amp; a_{22} &amp; … &amp; a_{2n}\<br>\vdots &amp;\vdots &amp; &amp;\vdots &amp;\<br>a_{n1} &amp; a_{n2} &amp; … &amp; a_{nn}<br>\end{vmatrix}=\sum_{j_{1}j_{2}…j_{n}}(-1)^{r(j_{1}j_{2}…j_{n})}a_{1j_{1}}a_{2j_{2}}…a_{nj_{n}}$(完全展开式)</p>
<p>$r(j_{1}j_{2}…j_{n})$为排列$j_{1}j_{2}…j_{n}$的逆序数</p>
<p><strong>性质</strong></p>
<ol>
<li><p>经转置行列式的值不变. $\left | A^{T} \right |=\left | A \right |$</p>
</li>
<li><p>两行或两列互换的行列式变号. $\begin{vmatrix}<br>a_{11} &amp; a_{12} &amp; … &amp; a_{1n}\<br>a_{21} &amp; a_{22} &amp; … &amp; a_{2n}\<br>\vdots &amp;\vdots &amp; &amp;\vdots &amp;\<br>a_{n1} &amp; a_{n2} &amp; … &amp; a_{nn}<br>\end{vmatrix}=-\begin{vmatrix}<br>a_{21} &amp; a_{22} &amp; … &amp; a_{2n}\<br>a_{11} &amp; a_{12} &amp; … &amp; a_{1n}\<br>\vdots &amp;\vdots &amp; &amp;\vdots &amp;\<br>a_{n1} &amp; a_{n2} &amp; … &amp; a_{nn}<br>\end{vmatrix}$</p>
</li>
<li><p>某行或某列有公因数k,可把k提取到行列式外.<br>$$<br>\begin{vmatrix}<br>ka_{11} &amp; ka_{12} &amp; … &amp; ka_{1n}\<br>a_{21} &amp; a_{22} &amp; … &amp; a_{2n}\<br>\vdots &amp;\vdots &amp; &amp;\vdots &amp;\<br>a_{n1} &amp; a_{n2} &amp; … &amp; a_{nn}<br>\end{vmatrix}<br>=k<br>\begin{vmatrix}<br>a_{11} &amp; a_{12} &amp; … &amp; a_{1n}\<br>a_{21} &amp; a_{22} &amp; … &amp; a_{2n}\<br>\vdots &amp;\vdots &amp; &amp;\vdots &amp;\<br>a_{n1} &amp; a_{n2} &amp; … &amp; a_{nn}<br>\end{vmatrix}<br>$$</p>
</li>
<li><p>某行或某列所有元素都为两个数之和，则可写成两个行列式之和.<br>$$<br>\begin{vmatrix}<br>a_{1} &amp; a_{2}+a_{4} &amp; a_{3}\<br>b_{1} &amp; b_{2}+b_{4} &amp; b_{3}\<br>c_{1} &amp; c_{2}+c_{4} &amp; c_{3}</p>
<h1 id="end-vmatrix"><a href="#end-vmatrix" class="headerlink" title="\end{vmatrix}"></a>\end{vmatrix}</h1><p>\begin{vmatrix}<br>a_{1} &amp; a_{2}&amp; a_{3}\<br>b_{1} &amp; b_{2}&amp; b_{3}\<br>c_{1} &amp; c_{2}&amp; c_{3}<br>\end{vmatrix}<br>+<br>\begin{vmatrix}<br>a_{1} &amp; a_{4} &amp; a_{3}\<br>b_{1} &amp; b_{4} &amp; b_{3}\<br>c_{1} &amp; c_{4} &amp; c_{3}<br>\end{vmatrix}<br>$$</p>
</li>
<li><p>某行或某列的k倍加至某行或某列，行列式不变.<br>$$<br>\begin{vmatrix}<br>a_{11} &amp; a_{12} &amp; … &amp; a_{1n}\<br>a_{21} &amp; a_{22} &amp; … &amp; a_{2n}\<br>\vdots &amp;\vdots &amp; &amp;\vdots &amp;\<br>a_{n1} &amp; a_{n2} &amp; … &amp; a_{nn}</p>
<h1 id="end-vmatrix-1"><a href="#end-vmatrix-1" class="headerlink" title="\end{vmatrix}"></a>\end{vmatrix}</h1><p>\begin{vmatrix}<br>a_{11} &amp; a_{12} &amp; … &amp; a_{1n}\<br>a_{21}+ka_{11} &amp; a_{22}+ka_{12} &amp; … &amp; a_{2n}+ka_{1n}\<br>\vdots &amp;\vdots &amp; &amp;\vdots &amp;\<br>a_{n1} &amp; a_{n2} &amp; … &amp; a_{nn}<br>\end{vmatrix}<br>$$</p>
<p>[^特别地,某两行或两列相同或某行或某列元素全为0，则行列式为0；某两行或某两列成比例则行列式为0]: </p>
</li>
<li><p>若$A$是$n$阶矩阵，则$|kA|=k^n|A|$，$|A^*|=|A|^{n-1}$</p>
</li>
<li><p>若$A,B$都是$n$阶矩阵，则$|AB|=|A||B|$</p>
</li>
<li><p>若$A$是$n$阶可逆矩阵，则$|A^{-1}|=|A|^{-1}$</p>
</li>
<li><p>若$n$阶矩阵$A$和$B$相似，则$|A|=|B|$</p>
</li>
</ol>
<p><strong>余子式和代数余子式</strong></p>
<p>余子式：在$n$阶行列式中，划去元素$a_{ij}$所在的第$i$行与第$j$列的所有元素剩下的元素(不改变原来的顺序)所构成的$n-1$阶行列式称为$a_{ij}$的余子式,记为$M_{ij}$</p>
<p>代数余子式：$a_{ij}$的代数余子式$A_{ij}=(-1)^{i+j}M_{ij}$</p>
<p>行列式$\begin{vmatrix}<br>a_{11} &amp; a_{12} &amp; a_{13}\<br>a_{21} &amp; a_{22} &amp; a_{23}\<br>a_{31} &amp; a_{32} &amp; a_{33}<br>\end{vmatrix}，<br>a_{22}的余子式M_{22} =<br>\begin{vmatrix}<br>a_{11} &amp;  a_{13}\<br>a_{31} &amp;  a_{33}<br>\end{vmatrix}，<br>a_{22}的代数余子式A_{22}=<br>(-1)^{(2+2)}\begin{vmatrix}<br>a_{11} &amp;  a_{13}\<br>a_{31} &amp;  a_{33}<br>\end{vmatrix}$</p>
<p>行列式等于它任意一行(列)的各元素与其对应的代数式余子式乘积之和<br>$$<br>|A| = a_{i1}A_{i1}+a_{i2}A_{i2}+…+a_{in}A_{in}(按i行展开)<br>\<br>|A| = a_{1j}A_{1j}+a_{2j}A_{2j}+…+a_{nj}A_{nj}(按j行展开)<br>$$</p>
<p><strong>行列式的计算</strong></p>
<ol>
<li><p>三角化</p>
<p>$\begin{vmatrix}<br>a_{11} &amp; a_{12} &amp; … &amp; a_{1n}\<br>0 &amp; a_{22} &amp; … &amp; a_{2n}\<br>\vdots &amp;\vdots &amp; &amp;\vdots &amp;\<br>0 &amp; 0 &amp; … &amp; a_{nn}</p>
<h1 id="end-vmatrix-2"><a href="#end-vmatrix-2" class="headerlink" title="\end{vmatrix}"></a>\end{vmatrix}</h1><p>\begin{vmatrix}<br>a_{11} &amp; 0 &amp; … &amp; 0\<br>a_{21} &amp; a_{22} &amp; … &amp; 0\<br>\vdots &amp;\vdots &amp; &amp;\vdots &amp;\<br>a_{n1} &amp; a_{n2} &amp; … &amp; a_{nn}<br>\end{vmatrix}<br>=a_{11}a_{22}…a_{nn}$</p>
<p>$\begin{vmatrix}<br>a_{11} &amp; a_{12} &amp; … &amp; a_{1n}\<br>a_{21} &amp; … &amp; a_{2n-1} &amp; 0\<br>\vdots &amp; &amp;\vdots &amp;\<br>a_{n1} &amp; 0 &amp; … &amp; 0</p>
<h1 id="end-vmatrix-3"><a href="#end-vmatrix-3" class="headerlink" title="\end{vmatrix}"></a>\end{vmatrix}</h1><p>\begin{vmatrix}<br>0 &amp; … &amp; 0 &amp; a_{1n}\<br>0 &amp; … &amp; a_{2n-1} &amp; a_{2n}\<br>\vdots &amp;  &amp;\vdots &amp;\vdots\<br>a_{n1} &amp; a_{n2} &amp; … &amp; a_{nn}<br>\end{vmatrix}<br>=(-1)^{\frac{n(n-1)}{2}}a_{1n}a_{2n-1}…a_{n1}$</p>
</li>
<li><p>公式法(代数余子式) 、递推法 、利用行列式性质、利用矩阵性质</p>
</li>
<li><p>利用特征值. $|A| = \prod \lambda_{i}$</p>
</li>
<li><p>拉普拉斯展开式<br>$$<br>\begin{vmatrix}<br>\mathbf{A} &amp; \mathbf{*} \<br>\mathbf{O} &amp; \mathbf{B}</p>
<h1 id="end-vmatrix-4"><a href="#end-vmatrix-4" class="headerlink" title="\end{vmatrix}"></a>\end{vmatrix}</h1><p>\begin{vmatrix}<br>\mathbf{A} &amp; \mathbf{O} \<br>\mathbf{<em>} &amp; \mathbf{B}<br>\end{vmatrix}<br>=|\mathbf{A}||\mathbf{B}|<br>，\begin{vmatrix}<br>\mathbf{O} &amp; \mathbf{A} \<br>\mathbf{B} &amp; \mathbf{</em>}</p>
<h1 id="end-vmatrix-5"><a href="#end-vmatrix-5" class="headerlink" title="\end{vmatrix}"></a>\end{vmatrix}</h1><p>\begin{vmatrix}<br>\mathbf{*} &amp; \mathbf{A} \<br>\mathbf{B} &amp; \mathbf{O}<br>\end{vmatrix}<br>=(-1)^{nm}|\mathbf{A}||\mathbf{B}|<br>$$<br>$m、n$分别是矩阵$\mathbf{A}、\mathbf{B}$的阶数</p>
</li>
<li><p>范德蒙德行列式</p>
<p>$\begin{vmatrix}<br>1 &amp; 1 &amp; … &amp; 1 \<br>x_1 &amp;x_2 &amp;… &amp;x_n \<br>x_1^2 &amp;x_2^2 &amp;… &amp;x_n^2 \<br>\vdots &amp;\vdots&amp;&amp;\vdots \<br>x_1^{n-1} &amp;x_2^{n-1} &amp;… &amp;x_n^{n-1} \<br>\end{vmatrix}=\prod_{1\leqslant j\leqslant i\leqslant n}(x_i-x_j)$</p>
<p>$=(x_n-x_{n-1})…(x_n-x_1)\cdot (x_{n-1}-x_{n-2})…(x_{n-1}-x_1)…(x_3-x_2)(x_3-x_1)(x_2-x_1)$</p>
</li>
</ol>
<p><strong>证明|A| = 0</strong></p>
<p>Ax = 0 有非零解 、反证法、r(A) &lt; n、0是A的特征值、|A| = -|A|</p>
<p><strong>行列式的应用</strong></p>
<ol>
<li><p>向量组的相关性</p>
<p>设$\alpha_1,\alpha_2,\cdots,\alpha_n$是$n$个$n$维向量，$A=\alpha_1,\alpha_2,\cdots,\alpha_n$,则$\alpha_1,\alpha_2,\cdots,\alpha_s$线性无关的充分必要条件是$|A|\neq0$</p>
</li>
<li><p>矩阵的满秩与可逆</p>
<p>$A$满秩的充分必要条件是$|A|\neq0$</p>
<p>$A$可逆的充分必要条件是$|A|\neq0$</p>
</li>
<li><p>方程组的解</p>
<p>$AX=0$只有零解的充分必要条件是$|A|\neq0$</p>
<p>$AX=b$有唯一解的充分必要条件是$|A|\neq0$</p>
</li>
</ol>
<p><strong>$n$阶行列式的计算</strong></p>
<p>升阶法、递推法、化为上下三角形法、拆项</p>
<hr>
<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><p><strong>概念：$m$x$n$个数排成的$m$行$n$列的集合</strong></p>
<p>$\begin{bmatrix}<br>a_{11} &amp; a_{12} &amp; … &amp; a_{1n}\<br>a_{21} &amp; a_{22} &amp; … &amp; a_{2n}\<br>\vdots &amp;\vdots &amp; &amp;\vdots &amp;\<br>a_{m1} &amp; a_{m2} &amp; … &amp; a_{mn}<br>\end{bmatrix}$称为$m$x$n$矩阵，当$m= n$,矩阵称为$n$阶矩阵或$n$阶方阵</p>
<p>[^行列式是方阵，仅方阵才有行列式]: </p>
<p><strong>矩阵运算</strong></p>
<ol>
<li><p>$A+B=[a_{ij}+b_{ij}]$ 对应元素相加</p>
</li>
<li><p>$kA=[ka_{ij}]$ 所有元素都乘以$k$</p>
</li>
<li><p>$m$x$n$矩阵$A$，$n$x$s$矩阵$B$，$AB=C(m,s),c_{ij}=\sum_{k=1}^{n}a_{ik}b_{kj}$</p>
<p>$\begin{bmatrix}<br> &amp;  &amp; \<br>(i)\cdots&amp;\cdots&amp;\cdots  \<br> &amp;  &amp;<br>\end{bmatrix}<br>\begin{bmatrix}<br> &amp; (j)  &amp; \<br> &amp; \vdots  &amp; \<br> &amp; \vdots  &amp;  \<br> &amp; \vdots  &amp;</p>
<h1 id="end-bmatrix"><a href="#end-bmatrix" class="headerlink" title="\end{bmatrix}"></a>\end{bmatrix}</h1><p>\begin{bmatrix}<br> &amp; &amp; \<br> &amp; c_{ij} &amp;  \<br> &amp; &amp;<br>\end{bmatrix}$</p>
</li>
</ol>
<p>例:$\begin{bmatrix}<br>2 &amp; 1 &amp; 1 \<br>1 &amp; 2 &amp; 1<br>\end{bmatrix}<br>\begin{bmatrix}<br>1 &amp; 0 \<br>0 &amp; 2 \<br>3 &amp; 1<br>\end{bmatrix}<br>=\begin{bmatrix}<br>2\cdot1+1\cdot0+1\cdot3 &amp; 2\cdot0+1\cdot2+1\cdot1\<br>1\cdot1+2\cdot0+1\cdot3 &amp; 1\cdot0+2\cdot2+1\cdot1<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>5 &amp; 3\<br>4 &amp; 5<br>\end{bmatrix}$</p>
<p>[^乘法条件:A的列数=B的行数]: </p>
<p>矩阵乘法法则:</p>
<p>$A(BC)=(AB)C;\A(B+C)=AB+AC,(A+B)C=AC+BC;\ (kA)(lB)=klAB;\ AE=A,EA=A \ (A+E)^2=A^2+2A+E$</p>
<p>$(A+B)^2=(A+B)(A+B)=A^2+AB+BA+B^2\neq  A^2+2AB+B^2$</p>
<blockquote>
<p>注意:$AB\neq  BA$</p>
</blockquote>
<p><strong>矩阵转置</strong></p>
<p>矩阵$A$的行换成同序数的列得到的新矩阵为矩阵$A$的转置矩阵，记为$A^T$</p>
<p>$A=\begin{bmatrix}<br>1&amp; 2 &amp; 3 \<br>4&amp; 5&amp; 6<br>\end{bmatrix},A^T=\begin{bmatrix}<br>1 &amp; 4 \<br>2 &amp; 5 \<br>3 &amp; 6 \end{bmatrix}$(横取竖放)</p>
<p><strong>伴随矩阵</strong></p>
<p>$A$是$n$阶矩阵，行列式$|A|$的每个元素$a_{ij}$的代数余子式$A_{ij}$所构成的矩阵为$A$的伴随矩阵,记为$A^*$</p>
<p>$A=\begin{bmatrix}<br>a_{11}&amp; a_{12}  \<br>a_{21}&amp; a_{22} \end{bmatrix}，A^*=\begin{bmatrix}<br>A_{11}&amp; A_{21}  \<br>A_{12}&amp; A_{22} \end{bmatrix}$(横取竖放)</p>
<blockquote>
<p>二阶矩阵的伴随矩阵:主对角线元素互换,副对角线元素变号</p>
</blockquote>
<p><strong>逆矩阵</strong></p>
<p>$A$是<strong>$n$阶矩阵</strong>，若存在<strong>$n$阶矩阵B</strong>使得$AB=BA=E$,则称A是可逆矩阵或非奇异矩阵，$B$是$A$的逆矩阵,记为$A^{-1}=B$,且$A$的逆矩阵唯一</p>
<p>$A$可逆$\Leftrightarrow |A|\neq 0$</p>
<p>​           $\Leftrightarrow r(A)=n$</p>
<p>​           $\Leftrightarrow $A的列(行)向量组线性无关</p>
<p>​           $\Leftrightarrow A=P_1P_2\cdots P_s,P_i$是初等矩阵</p>
<p>​           $\Leftrightarrow A$与单位矩阵等价</p>
<p>​           $\Leftrightarrow 0$不是A的特征值</p>
<p>矩阵$A$与矩阵$B$等价的充分必要条件是存在可逆矩阵$P$与$Q$，使得$PAQ=B$</p>
<ul>
<li><p>$A^{-1}=P_t\cdots P_2P_1$ </p>
<p>$P_t\cdots P_2P_1A=E$</p>
<p>$P_t\cdots P_2P_1E=A^{-1} \rightarrow (A|E)\rightarrow \cdots\rightarrow(E|A^{-1})$</p>
</li>
<li><p>$P_t\cdots P_2P_1A=B$</p>
<p>$P_t\cdots P_2P_1E=P$ ($P=P_t\cdots P_2P_1$)</p>
<p>$(A|E)\rightarrow \cdots\rightarrow(B|P)$</p>
</li>
</ul>
<p><strong>正交矩阵</strong></p>
<p>$n$阶矩阵$A$，若满足$AA^T=A^TA=E$，则$A$为正交矩阵</p>
<p><strong>行阶梯矩阵、行最简矩阵</strong></p>
<p><strong>矩阵的初等变换</strong></p>
<p>$E_{i,j}A$：对调$A$的$i,j$行 </p>
<p>$AE_{i,j}$：对调$A$的$i,j$列</p>
<p>$E_{i,j}$</p>
<p><strong>公式</strong></p>
<ol>
<li><p>转置</p>
<p>$(A^T)^T=A ;(A+B)^T=A^T+B^T \ (kA)^T=kA^T \ (AB)^T=B^TA^T$</p>
</li>
<li><p>可逆</p>
<p>$(A^{-1})^{-1}=A;(kA)^{-1}=\frac{1}{k}A^{-1}  (k\neq 0) \ (AB)^{-1}=B^{-1}A^{-1};(A^n)^{-1}=(A^{-1})^n$</p>
<p>$(A^{-1})^T=(A^T)^{-1};|A^{-1}|=\frac{1}{|A|}\A^{-1}=\frac{1}{|A|}A^*$</p>
</li>
<li><p>伴随</p>
<p>$$AA^<em>=A^</em>A=|A|E$$</p>
<p>$$A^<em>=|A|A^{-1};|A^</em>|=|A|^{n-1}$$</p>
<p>$$(A^<em>)^{-1}=(A^{-1})^</em>=\frac{1}{|A|}A\(A^<em>)^T=(A^T)^</em>;(kA)^<em>= k^{n-1}A^</em> ;(A^<em>)^</em>=|A|^{n-2}A$$</p>
<p>$$(AB)^<em>=B^*A^</em>$$</p>
<p>$r(A^*)=\begin{cases}<br> n&amp; \text{ 如果 } r(A)=n \<br> 1&amp; \text{ 如果 } r(A)=n-1 \<br>0&amp; \text{ 如果 } r(A)&lt;n-1<br>\end{cases}$</p>
</li>
<li><p>秩</p>
<p>$r(A)=r(A^T)=r(A^TA)\r(kA)=r(A),k\neq  0 \r(A+B)\leqslant r(A)+r(B)\r(AB)\leqslant min(r(A),r(B))$</p>
<p>若$A$可逆，则$r(AB)=r(B),r(BA)=r(B)$</p>
<p>若$A$为$m$x$n$矩阵，$B$为$n$x$s$矩阵，$AB=O$,则 $r(A)+r(B)\leqslant n$</p>
<p>$r\binom{A}{B}=r(A)+r(B)$</p>
<p>$r\begin{pmatrix}<br>A &amp; O\<br>O &amp; B<br>\end{pmatrix}=r(A)+r(B)$</p>
<p>设$A$为$n$阶矩阵，则$r(A)=1$的充分必要条件是存在非零$n$维向量$\alpha,\beta$,使得$A=\alpha\beta^{T}$</p>
<p>$\alpha^T\beta=tr(A)$(主对角线元素相加)</p>
<p>$A=\alpha\beta^{T}$，则$A^n=k^{n-1}A$,其中$k=\alpha^T\beta=\beta^{T}\alpha$</p>
<p>(满秩=矩阵列向量的个数)</p>
</li>
<li><p>分块矩阵</p>
<p>$\begin{bmatrix}<br>A_1 &amp; A_2\<br>A_3 &amp; A_4<br>\end{bmatrix}<br>+\begin{bmatrix}<br>B_1 &amp; B_2\<br>B_3 &amp; B_4</p>
<h1 id="end-bmatrix-1"><a href="#end-bmatrix-1" class="headerlink" title="\end{bmatrix}"></a>\end{bmatrix}</h1><p>\begin{bmatrix}<br>A_1+B_1  &amp; A_2+B_2 \<br>A_3+B_3  &amp; A_4+B_4<br>\end{bmatrix}$</p>
<p>$\begin{bmatrix}<br>A &amp; B\<br>C &amp; D<br>\end{bmatrix}<br>\begin{bmatrix}<br>X &amp; Y\<br>Z &amp; W</p>
<h1 id="end-bmatrix-2"><a href="#end-bmatrix-2" class="headerlink" title="\end{bmatrix}"></a>\end{bmatrix}</h1><p>\begin{bmatrix}<br>AX+BZ  &amp; AY+BW \<br>CX+DZ  &amp; CY+DW<br>\end{bmatrix}$</p>
<p>$\begin{bmatrix}<br>A &amp; B\<br>C &amp; D</p>
<h1 id="end-bmatrix-T"><a href="#end-bmatrix-T" class="headerlink" title="\end{bmatrix}^T"></a>\end{bmatrix}^T</h1><p>\begin{bmatrix}<br>A^T &amp; C^T\<br>B^T &amp; D^T<br>\end{bmatrix}$</p>
<p>若$B,C$分别是$m$阶与$s$阶矩阵，则$\begin{bmatrix}<br>B &amp; O\<br>O &amp; C</p>
<h1 id="end-bmatrix-n"><a href="#end-bmatrix-n" class="headerlink" title="\end{bmatrix}^n"></a>\end{bmatrix}^n</h1><p>\begin{bmatrix}<br>B^n &amp; O\<br>O &amp; C^n<br>\end{bmatrix}$</p>
<p>若$B,C$分别是$m$阶与$s$阶可逆矩阵，则$\begin{bmatrix}<br>B &amp; O\<br>O &amp; C</p>
<h1 id="end-bmatrix-1"><a href="#end-bmatrix-1" class="headerlink" title="\end{bmatrix}^{-1}"></a>\end{bmatrix}^{-1}</h1><p>\begin{bmatrix}<br>B^{-1} &amp; O\<br>O &amp; C^{-1}<br>\end{bmatrix}，\begin{bmatrix}<br>O &amp; B\<br>C &amp; O<br>\end{bmatrix}^{-1}<br>=\begin{bmatrix}<br>O &amp; C^{-1}\<br>B^{-1} &amp; O<br>\end{bmatrix}$</p>
</li>
<li><p>对角矩阵</p>
<p>$\begin{bmatrix}<br>a_1 &amp;  &amp; \<br> &amp;  a_2&amp; \<br> &amp;  &amp; a_3<br>\end{bmatrix}<br>\begin{bmatrix}<br>b_1 &amp;  &amp; \<br> &amp;  b_2&amp; \<br> &amp;  &amp; b_3</p>
<h1 id="end-bmatrix-3"><a href="#end-bmatrix-3" class="headerlink" title="\end{bmatrix}"></a>\end{bmatrix}</h1><p>\begin{bmatrix}<br>a_1b_1 &amp;  &amp; \<br> &amp;  a_2b_2&amp; \<br> &amp;  &amp; a_3b_3<br>\end{bmatrix}$</p>
<p>$\begin{bmatrix}<br>a_1 &amp;  &amp; \<br> &amp;  a_2&amp; \<br> &amp;  &amp; a_3</p>
<h1 id="end-bmatrix-n-1"><a href="#end-bmatrix-n-1" class="headerlink" title="\end{bmatrix}^n"></a>\end{bmatrix}^n</h1><p>\begin{bmatrix}<br>a_1^n &amp;  &amp; \<br> &amp;  a_2^n&amp; \<br> &amp;  &amp; a_3^n<br>\end{bmatrix}$</p>
<p>$\begin{bmatrix}<br>a_1 &amp;  &amp; \<br> &amp;  a_2&amp; \<br> &amp;  &amp; a_3</p>
<h1 id="end-bmatrix-1-1"><a href="#end-bmatrix-1-1" class="headerlink" title="\end{bmatrix}^{-1}"></a>\end{bmatrix}^{-1}</h1><p>\begin{bmatrix}<br>\frac{1}{a_1} &amp;  &amp; \<br> &amp;  \frac{1}{a_2} &amp; \<br> &amp;  &amp; \frac{1}{a_3}<br>\end{bmatrix}$</p>
</li>
</ol>
<hr>
<h1 id="n-维向量"><a href="#n-维向量" class="headerlink" title="$n$维向量"></a>$n$维向量</h1><p><strong>定义1</strong></p>
<p>设$n$维列向量$\alpha =[a_1,a_2,\cdots,a_n]^T,\beta =[b_1.b_2,\cdots,b_n]^T$,则</p>
<p>$\alpha+\beta=[a_1+b_1,a_2+b_2,\cdots,a_n+b_n];\ k\alpha=[ka_1,ka_2,\cdots,ka_n]$</p>
<p>$(\alpha,\beta)=\alpha^T\beta=a_1b_1+a_2b_2+\cdots+a_nb_n$</p>
<p>$\begin{Vmatrix}<br>\alpha<br>\end{Vmatrix}=\sqrt{\alpha^T\alpha}=\sqrt{a_1^2+a_2^2+\cdots+a_n^2}$</p>
<p><strong>定义2</strong></p>
<p>设$\alpha_1,\alpha_2,\cdots,\alpha_s$是$n$维向量，$k_1,k_2,\cdots,k_s$是一组实数，称$k_1\alpha_1+k_2\alpha_2+\cdots+k_s\alpha_s$是$\alpha_1,\alpha_2,\cdots,\alpha_s$的线性组合，若$k_1\alpha_1+k_2\alpha_2+\cdots+k_s\alpha_s=\beta$,则称$\beta$是$\alpha_1,\alpha_2,\cdots,\alpha_s$的线性组合</p>
<p><strong>定义3</strong></p>
<p>设$\alpha_1,\alpha_2,\cdots,\alpha_s$是$n$维向量，如果存在不全为零的数使得$k_1\alpha_1+k_2\alpha_2+\cdots+k_s\alpha_s=0$，则称向量组$\alpha_1,\alpha_2,\cdots,\alpha_s$线性相关，当且仅当$k_1=k_2=\cdots=k_s=0$时，称向量组$\alpha_1,\alpha_2,\cdots,\alpha_s$线性无关</p>
<p><strong>定理1</strong></p>
<p>$k_1\alpha_1+k_2\alpha_2+\cdots+k_s\alpha_s=\beta$</p>
<p>$\Leftrightarrow$ 非齐次线性方程组$[\alpha_1,\alpha_2,\cdots,\alpha_s]\begin{bmatrix}<br>x_1\<br>x_2\<br>\vdots \<br>x_s<br>\end{bmatrix}=\beta$有解</p>
<p>$\Leftrightarrow$秩$r[\alpha_1,\alpha_2,\cdots,\alpha_s]=r[\alpha_1,\alpha_2,\cdots,\alpha_s,\beta]$</p>
<p><strong>定理2</strong></p>
<p>$\alpha_1,\alpha_2,\cdots,\alpha_s$线性相关</p>
<p>$\Leftrightarrow$ 齐次线性方程组$[\alpha_1,\alpha_2,\cdots,\alpha_s]\begin{bmatrix}<br>x_1\<br>x_2\<br>\vdots \<br>x_s<br>\end{bmatrix}=0$有非零解</p>
<p>$\Leftrightarrow$秩$r[\alpha_1,\alpha_2,\cdots,\alpha_s]&lt;s$</p>
<p><strong>推论</strong></p>
<p>1.$n$个$n$维向量$\alpha_1,\alpha_2,\cdots,\alpha_n$线性相关的充分必要条件是行列式$|\alpha_1,\alpha_2,\cdots,\alpha_n|=0$</p>
<p>2.向量组$\alpha_1,\alpha_2,\cdots,\alpha_n$线性相关的充分必要条件是$\alpha_1,\alpha_2,\cdots,\alpha_n$中至少有一个向量可由其余向量线性表示</p>
<p>3.含零向量的向量组一定线性相关</p>
<p>4.若一个向量组线性无关，则该向量组的任何部分向量组都线性无关</p>
<p>5.若向量组有部分向量组线性相关，则该向量组一定线性相关</p>
<p>6.$n$个$n$维向量$\alpha_1,\alpha_2,\cdots,\alpha_n$线性无关的充分必要条件是行列式$|\alpha_1,\alpha_2,\cdots,\alpha_n|\neq 0$</p>
<p>7.两个向量线性相关的充分必要条件是两个向量成比例</p>
<p>8.若$A$的任意两行两列成比例，则$A=\alpha\beta^T$</p>
<hr>
<h1 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h1><p><strong>定理</strong></p>
<p>齐次线性方程组$AX=0$ (零解和非零解)</p>
<ul>
<li>只有零解的充分必要条件是$r(A)=n$(A为普通矩阵),$|A|\neq0$(A为方阵)</li>
<li>有非零解的充分必要条件是$r(A) &lt;  n$(A为普通矩阵),$|A|= 0$(A为方阵)</li>
</ul>
<p>非齐次线性线性方程组$AX=b$(无解和有解)，增广矩阵$\overline{A}=(A\vdots b)$</p>
<ul>
<li><p>有解的充分必要条件是$r(A)=r(\overline{A})$</p>
<p>若$r(A)=r(\overline{A})=n$ 方程组有唯一解,$|A|\neq0$ (A为方阵时 )</p>
<p>若$r(A)=r(\overline{A}) &lt; n$ 方程组有无数个解，$|A|= 0$ (A为方阵时)</p>
</li>
<li><p>无解的充分必要条件是$r(A)\neq r(\overline{A})$</p>
</li>
</ul>
<p><strong>线性方程组解的结构</strong></p>
<ol>
<li>设$X_1,X_2,\cdots,X_s$为齐次线性方程组$AX=0$的一组解，则$k_1X_1+k_2X_2+\cdots+k_sX_s$也为$AX = 0$的解</li>
<li>设$\eta_0$为非齐次线性方程组$AX=b$的一个解，$X_1,X_2,\cdots,X_s$为齐次线性方程组$AX=0$的一组解，则$k_1X_1+k_2X_2+\cdots+k_sX_s+\eta_0$为$AX=b$的一个解</li>
<li>设$\eta_1，\eta_2$为非齐次线性方程组$AX=b$的两个解，则$\eta_2-\eta_1$为$AX = 0$的一个解</li>
<li>设$X_1,X_2,\cdots,X_s$为非齐次线性方程组$AX=b$的一组解，则$k_1X_1+k_2X_2+\cdots+k_sX_s$也为$AX = b$的解的充分必要条件是$k_1+k_2+\cdots+k_s=1$</li>
<li>设$X_1,X_2,\cdots,X_s$为非齐次线性方程组$AX=b$的一组解，则$k_1X_1+k_2X_2+\cdots+k_sX_s$为$AX = 0$的解的充分必要条件是$k_1+k_2+\cdots+k_s=0$</li>
</ol>
<p><strong>解方程组</strong></p>
<p>化为行阶梯型或行最简</p>
<p><strong>公共解</strong></p>
<p>$AX=b$，$BX=d$ 两个方程组的解的交集为其公共解</p>
<p>解法:</p>
<ul>
<li>$\begin{pmatrix}<br>A\<br>B<br>\end{pmatrix}X=\begin{pmatrix}<br>b\<br>d<br>\end{pmatrix}$ 该方程组的解即为公共解</li>
<li>先求出(1)的解再代入(2)，解即为公共解</li>
<li>分别求出(1)(2)的通解，令两个方程组的通解相等，从而求出公共解</li>
</ul>
<p><strong>同解</strong></p>
<p>$AX=O$，$BX=O$ ,(1)的解也是(2)的解</p>
<p>(1)、(2)同解的必要条件是$r(A)=r(B)$</p>
<hr>
<h1 id="特征值与特征向量"><a href="#特征值与特征向量" class="headerlink" title="特征值与特征向量"></a>特征值与特征向量</h1><p><strong>定义</strong></p>
<p>1.设$A$是$n$阶矩阵，如果存在一个数$\lambda$及非零$n$维列向量$\alpha$ ,使得$A\alpha=\lambda\alpha$成立，则称$\lambda$是$A$的一个特征值，$\alpha$是矩阵$A$属于特征值$\lambda$的一个特征向量. <strong>$A$有$n$个特征值(包括重数)</strong></p>
<p>$|\lambda E-A|=0$为$A$的特征方程，通过此方程可求出$A$特征值，</p>
<p>$(\lambda_iE-A)X=0$的基础解系为$\lambda_i$对应的线性无关的特征向量</p>
<p>任何特征值都对应无数个特征向量，但其线性无关的特征向量不超过其重数</p>
<p>2.设$A,B$都是$n$阶矩阵，如果存在可逆矩阵$P$,使得$P^{-1}AP=B$，则称矩阵$A,B$相似,记作 $A\sim B$</p>
<p>$P^{-1}A^nP=B^n,A^n=PB^nP^{-1}$</p>
<p>3.已知$B=P^{-1}AP$，$A$的特征值为$\lambda_1,\lambda_2,\dots,\lambda_n$，其对应的特征特征向量为$\alpha_1,\alpha_2,\dots,\alpha_n$,</p>
<p>则 $BP^{-1}=P^{-1}A \rightarrow BP^{-1}\alpha_i=P^{-1}A\alpha_i \rightarrow BP^{-1}\alpha_i=\lambda_iP^{-1}\alpha_i$</p>
<p>即$B$的特征向量为$\beta_i=P^{-1}\alpha_i$</p>
<p><strong>矩阵相似的性质</strong></p>
<ol>
<li><p>$A\sim A$</p>
</li>
<li><p>若$A\sim B$,则$B\sim A$</p>
</li>
<li><p>若$A\sim B$，则$A^T\sim B^T$</p>
<p>且$A，B$可逆，则$A^{-1}\sim B^{-1}$，$$A^<em>\sim B^</em>$$</p>
</li>
<li><p>若$A\sim B$，$B\sim C$,则$A\sim C$</p>
</li>
<li><p>若$A\sim B$，$r(A)=r(B)$,$|\lambda E-A|=|\lambda E-B|$</p>
</li>
<li><p>若$A\sim B$，则$|A|=|B|,tr(A)=tr(B)$</p>
</li>
</ol>
<p><strong>特征值与特征向量的性质​</strong></p>
<p>设$A$为$n$阶矩阵，$\lambda_1,\lambda_2,\cdots,\lambda_n$为其特征值</p>
<ol>
<li>$\lambda_1+\lambda_2+\cdots+\lambda_n=tr(A)$</li>
<li>$\lambda_1\lambda_2\cdots\lambda_n=|A|$</li>
</ol>
<p>设$A$为$n$阶矩阵，且$A\alpha=\lambda_0\alpha$,$f(x)=a_nx^n+\cdots+a_1x+a_0$,令$f(A)=a_nA^n+\cdots+a_1A+a_0E$,则</p>
<ol>
<li>若$A$可逆，则$A^{-1}\alpha=\frac{1}{\lambda_0}\alpha$,即$\frac{1}{\lambda_0}$为$A^{-1}$的特征值，$\alpha$为$A^{-1}$的特征向量</li>
<li>若$A$可逆，则$$A^<em>\alpha=\frac{|A|}{\lambda_0}\alpha$$,即$$\frac{|A|}{\lambda_0}$$为$$A^</em>$$的特征值，$\alpha$为$A^*$的特征向量</li>
<li>$f(A)\alpha=f(\lambda_0)\alpha$,即$f(\lambda_0)$为$f(A)$的特征值，$\alpha$为 $f(A)$的特征向量</li>
</ol>
<p>$A$可逆时，$A^{-1},A^*,A$的特征向量相同</p>
<p><strong>设$A$为$n$阶矩阵,$A$的不同特征值对应的特征向量线性无关</strong></p>
<p><strong>施密特正交化</strong></p>
<p>把一组<strong>线性无关</strong>的向量组化为一组<strong>两两正交</strong>且规范化的向量组的过程称为施密特正交化</p>
<p>设$\alpha_1,\alpha_2,\cdots,\alpha_n$线性无关，</p>
<ol>
<li><p>正交化</p>
<p>令$\beta_1=\alpha_1,\beta_2=\alpha_2-\frac{(\alpha_2,\beta_1)}{(\beta_1,\beta_1)}\beta_1,\cdots$</p>
<p>$\beta_n=\alpha_n-\frac{(\alpha_n,\beta_1)}{(\beta_1,\beta_1)}\beta_1-\frac{(\alpha_n,\beta_2)}{(\beta_2,\beta_2)}\beta_2-\cdots-\frac{(\alpha_n,\beta_{n-1})}{(\beta_{n-1},\beta_{n-1})}\beta_{n-1}$</p>
<p>则$\beta_1,\beta_2,\cdots,\beta_n$两两正交</p>
</li>
<li><p>规范化</p>
<p>令$\gamma_1=\frac{1}{|\beta_1|}\beta_1, \gamma_2=\frac{1}{|\beta_2|}\beta_2,\cdots,\gamma_n=\frac{1}{|\beta_n|}\beta_n$</p>
<p>则$\gamma_1,\gamma_2,\cdots,\gamma_n$为两两正交且规范化的向量组</p>
</li>
</ol>
<p><strong>正交矩阵</strong></p>
<p>设$Q$为$n$阶矩阵，若$Q^TQ=E或QQ^T=E$,称$Q$为正交矩阵</p>
<p>设$Q=(\gamma_1,\gamma_2,\cdots,\gamma_n)$为$n$阶矩阵,则$Q$为正交矩阵的充分必要条件是$\gamma_1,\gamma_2,\cdots,\gamma_n$为两两正交且规范化的向量组</p>
<p>若$Q$为正交矩阵，则$Q^{-1}=Q^T$,$|Q|=\pm1,特征值为-1或1；且Y=QX，则|Y|=|X|$</p>
<p><strong>实对称矩阵 $A^T=A$</strong></p>
<ol>
<li>实对称矩阵的特征值都是实数</li>
<li><strong>实对称矩阵的不同特征值对应的特征向量正交</strong></li>
<li>实对称矩阵一定可以相似对角化，特别地若$A^T=A$,则存在正交矩阵$Q$使得$Q^TAQ=\begin{bmatrix}<br>\lambda_1 &amp; 0 &amp; \cdots &amp; 0\<br>0 &amp; \lambda_2 &amp; \cdots &amp; 0\<br>\vdots &amp; \vdots &amp; \vdots &amp; \vdots\<br>0 &amp; 0 &amp; 0 &amp; \lambda_n<br>\end{bmatrix}$ ,$\lambda_1,\lambda_2,\cdots\lambda_n$为实对称矩阵$A$的特征值</li>
</ol>
<p><strong>矩阵可相似对角化</strong></p>
<ul>
<li>矩阵$A$的特征值都是单值</li>
<li>矩阵$A$为实对称矩阵</li>
<li>矩阵$A$有$n$个线性无关的特征向量</li>
<li>矩阵$A$特征值的重数与其对应的线性无关的特征向量个数相等，即$n-r(\lambda_i E-A)=重数,\lambda_i为重根特征值$</li>
</ul>
<p>设$A$为$n$阶矩阵，则$A$可相似对角化(与对角矩阵相似)的充分必要条件是$A$有$n$个线性无关的特征向量</p>
<ol>
<li><p>由$|\lambda E-A|=0$求出$A$的特征值 $\lambda_1,\lambda_2,\cdots,\lambda_n $</p>
</li>
<li><p>由$(\lambda_i E-A)X=0$求出$A$的特征向量$\delta_1,\delta_2,\cdots,\delta_m  $</p>
</li>
<li><p>若$m&lt;n$时，矩阵$A$不可对角化；若$m=n$时，矩阵$A$可相似对角化</p>
<p>由$A\delta_i=\lambda_i\delta_i $得</p>
<p>$(A\delta_1,A\delta_2,\cdots,A\delta_n)=(\lambda_1\delta_1,\lambda_2\delta_2 ,\cdots,\lambda_n\delta_n )$ 即</p>
<p>$A(\delta_1,\delta_2,\cdots,\delta_n)=(\delta_1,\delta_2,\cdots,\delta_n)\begin{bmatrix}<br>\lambda_1 &amp; 0 &amp; \cdots &amp; 0\<br>0 &amp; \lambda_2 &amp; \cdots &amp; 0\<br>\vdots &amp; \vdots &amp; \vdots &amp; \vdots\<br>0 &amp; 0 &amp; 0 &amp; \lambda_n<br>\end{bmatrix}$</p>
<p>令$P=(\delta_1,\delta_2,\cdots,\delta_n)$,则$P$可逆，且$P^{-1}AP=\begin{bmatrix}<br>\lambda_1 &amp; 0 &amp; \cdots &amp; 0\<br>0 &amp; \lambda_2 &amp; \cdots &amp; 0\<br>\vdots &amp; \vdots &amp; \vdots &amp; \vdots\<br>0 &amp; 0 &amp; 0 &amp; \lambda_n<br>\end{bmatrix}$</p>
</li>
</ol>
<p><strong>实对称矩阵的对角化</strong></p>
<ol>
<li>若求可逆矩阵$P$，则按上述步骤即可</li>
<li>若求正交矩阵$Q$,将$\delta_1,\delta_2,\cdots,\delta_n$施密特正交化和规范化，令$Q=(\delta_1,\delta_2,\cdots,\delta_n)$,则$Q^TAQ=\begin{bmatrix}<br>\lambda_1 &amp; 0 &amp; \cdots &amp; 0\<br>0 &amp; \lambda_2 &amp; \cdots &amp; 0\<br>\vdots &amp; \vdots &amp; \vdots &amp; \vdots\<br>0 &amp; 0 &amp; 0 &amp; \lambda_n<br>\end{bmatrix}$</li>
</ol>
<p><strong>矩阵相似的判断</strong></p>
<p>$A,B$相似的必要条件是$|\lambda E-A|=|\lambda E-B|$,即$A,B$具有相同的特征值</p>
<p>若$A,B$特征值相同，判断$A,B$相似一般分如下情形：</p>
<ol>
<li>若$A,B$都可相似对角化，则$A \sim B$</li>
<li>若$A,B$一个可相似对角化，一个不可相似对角化，则$A,B$一定不相似</li>
<li>若$A,B$都不可相似对角化，一般不讨论</li>
</ol>
<hr>
<h1 id="二次型"><a href="#二次型" class="headerlink" title="二次型"></a>二次型</h1><p><strong>定义1</strong></p>
<p>含有$n$个变量$x_1,x_2,\cdots,x_n$的二次齐次函数</p>
<p>$f(x_1,x_2,\cdots,x_n)=a_{11}x_1^2+a_{22}x_2^2+\cdots+a_{nn}x_n^2$</p>
<p>​                                    $+2a_{12}x_1x_2+2a_{13}x_1x_3+\cdots+2a_{1n}x_1x_n$</p>
<p>​                                    $+2a_{23}x_2x_3+\cdots+2a_{2n}x_2x_n$</p>
<p>​                                    $+\cdots+2a_{n-1,n}x_{n-1}x_n$ </p>
<p>称为$n$元二次型.若规定$a_{ij}=a_{ji}$，则二次型有矩阵表示$f(x_1,x_2,\cdots,x_n)=x^TAx$,</p>
<p>其中$x=[x_1,x_2,\cdots,x_n]^T,A=[a_{ij}]$且$A^T=A$,称$A$为二次型的矩阵</p>
<p>例如：$f(x_1,x_2)=x_1^2+5x_2^2+6x_1x_2$，有</p>
<p>​            $f(x_1,x_2)=x_1^2+3x_1x_2+3x_1x_2+5x_2^2$</p>
<p>​                              $=x_1(x_1+3_x2)+x_2(3x_1+5x_2)$</p>
<p>​                              $=[x_1,x_2] \begin{bmatrix}x_1 &amp; 3x_2\ 3x_1 &amp; 5x_2 \end{bmatrix}$</p>
<p>​                             $=[x_1,x_2] \begin{bmatrix}1 &amp; 3\ 3 &amp; 5 \end{bmatrix} \begin{bmatrix}x_1\ x_2\end{bmatrix}=x^TAx$</p>
<p>若对任何$x\neq0$,恒有$x^TAx&gt;0$，则称二次型为正定二次型</p>
<ul>
<li><p>若二次型中只含有变量的平方项，即$x^TAx=d_1x_1^2+d_2x_2^2+\cdots+d_nx_n^2$称为二次型的标准形</p>
</li>
<li><p>若标准形中，平方项的系数$d_j$为1，-1或0，即$x^TAx=x_1^2+x_2^2+\cdots+x_p^2-x_{p+1}x^2+\cdots-x_{p+q}^2$ 称为二次型的规范形</p>
</li>
<li><p>标准形中，正平方项的个数$p$称为二次型的正惯性指数，负平方项的个数$q$称为二次型的负惯性指数，系数不为0的个数为二次型的秩</p>
</li>
</ul>
<p><strong>定义2</strong></p>
<p>若$\left{\begin{matrix}<br>x_1=c_{11}y_1+c_{12}y_2+c_{13}y_3\<br>x_2=c_{21}y_1+c_{22}y_2+c_{23}y_3\<br>x_3=c_{31}y_1+c_{32}y_2+c_{33}y_3<br>\end{matrix}\right.$满足$|C|=\begin{bmatrix}<br>c_{11} &amp; c_{12} &amp; c_{13}\<br>c_{21} &amp; c_{22} &amp; c_{23}\<br>c_{31} &amp; c_{32} &amp; c_{33}<br>\end{bmatrix} \neq0$ 称$x=[x_1,x_2,x_3]^T到y=[y_1,y_2,y_3]$的</p>
<p>坐标变换，即$\begin{bmatrix}<br>x_1\<br>x_2\<br>x_3<br>\end{bmatrix}=\begin{bmatrix}<br>c_{11} &amp; c_{12} &amp; c_{13}\<br>c_{21} &amp; c_{22} &amp; c_{23}\<br>c_{31} &amp; c_{32} &amp; c_{33}<br>\end{bmatrix}\begin{bmatrix}<br>y_1\<br>y_2\<br>y_3<br>\end{bmatrix}$,或$x=Cy$</p>
<p>两个$n$阶矩阵$A$和$B$，如果存在可逆矩阵$C$使得$C^TAC=B$则称矩阵$A$和$B$合同，并称$A$到$B$的变换为合同变换，$C$为合同变换矩阵</p>
<p><strong>定理1</strong></p>
<p>变量$x=[x_1,x_2,\dots,x_n]^T$的$n$元二次型$x^TAx$经坐标变换$x=Cy$后，化为变量$y=[y_1,y_2,\cdots,y_n]$的$n$元二次型$y^TBy$.</p>
<p>$x^TAx=(Cy)^TA(Cy)=y^TC^TACy=y^TBy$,其中$B=C^TAC$</p>
<p><strong>定理2</strong></p>
<p>任意的$n$元二次型$x^TAx$都可以通过坐标变换化成标准形</p>
<p>对任一个$n$元二次型$x^TAx$，其中$A$是$n$阶实对称矩阵，必存在正交变换$x=Qy$ ($Q$是正交矩阵)，使得$x^TAx$化为标准形$\lambda_1y_1^2+\lambda_2y_2^2+\cdots+\lambda_ny_n^2$</p>
<p><strong>定理3</strong></p>
<p>任一$n$阶是对称矩阵$A$，总可以合同于一个对角矩阵，即$C^TAC=\begin{bmatrix}<br>d_1 &amp; 0 &amp; \cdots &amp; 0\<br>0 &amp; d_2 &amp; \cdots &amp; 0\<br>\vdots &amp; \vdots &amp; \vdots &amp; \vdots\<br>0 &amp; 0 &amp; 0 &amp; d_n<br>\end{bmatrix}$</p>
<p><strong>定理4</strong>​</p>
<p>$n$元二次型$x^TAx$正定的充分必要条件:</p>
<ol>
<li>$A$的正惯性指数是$n$</li>
<li>$A$与$E$合同，且存在可逆矩阵$C$，使得$C^TAC=E$</li>
<li>$A$的所有特征值均为正数</li>
<li>$A$的各阶顺序主子式均大于零</li>
</ol>
<p>版权声明：原创,转载请注明来源,否则律师函警告</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jiaopaner.github.io/2019/04/26/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" data-id="ck4mhjkdg003ww6zw9ra279nn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E5%AD%A6/" rel="tag">数学</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-小贴士" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/15/%E5%B0%8F%E8%B4%B4%E5%A3%AB/" class="article-date">
  <time datetime="2019-03-15T08:06:23.000Z" itemprop="datePublished">2019-03-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/15/%E5%B0%8F%E8%B4%B4%E5%A3%AB/">小贴士</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p>Q： Visual Studio 编译工程报错:error C4996: ‘strtok’: This function or variable may be unsafe. Consider using strtok_s instead<br>A：工程属性 –&gt;C/C++ –&gt; 预处理器 –&gt; 预处理器定义,添加宏定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_CRT_SECURE_NO_WARNINGS</span><br></pre></td></tr></table></figure>

<hr>
<p>Q： pthread.h中报错：C2011“timespec”:“struct”类型重定义<br>A：tim.h已定义，pthread.h添加如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined( PTHREAD_H )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTHREAD_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_STRUCT_TIMESPEC</span></span><br></pre></td></tr></table></figure>

<hr>
<p>Q：Visual Studio 工程编译dll,接口的定义<br>A：接口的头文件应如下声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIB_API __declspec(dllexport) <span class="comment">//导出函数</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">	<span class="function">LIB_API <span class="keyword">char</span>*   <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>Q：C++调用DLL</p>
<ul>
<li><p>dll的创建</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">__declspec(dllexport) <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// __cplusplus</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译上述工程为dll，即生成test.dll，并复制到调用该dll工程的编译目录</p>
</li>
<li><p>dll的使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#includ<span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*padd)</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">	HMODULE test = LoadLibrary(<span class="string">"test.dll"</span>);</span><br><span class="line">	<span class="keyword">if</span> (test != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		padd add = (padd)GetProcAddress(test,<span class="string">"add"</span>);</span><br><span class="line">		<span class="keyword">if</span> (add != <span class="literal">NULL</span>)&#123;	</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">1</span>,<span class="number">0</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<p>Q:cmake 简单编译命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxvf <span class="built_in">test</span></span><br><span class="line"><span class="built_in">cd</span> <span class="built_in">test</span></span><br><span class="line">sudo mkdir build</span><br><span class="line"><span class="built_in">cd</span> build/</span><br><span class="line"></span><br><span class="line">sudo cmake -DCMAKE_INSTALL_PREFIX=/home/<span class="built_in">test</span> .. <span class="comment">#安装目录</span></span><br><span class="line">sudo make -j4 <span class="comment">#编译</span></span><br><span class="line">sudo make install <span class="comment">#安装</span></span><br><span class="line">sudo ldconfig <span class="comment">#更新软连接</span></span><br></pre></td></tr></table></figure>

<hr>
<p>Q: mac安装LLVM</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="built_in">where</span>-you-want-llvm-to-live</span><br><span class="line">$ svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> llvm/tools</span><br><span class="line">$ svn co http://llvm.org/svn/llvm-project/cfe/trunk clang</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> llvm/tools/clang/tools</span><br><span class="line">$ svn co http://llvm.org/svn/llvm-project/clang-tools-extra/trunk extra</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> llvm/projects</span><br><span class="line">$ svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> llvm</span><br><span class="line">$ mkdir build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake -G <span class="string">"Unix Makefiles"</span> ..</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure>

<hr>
<p>Q:cJSON的使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cJSON.h"</span></span></span><br><span class="line">cJSON  *root = cJSON_CreateObject();</span><br><span class="line">cJSON  *bboxs = cJSON_CreateArray();</span><br><span class="line"><span class="keyword">char</span> *resultJson;</span><br><span class="line"></span><br><span class="line">cJSON_AddNumberToObject(root, <span class="string">"status"</span>, <span class="number">1</span>);</span><br><span class="line">cJSON_AddStringToObject(root, <span class="string">"msg"</span>, <span class="string">"detect ok"</span>);</span><br><span class="line">cJSON_AddItemToObject(root, <span class="string">"bboxs"</span>, bboxs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">  cJSON  *bbox;</span><br><span class="line">  cJSON_AddItemToArray(bboxs, bbox = cJSON_CreateObject());</span><br><span class="line">  cJSON_AddNumberToObject(bbox, <span class="string">"score"</span>, <span class="number">99</span>);</span><br><span class="line">  cJSON_AddNumberToObject(bbox, <span class="string">"x"</span>, <span class="number">1</span>);</span><br><span class="line">  cJSON_AddNumberToObject(bbox, <span class="string">"y"</span>, <span class="number">2</span>);</span><br><span class="line">  cJSON_AddNumberToObject(bbox, <span class="string">"width"</span>, <span class="number">3</span>);</span><br><span class="line">  cJSON_AddNumberToObject(bbox, <span class="string">"height"</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line">resultJson = cJSON_PrintUnformatted(result);</span><br></pre></td></tr></table></figure>

<hr>
<p>Q:c#调用dll</p>
<p>note:若dll为X64,则c#应编译x64,否则报错</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">DllImport(@<span class="meta-string">"facedetection.dll"</span>, EntryPoint = <span class="meta-string">"facedetect"</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">extern</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">facedetect</span>(<span class="params"><span class="keyword">string</span> src</span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">string</span> result = facedetect(<span class="string">"test.jpg"</span>);</span><br><span class="line">            Console.WriteLine(result);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>Q：opencv Mat和byte互转</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span>* <span class="title">matToBytes</span><span class="params">(Mat <span class="built_in">image</span>)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> <span class="built_in">size</span> = <span class="built_in">image</span>.total() * <span class="built_in">image</span>.elemSize();</span><br><span class="line">	 <span class="keyword">unsigned</span> <span class="keyword">char</span>* bytes = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[<span class="built_in">size</span>];  <span class="comment">// you will have to delete[] that later</span></span><br><span class="line">	 <span class="built_in">std</span>::<span class="built_in">memcpy</span>(bytes, <span class="built_in">image</span>.data, <span class="built_in">size</span> * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>));</span><br><span class="line">	 <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Mat <span class="title">bytesToMat</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* bytes,<span class="keyword">int</span> <span class="built_in">width</span>,<span class="keyword">int</span> <span class="built_in">height</span>)</span></span>&#123;</span><br><span class="line">    Mat <span class="built_in">image</span> = Mat(<span class="built_in">height</span>,<span class="built_in">width</span>,CV_8UC3,bytes).clone(); <span class="comment">// make a copy</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">image</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>Q:opencv Mat 转std::vector std::vector转std::string</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat output = output.reshape(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vetor = (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;)output;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">ss &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">16</span>);<span class="comment">//精度设置</span></span><br><span class="line"><span class="built_in">std</span>::copy(<span class="built_in">vector</span>.<span class="built_in">begin</span>(), <span class="built_in">vector</span>.<span class="built_in">end</span>(), <span class="built_in">std</span>::ostream_iterator&lt;<span class="keyword">double</span>&gt;(ss, <span class="string">","</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> values = ss.str();</span><br><span class="line">values.pop_back();<span class="comment">//去掉末尾多余的分隔符</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; values;</span><br><span class="line"></span><br><span class="line"><span class="function">Mat <span class="title">convertToMat</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v;</span><br><span class="line">	<span class="built_in">std</span>::<span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line">	ss &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">16</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> token;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">std</span>::getline(ss, token, <span class="string">','</span>)) &#123;</span><br><span class="line">		v.push_back(<span class="built_in">std</span>::stod(token));</span><br><span class="line">	&#125;</span><br><span class="line">	Mat output = cv::Mat(v, <span class="literal">true</span>).reshape(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cv::<span class="function">FileStorage <span class="title">fs</span><span class="params">(<span class="string">"../features.xml"</span>, cv::FileStorage::WRITE)</span></span>;</span><br><span class="line">fs &lt;&lt; <span class="string">"features"</span> &lt;&lt; output;</span><br><span class="line">fs.<span class="built_in">release</span>();</span><br></pre></td></tr></table></figure>

<hr>
<p>Q: opencv 截取图片的矩形区域</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rectangle(<span class="built_in">image</span>, Rect(x, y, w, h), Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line">Mat dst = <span class="built_in">image</span>(cv::Range(y,y+h),cv::Range(x,x+w));</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p>Q：python打包发布</p>
<p>1.项目根目录新建setup.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup</span><br><span class="line">setup(</span><br><span class="line"> name=<span class="string">'test'</span>,  <span class="comment">#打包的输出文件名</span></span><br><span class="line"> version=<span class="string">'1.0.0'</span>,</span><br><span class="line"> py_modules=[<span class="string">'test'</span>] <span class="comment">#打包的.py文件</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>依赖文件 requirements.txt生成</p>
<p>pip freeze &gt; requirements.txt</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">opencv&#x3D;&#x3D;3.4.2</span><br><span class="line">numpy&#x3D;&#x3D;1.16.4</span><br><span class="line">scikit-image&#x3D;&#x3D;0.15.0</span><br></pre></td></tr></table></figure>

<p>或者 conda list -e &gt; requirements.txt</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numpy=1.16.4</span><br><span class="line">opencv=3.4.2</span><br><span class="line">scikit-image=0.15.0</span><br></pre></td></tr></table></figure>

<p>2.项目根目录下执行命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo python setup.py sdist</span><br></pre></td></tr></table></figure>

<p>生成dist目录且包含test-1.0.0.tar.gz分发包</p>
<p>3.安装：解压分发包并定位到解压目录后执行安装命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt <span class="comment">#安装依赖 或者 conda install --yes --file requirements.txt</span></span><br><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure>

<p>4.使用</p>
<p>import test<br>test.sayHello();//#调用模块的sayHello方法</p>
<hr>
<p>Q:jupyter notebook 运行于指定的conda环境上</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install nb_conda</span><br></pre></td></tr></table></figure>

<p>重启jupyter notebook 选择kernel即可</p>
<blockquote>
<blockquote>
<hr>
<h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><p>Q：iframe父/子页面互相调用方法</p>
</blockquote>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById("iframeId").contentWindow.childMethod()/childVariable;</span><br><span class="line">parent.parentMethod()/parentVariable</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p>Q：springboot切面编程实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebLogAspect</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义一个切入点，对该包下的所有函数方法执行前，执行@Before()</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(public * com.jp.controller..*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">webLog</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"webLog()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 接收到请求，记录请求内容</span></span><br><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = attributes.getRequest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录下请求内容</span></span><br><span class="line">        log.info(<span class="string">"URL : "</span> + request.getRequestURL().toString());</span><br><span class="line">        log.info(<span class="string">"HTTP_METHOD : "</span> + request.getMethod());</span><br><span class="line">        log.info(<span class="string">"IP : "</span> + request.getRemoteAddr());</span><br><span class="line">        log.info(<span class="string">"CLASS_METHOD : "</span> + joinPoint.getSignature().getDeclaringTypeName() + <span class="string">"."</span> + joinPoint.getSignature().getName());</span><br><span class="line">        log.info(<span class="string">"ARGS : "</span> + Arrays.toString(joinPoint.getArgs()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(returning = <span class="string">"ret"</span>, pointcut = <span class="string">"webLog()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">(Object ret)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 处理完请求，返回内容</span></span><br><span class="line">        log.info(<span class="string">"RESPONSE : "</span> + ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Q：Mac，MavenReportException: Error while creating archive: Unable to find javadoc command: The environment variable JAVA_HOME is not correctly set</p>
<p>在pom.xml文件中添加javadoc命令的位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line"> 	&lt;javadocExecutable&gt;&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;jdk1.8.0_151.jdk&#x2F;Contents&#x2F;Home&#x2F;bin&#x2F;javadoc&lt;&#x2F;javadocExecutable&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h1><p>Q：利用nginx共享文件夹</p>
<p>nginx.conf添加如下配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       8000;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    charset utf-8;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">    root &#x2F;home;#共享根目录下的home文件夹</span><br><span class="line">    # 索引</span><br><span class="line">    autoindex on;</span><br><span class="line">    # 显示文件大小</span><br><span class="line">    autoindex_exact_size on;</span><br><span class="line">    # 显示文件时间</span><br><span class="line">    autoindex_localtime on;</span><br><span class="line">    #index  index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Q:更改ubuntu源为阿里云源</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line"></span><br><span class="line">sudo vim /etc/apt/source.list</span><br><span class="line"></span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu xenial main restricted <span class="comment">#Added by software-properties</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe <span class="comment">#Added by software-properties</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe <span class="comment">#Added by software-properties</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse <span class="comment">#Added by software-properties</span></span><br><span class="line">deb http://archive.canonical.com/ubuntu xenial partner</span><br><span class="line">deb-src http://archive.canonical.com/ubuntu xenial partner</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe <span class="comment">#Added by software-properties</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse</span><br><span class="line"></span><br><span class="line">apt-get update </span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line">mv /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"deb http://mirrors.163.com/debian/ jessie main non-free contrib"</span> &gt;&gt; /etc/apt/sources.list</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"deb http://mirrors.163.com/debian/ jessie-proposed-updates main non-free contrib"</span> &gt;&gt;/etc/apt/sources.list</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"deb-src http://mirrors.163.com/debian/ jessie main non-free contrib"</span> &gt;&gt;/etc/apt/sources.list</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"deb-src http://mirrors.163.com/debian/ jessie-proposed-updates main non-free contrib"</span> &gt;&gt;/etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">apt-get update</span><br></pre></td></tr></table></figure>

<hr>
<p>版权声明：原创,转载请注明来源,否则律师函警告</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jiaopaner.github.io/2019/03/15/%E5%B0%8F%E8%B4%B4%E5%A3%AB/" data-id="ck4mhjkd9003dw6zw44r1b8j8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B0%8F%E8%B4%B4%E5%A3%AB/" rel="tag">小贴士</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-opencv3(1-2) linux配置opencv3开发环境" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/11/opencv3(1-2)%20linux%E9%85%8D%E7%BD%AEopencv3%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/" class="article-date">
  <time datetime="2019-03-11T15:00:35.000Z" itemprop="datePublished">2019-03-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/opencv3/">opencv3</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/11/opencv3(1-2)%20linux%E9%85%8D%E7%BD%AEopencv3%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">opencv3(1-2) linux配置opencv3开发环境</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>环境</strong><br>ubuntu<br>cmake<br>cmake-gui<br>opencv-3.3.1 下载地址:<a href="https://opencv.org/releases.html" target="_blank" rel="noopener">https://opencv.org/releases.html</a><br>opencv_contrib-3.3.1 下载地址:<a href="https://github.com/opencv/opencv_contrib/releases" target="_blank" rel="noopener">https://github.com/opencv/opencv_contrib/releases</a></p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul>
<li>更新系统<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></li>
<li>安装cmake及必要依赖<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line">sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev</span><br><span class="line">sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev</span><br></pre></td></tr></table></figure></li>
<li>安装cmake-gui<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install cmake-qt-gui</span><br></pre></td></tr></table></figure></li>
<li>解压opencv以及opecv_contrib至同一目录<br><img src="/images/opencv3/2-1.png" alt=""></li>
<li>opencv目录内新建build目录<br><img src="/images/opencv3/2-2.png" alt=""><br>build目录内打开终端运行cmake-gui<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake-gui</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="编译-安装"><a href="#编译-安装" class="headerlink" title="编译 / 安装"></a>编译 / 安装</h1><ul>
<li><p>配置源码目录以及编译目录<br><img src="/images/opencv3/2-3.png" alt=""></p>
</li>
<li><p>执行Configure<br>Unix Makefiles - &gt; Use default native compilers(默认) - &gt; Finish<br><img src="/images/opencv3/2-4.png" alt=""></p>
</li>
<li><p>配置编译属性<br>CMAKE_BUILD_TYPE：RELEASE<br>CMAKE_INSTALL_PREFIX：/home/jiaopan/app/opencv #配置安装目录 可默认<br><img src="/images/opencv3/2-5.png" alt=""><br>OPENCV_EXTRA_MODULES_PATH：/home/jiaopan/app/opencv3/opencv_contrib-3.3.1/modules #opencv_contrib的modules目录<br><img src="/images/opencv3/2-6.png" alt=""></p>
</li>
<li><p>执行Generate 生成配置文件</p>
</li>
<li><p>build目录内打开终端 执行make命令开始编译 ，100%时编译成功<br><img src="/images/opencv3/2-7.png" alt=""></p>
</li>
<li><p>编译成功，执行make install 命令进行安装</p>
</li>
<li><p>编译时问题</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.问题1</span></span><br><span class="line">collect2: error: ld returned 1 <span class="built_in">exit</span> status</span><br><span class="line">modules/core/CMakeFiles/opencv_perf_core.dir/build.make:882: recipe <span class="keyword">for</span> target <span class="string">'bin/opencv_perf_core'</span> failed</span><br><span class="line">make[2]: *** [bin/opencv_perf_core] Error 1</span><br><span class="line">CMakeFiles/Makefile2:2627: recipe <span class="keyword">for</span> target <span class="string">'modules/core/CMakeFiles/opencv_perf_core.dir/all'</span> failed</span><br><span class="line">make[1]: *** [modules/core/CMakeFiles/opencv_perf_core.dir/all] Error 2</span><br><span class="line">Makefile:160: recipe <span class="keyword">for</span> target <span class="string">'all'</span> failed</span><br><span class="line">make: *** [all] Error 2</span><br><span class="line"><span class="comment">#解决：缺少ffmpeg</span></span><br><span class="line"><span class="comment">#安装ffmpeg</span></span><br><span class="line">sudo add-apt-repository ppa:djcj/hybrid  </span><br><span class="line">sudo apt-get update  </span><br><span class="line">sudo apt-get install ffmpeg</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ld.so.conf.d/opencv.conf <span class="comment">#添加 /home/jiaopan/app/opencv/lib内容 ，即opencv安装目录下的lib目录路径</span></span><br><span class="line">sudo ldconfig <span class="comment">#更新动态链接库</span></span><br><span class="line">sudo vim /etc/bash.bashrc </span><br><span class="line"><span class="comment">#末尾添加如下内容</span></span><br><span class="line">PKG_CONFIG_PATH=<span class="variable">$PKG_CONFIG_PATH</span>:opencv安装目录/lib/pkgconfig </span><br><span class="line"><span class="built_in">export</span> PKG_CONFIG_PATH</span><br><span class="line"><span class="comment">#-----------------------------------------</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile <span class="comment">#更新环境变量 </span></span><br><span class="line">pkg-config --cflags --libs opencv <span class="comment">#测试是否安装成功</span></span><br></pre></td></tr></table></figure>
<p>安装成功:<br><img src="/images/opencv3/2-8.png" alt=""></p>
<h1 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h1><ul>
<li><p>eclipse for c/c++ 新建C/C++项目</p>
</li>
<li><p>添加opencv包含目录<br><img src="/images/opencv3/2-9.png" alt=""></p>
</li>
<li><p>引入库文件 可通过pkg-config –libs opencv 命令查看库文件<br><img src="/images/opencv3/2-10.png" alt=""></p>
</li>
<li><p>复制到图片到项目根路径下<br><img src="/images/opencv3/2-11.png" alt=""></p>
</li>
<li><p>测试代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 读入一张图片</span></span><br><span class="line">    cv::Mat image=cv::imread(<span class="string">"dog.jpg"</span>);</span><br><span class="line">    <span class="comment">// 在窗口中显示</span></span><br><span class="line">    cv::imshow(<span class="string">"test"</span>,image);</span><br><span class="line">    <span class="comment">// 等待6000 ms后窗口自动关闭</span></span><br><span class="line">    cv::waitKey(<span class="number">6000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>右键项目 build project 执行编译</p>
</li>
<li><p>编译成功，右键项目执行run as local C/C++ Application<br><img src="/images/opencv3/2-12.png" alt=""></p>
</li>
</ul>
<p>版权声明：原创,转载请注明来源,否则律师函警告</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jiaopaner.github.io/2019/03/11/opencv3(1-2)%20linux%E9%85%8D%E7%BD%AEopencv3%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/" data-id="ck4mhjkd60032w6zw8u4sbl0t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/opencv3/" rel="tag">opencv3</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-eclipse编译C-C++为dll供Java调用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/10/eclipse%E7%BC%96%E8%AF%91C-C++%E4%B8%BAdll%E4%BE%9BJava%E8%B0%83%E7%94%A8/" class="article-date">
  <time datetime="2019-03-10T10:34:24.000Z" itemprop="datePublished">2019-03-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/10/eclipse%E7%BC%96%E8%AF%91C-C++%E4%B8%BAdll%E4%BE%9BJava%E8%B0%83%E7%94%A8/">编译C/C++为dll供Java调用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="开发环境准备"><a href="#开发环境准备" class="headerlink" title="开发环境准备"></a>开发环境准备</h1><ul>
<li>下载 Eclipse IDE for C/C++<br>地址:<a href="https://www.eclipse.org/downloads/packages/" target="_blank" rel="noopener">https://www.eclipse.org/downloads/packages/</a><br><img src="/images/2019/3/10/1.jpg" alt=""></li>
<li>安装mingw64<br>地址:<a href="http://www.mingw-w64.org/doku.php/download" target="_blank" rel="noopener">http://www.mingw-w64.org/doku.php/download</a><br><img src="/images/2019/3/10/2.jpg" alt=""><br>1）配置mingw64环境变量<br>C_INCLUDE_PATH : mingw64安装目录\include<br>LIBRARY_PATH :mingw64安装目录\lib<br><img src="/images/2019/3/10/3.jpg" alt=""><br>2）系统变量的path变量中添加 mingw64安装目录\bin<br>注意:以防万一,本文也将include和lib目录也加入了path变量中<br><img src="/images/2019/3/10/4.jpg" alt=""><br>3）测试 cmd里执行如下命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -v</span><br></pre></td></tr></table></figure>
输出版本信息则安装成功<br><img src="/images/2019/3/10/5.jpg" alt=""></li>
</ul>
<h1 id="编译C-C-为dll"><a href="#编译C-C-为dll" class="headerlink" title="编译C/C++为dll"></a>编译C/C++为dll</h1><p><strong>eclipse环境下</strong></p>
<ul>
<li>eclipse新建项目<br><img src="/images/2019/3/10/6.jpg" alt=""><br><img src="/images/2019/3/10/7.jpg" alt=""></li>
<li>新建源代码文件<br><img src="/images/2019/3/10/8.jpg" alt=""></li>
<li>编写方法<br><img src="/images/2019/3/10/9.jpg" alt=""></li>
<li>右键项目 properties 配置<br>1）Tool Chain Editor的配置<br><img src="/images/2019/3/10/10.jpg" alt=""><br>2）settings的配置<br><img src="/images/2019/3/10/11.jpg" alt=""><br><img src="/images/2019/3/10/12.jpg" alt=""><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Wl,--add-stdcall-alias -static-libgcc -static-libstdc++ -shared</span><br></pre></td></tr></table></figure>
<img src="/images/2019/3/10/13.jpg" alt=""><br><img src="/images/2019/3/10/14.jpg" alt=""><br><img src="/images/2019/3/10/15.jpg" alt=""><br><img src="/images/2019/3/10/16.jpg" alt=""></li>
<li>右键项目 build project 执行编译<br><img src="/images/2019/3/10/17.jpg" alt=""><br>编译成功<br><img src="/images/2019/3/10/18.jpg" alt=""><br>在eclipse的工作目录 test项目下的debug目录可以找到编译好的dll文件<br><img src="/images/2019/3/10/19.jpg" alt=""></li>
</ul>
<p><strong>visual studio 2015环境下</strong></p>
<ul>
<li>新建win32项目<br><img src="/images/2019/3/10/22.jpg" alt=""><br><img src="/images/2019/3/10/23.jpg" alt=""></li>
<li>新建头文件<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DLL_IMP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_API __declspec(dllexport) <span class="comment">//导出函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DLL_API</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">	<span class="function">DLL_API <span class="keyword">char</span>*   <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/images/2019/3/10/24.jpg" alt=""></li>
<li>新建源文件<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_IMP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"say.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>*  <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hello"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/images/2019/3/10/25.jpg" alt=""></li>
<li>设置属性 编译为dll<br><img src="/images/2019/3/10/26.jpg" alt=""><br><img src="/images/2019/3/10/27.jpg" alt=""><h1 id="Java调用dll"><a href="#Java调用dll" class="headerlink" title="Java调用dll"></a>Java调用dll</h1></li>
<li>下载JNA jna.jar 地址:<a href="https://mvnrepository.com/artifact/com.sun.jna/jna/3.0.9" target="_blank" rel="noopener">https://mvnrepository.com/artifact/com.sun.jna/jna/3.0.9</a></li>
<li>新建Java项目 引入jna.jar 并将dll拷贝到项目根路径下(否则需要填写dll的绝对路径)<br><img src="/images/2019/3/10/20.jpg" alt=""></li>
<li>编写调用接口类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.jna.Library;</span><br><span class="line"><span class="keyword">import</span> com.sun.jna.Native;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Clibrary</span> <span class="keyword">extends</span> <span class="title">Library</span></span>&#123;</span><br><span class="line">	<span class="comment">//使用eclipse环境下生成的dll</span></span><br><span class="line">	Clibrary instance = (Clibrary) Native.loadLibrary(<span class="string">"libtest"</span>, Clibrary<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	<span class="comment">//dll中的方法 声明需一致</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//使用vs 2015生成的dll</span></span><br><span class="line">	<span class="comment">//Clibrary instance = (Clibrary) Native.loadLibrary("yolo-dll", Clibrary.class);</span></span><br><span class="line">	<span class="comment">//String say();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编写Main类 调用方法执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Clibrary.instance.sayHello();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果 如图<br><img src="/images/2019/3/10/21.jpg" alt=""></p>
<p>版权声明：原创,转载请注明来源,否则律师函警告</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://jiaopaner.github.io/2019/03/10/eclipse%E7%BC%96%E8%AF%91C-C++%E4%B8%BAdll%E4%BE%9BJava%E8%B0%83%E7%94%A8/" data-id="ck4mhjkch0012w6zw44gv52hj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JNA/" rel="tag">JNA</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/leetcode/">leetcode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/opencv3/">opencv3</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/">数字图像处理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E5%AD%A6/">数学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/">目标检测</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JNA/" rel="tag">JNA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hadoop/" rel="tag">hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jdk/" rel="tag">jdk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/make/" rel="tag">make</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mxnet/" rel="tag">mxnet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/" rel="tag">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/opencv/" rel="tag">opencv</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/opencv-samples/" rel="tag">opencv samples</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/opencv3/" rel="tag">opencv3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E8%B4%B4%E5%A3%AB/" rel="tag">小贴士</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" rel="tag">数字图像处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%AD%A6/" rel="tag">数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="tag">模型转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag">深度学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/" rel="tag">神经网络模型</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 16px;">C++</a> <a href="/tags/JNA/" style="font-size: 10px;">JNA</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/hadoop/" style="font-size: 10px;">hadoop</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/jdk/" style="font-size: 10px;">jdk</a> <a href="/tags/leetcode/" style="font-size: 20px;">leetcode</a> <a href="/tags/make/" style="font-size: 10px;">make</a> <a href="/tags/mxnet/" style="font-size: 10px;">mxnet</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/opencv/" style="font-size: 10px;">opencv</a> <a href="/tags/opencv-samples/" style="font-size: 10px;">opencv samples</a> <a href="/tags/opencv3/" style="font-size: 16px;">opencv3</a> <a href="/tags/%E5%B0%8F%E8%B4%B4%E5%A3%AB/" style="font-size: 10px;">小贴士</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 14px;">操作系统</a> <a href="/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" style="font-size: 12px;">数字图像处理</a> <a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 12px;">数学</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 18px;">数据结构</a> <a href="/tags/%E6%A8%A1%E5%9E%8B%E8%BD%AC%E6%8D%A2/" style="font-size: 10px;">模型转换</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">深度学习</a> <a href="/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/" style="font-size: 12px;">神经网络模型</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/12/18/elasticsearch%20%E6%95%99%E7%A8%8B/">elasticsearch 教程</a>
          </li>
        
          <li>
            <a href="/2019/11/20/hadoop%20spark/">hadoop spark</a>
          </li>
        
          <li>
            <a href="/2019/11/01/android%E4%BD%BF%E7%94%A8opencv%20native%E6%96%B9%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">android使用opencv native方式环境搭建</a>
          </li>
        
          <li>
            <a href="/2019/10/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E8%BD%AC%E6%8D%A2/">深度学习模型转换</a>
          </li>
        
          <li>
            <a href="/2019/09/19/mxnet%20Windows%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85CPU%E7%89%88/">mxnet Windows编译安装CPU版 c++ api</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 JiaoPan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>